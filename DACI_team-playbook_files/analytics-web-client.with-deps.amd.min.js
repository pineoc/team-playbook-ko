(function (define) { define( [], function() {
    /******/ return function(modules) {
        /******/
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: !1,
                /******/
                exports: {}
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.l = !0, module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // define getter function for harmony exports
        /******/
        /******/
        /******/
        // getDefaultExport function for compatibility with non-harmony modules
        /******/
        /******/
        /******/
        // Object.prototype.hasOwnProperty.call
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.d = function(exports, name, getter) {
            /******/
            __webpack_require__.o(exports, name) || /******/
            Object.defineProperty(exports, name, {
                /******/
                configurable: !1,
                /******/
                enumerable: !0,
                /******/
                get: getter
            });
        }, __webpack_require__.n = function(module) {
            /******/
            var getter = module && module.__esModule ? /******/
            function() {
                return module.default;
            } : /******/
            function() {
                return module;
            };
            /******/
            /******/
            return __webpack_require__.d(getter, "a", getter), getter;
        }, __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 133);
    }([ /* 0 */
    /***/
    function(module, exports) {
        var core = module.exports = {
            version: "2.4.0"
        };
        "number" == typeof __e && (__e = core);
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0, exports.default = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        };
    }, /* 2 */
    /***/
    function(module, exports, __webpack_require__) {
        var store = __webpack_require__(59)("wks"), uid = __webpack_require__(39), Symbol = __webpack_require__(6).Symbol, USE_SYMBOL = "function" == typeof Symbol;
        (module.exports = function(name) {
            return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name));
        }).store = store;
    }, /* 3 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(6), core = __webpack_require__(0), ctx = __webpack_require__(30), hide = __webpack_require__(12), $export = function(type, name, source) {
            var key, own, out, IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = exports.prototype, target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {}).prototype;
            IS_GLOBAL && (source = name);
            for (key in source) // contains in native
            (own = !IS_FORCED && target && void 0 !== target[key]) && key in exports || (// export native or passed
            out = own ? target[key] : source[key], // prevent global pollution for namespaces
            exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                var F = function(a, b, c) {
                    if (this instanceof C) {
                        switch (arguments.length) {
                          case 0:
                            return new C();

                          case 1:
                            return new C(a);

                          case 2:
                            return new C(a, b);
                        }
                        return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                };
                return F.prototype = C.prototype, F;
            }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out, // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            IS_PROTO && ((exports.virtual || (exports.virtual = {}))[key] = out, // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            type & $export.R && expProto && !expProto[key] && hide(expProto, key, out)));
        };
        // type bitmap
        $export.F = 1, // forced
        $export.G = 2, // global
        $export.S = 4, // static
        $export.P = 8, // proto
        $export.B = 16, // bind
        $export.W = 32, // wrap
        $export.U = 64, // safe
        $export.R = 128, // real proto method for `library` 
        module.exports = $export;
    }, /* 4 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
            function useColors() {
                // NB: In an Electron preload script, document will be defined but not fully
                // initialized. Since we know we're in Chrome, we'll just detect this case
                // explicitly
                // NB: In an Electron preload script, document will be defined but not fully
                // initialized. Since we know we're in Chrome, we'll just detect this case
                // explicitly
                // is firebug? http://stackoverflow.com/a/398120/376773
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                // double check webkit in userAgent just in case we are in a worker
                return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }
            /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */
            function formatArgs(args) {
                var useColors = this.useColors;
                if (args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff), 
                useColors) {
                    var c = "color: " + this.color;
                    args.splice(1, 0, c, "color: inherit");
                    // the final "%c" is somewhat tricky, because there could be other
                    // arguments passed either before or after the %c, so we need to
                    // figure out the correct index to insert the CSS into
                    var index = 0, lastC = 0;
                    args[0].replace(/%[a-zA-Z%]/g, function(match) {
                        "%%" !== match && (index++, "%c" === match && (// we only are interested in the *last* %c
                        // (the user may have provided their own)
                        lastC = index));
                    }), args.splice(lastC, 0, c);
                }
            }
            /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
            function log() {
                // this hackery is required for IE8/9, where
                // the `console.log` function doesn't have 'apply'
                return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
            }
            /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
            function save(namespaces) {
                try {
                    null == namespaces ? exports.storage.removeItem("debug") : exports.storage.debug = namespaces;
                } catch (e) {}
            }
            /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
            function load() {
                var r;
                try {
                    r = exports.storage.debug;
                } catch (e) {}
                // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
                return !r && void 0 !== process && "env" in process && (r = Object({
                    NODE_ENV: "production"
                }).DEBUG), r;
            }
            /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
            exports = module.exports = __webpack_require__(171), exports.log = log, exports.formatArgs = formatArgs, 
            exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */
            function() {
                try {
                    return window.localStorage;
                } catch (e) {}
            }(), /**
 * Colors.
 */
            exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ], 
            /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */
            exports.formatters.j = function(v) {
                try {
                    return JSON.stringify(v);
                } catch (err) {
                    return "[UnexpectedJSONParseError]: " + err.message;
                }
            }, /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */
            exports.enable(load());
        }).call(exports, __webpack_require__(69));
    }, /* 5 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var keys = __webpack_require__(33), objToString = Object.prototype.toString, isNumber = function(val) {
            var type = typeof val;
            return "number" === type || "object" === type && "[object Number]" === objToString.call(val);
        }, isArray = "function" == typeof Array.isArray ? Array.isArray : function(val) {
            return "[object Array]" === objToString.call(val);
        }, isArrayLike = function(val) {
            return null != val && (isArray(val) || "function" !== val && isNumber(val.length));
        }, arrayEach = function(iterator, array) {
            for (var i = 0; i < array.length && !1 !== iterator(array[i], i, array); i += 1) ;
        }, baseEach = function(iterator, object) {
            for (var ks = keys(object), i = 0; i < ks.length && !1 !== iterator(object[ks[i]], ks[i], object); i += 1) ;
        }, each = function(iterator, collection) {
            return (isArrayLike(collection) ? arrayEach : baseEach).call(this, iterator, collection);
        };
        /*
 * Exports.
 */
        module.exports = each;
    }, /* 6 */
    /***/
    function(module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = global);
    }, /* 7 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), IE8_DOM_DEFINE = __webpack_require__(83), toPrimitive = __webpack_require__(54), dP = Object.defineProperty;
        exports.f = __webpack_require__(8) ? Object.defineProperty : function(O, P, Attributes) {
            if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
            } catch (e) {}
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
            return "value" in Attributes && (O[P] = Attributes.value), O;
        };
    }, /* 8 */
    /***/
    function(module, exports, __webpack_require__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__webpack_require__(18)(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 9 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.inherit = __webpack_require__(66), exports.clone = __webpack_require__(26), 
        exports.type = __webpack_require__(162);
    }, /* 10 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _assign = __webpack_require__(43), _assign2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_assign);
        exports.default = _assign2.default || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        };
    }, /* 11 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function objectValues(object) {
            return (0, _keys2.default)(object).map(function(key) {
                return object[key];
            });
        }
        function isType(type, value) {
            return objectValues(type).indexOf(value) > -1;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.originTracingType = exports.webPlatforms = exports.desktopPlatforms = exports.apdexType = exports.userType = exports.tenantType = exports.originType = exports.platformType = exports.eventType = exports.envType = void 0;
        var _keys = __webpack_require__(16), _keys2 = _interopRequireDefault(_keys), _freeze = __webpack_require__(236), _freeze2 = _interopRequireDefault(_freeze);
        exports.objectValues = objectValues, exports.isType = isType;
        var platformType = (exports.envType = (0, _freeze2.default)({
            LOCAL: "local",
            DEV: "dev",
            STAGING: "staging",
            PROD: "prod"
        }), exports.eventType = (0, _freeze2.default)({
            TRACK: "track",
            UI: "ui",
            OPERATIONAL: "operational",
            SCREEN: "screen"
        }), exports.platformType = (0, _freeze2.default)({
            MAC: "mac",
            LINUX: "linux",
            WINDOWS: "windows",
            /**
   *  @deprecated desktop is here for retrocompatibility, please select one of the above OS instead.
   */
            DESKTOP: "desktop",
            WEB: "web",
            MOBILE_WEB: "mobileWeb"
        }));
        exports.originType = (0, _freeze2.default)({
            DESKTOP: "desktop",
            WEB: "web"
        }), exports.tenantType = (0, _freeze2.default)({
            CLOUD_ID: "cloudId",
            ORG_ID: "orgId",
            OPSGENIE_CUSTOMER_ID: "opsgenieCustomerId",
            NONE: "none"
        }), exports.userType = (0, _freeze2.default)({
            ATLASSIAN_ACCOUNT: "atlassianAccount",
            HASHED_EMAIL: "hashedEmail",
            TRELLO: "trello",
            OPSGENIE: "opsgenie"
        }), exports.apdexType = (0, _freeze2.default)({
            TRANSITION: "transition",
            INITIAL_LOAD: "initialLoad"
        }), exports.desktopPlatforms = (0, _freeze2.default)([ platformType.DESKTOP, platformType.MAC, platformType.LINUX, platformType.WINDOWS ]), 
        exports.webPlatforms = (0, _freeze2.default)([ platformType.WEB, platformType.MOBILE_WEB ]), 
        exports.originTracingType = (0, _freeze2.default)({
            ATL_ORIGIN: "atlOrigin"
        });
    }, /* 12 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(7), createDesc = __webpack_require__(37);
        module.exports = __webpack_require__(8) ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value));
        } : function(object, key, value) {
            return object[key] = value, object;
        };
    }, /* 13 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14);
        module.exports = function(it) {
            if (!isObject(it)) throw TypeError(it + " is not an object!");
            return it;
        };
    }, /* 14 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            return "object" == typeof it ? null !== it : "function" == typeof it;
        };
    }, /* 15 */
    /***/
    function(module, exports, __webpack_require__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __webpack_require__(55), defined = __webpack_require__(36);
        module.exports = function(it) {
            return IObject(defined(it));
        };
    }, /* 16 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(154),
            __esModule: !0
        };
    }, /* 17 */
    /***/
    function(module, exports) {
        var g;
        // This works in non-strict mode
        g = function() {
            return this;
        }();
        try {
            // This works if eval is allowed (see CSP)
            g = g || Function("return this")() || (0, eval)("this");
        } catch (e) {
            // This works if the window reference is available
            "object" == typeof window && (g = window);
        }
        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}
        module.exports = g;
    }, /* 18 */
    /***/
    function(module, exports) {
        module.exports = function(exec) {
            try {
                return !!exec();
            } catch (e) {
                return !0;
            }
        };
    }, /* 19 */
    /***/
    function(module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
        };
    }, /* 20 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __webpack_require__(86), enumBugKeys = __webpack_require__(60);
        module.exports = Object.keys || function(O) {
            return $keys(O, enumBugKeys);
        };
    }, /* 21 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var Facade = __webpack_require__(25);
        /**
 * Expose specific-method facades.
 */
        Facade.Alias = __webpack_require__(167), Facade.Group = __webpack_require__(168), 
        Facade.Identify = __webpack_require__(98), Facade.Track = __webpack_require__(68), 
        Facade.Page = __webpack_require__(100), Facade.Screen = __webpack_require__(169), 
        /**
 * Exports.
 */
        module.exports = Facade;
    }, /* 22 */
    /***/
    function(module, exports) {
        // code borrowed from https://github.com/feross/is-buffer/blob/master/index.js
        function isBuffer(obj) {
            // For Safari 5-7 (missing Object.prototype.constructor)
            return !(null == obj || !(obj._isBuffer || obj.constructor && "function" == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj)));
        }
        /**
 * toString ref.
 */
        var toString = Object.prototype.toString;
        /**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */
        module.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Date]":
                return "date";

              case "[object RegExp]":
                return "regexp";

              case "[object Arguments]":
                return "arguments";

              case "[object Array]":
                return "array";

              case "[object Error]":
                return "error";
            }
            return null === val ? "null" : void 0 === val ? "undefined" : val !== val ? "nan" : val && 1 === val.nodeType ? "element" : isBuffer(val) ? "buffer" : typeof (val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val));
        };
    }, /* 23 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function bindAll(obj) {
            // eslint-disable-next-line guard-for-in
            for (var key in obj) {
                "function" == typeof obj[key] && (obj[key] = bind(obj, obj[key]));
            }
            return obj;
        }
        var bind = __webpack_require__(102);
        module.exports = bindAll;
    }, /* 24 */
    /***/
    function(module, exports) {
        module.exports = {};
    }, /* 25 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Facade` with an `obj` of arguments.
 *
 * @param {Object} obj
 * @param {Object} opts
 */
        function Facade(obj, opts) {
            opts = opts || {}, "clone" in opts || (opts.clone = !0), opts.clone && (obj = clone(obj)), 
            "traverse" in opts || (opts.traverse = !0), obj.timestamp = "timestamp" in obj ? newDate(obj.timestamp) : new Date(), 
            opts.traverse && traverse(obj), this.opts = opts, this.obj = obj;
        }
        /**
 * Return the cloned and traversed object
 *
 * @param {*} obj
 * @return {*}
 */
        function transform(obj) {
            return clone(obj);
        }
        var address = __webpack_require__(161), clone = __webpack_require__(9).clone, isEnabled = __webpack_require__(163), newDate = __webpack_require__(67), objCase = __webpack_require__(44), traverse = __webpack_require__(94), type = __webpack_require__(9).type;
        /**
 * Mixin address traits.
 */
        address(Facade.prototype), /**
 * Return a proxy function for a `field` that will attempt to first use methods,
 * and fallback to accessing the underlying object directly. You can specify
 * deeply nested fields too like:
 *
 *   this.proxy('options.Librato');
 *
 * @param {string} field
 */
        Facade.prototype.proxy = function(field) {
            var fields = field.split(".");
            field = fields.shift();
            // Call a function at the beginning to take advantage of facaded fields
            var obj = this[field] || this.field(field);
            return obj ? ("function" == typeof obj && (obj = obj.call(this) || {}), 0 === fields.length ? this.opts.clone ? transform(obj) : obj : (obj = objCase(obj, fields.join(".")), 
            this.opts.clone ? transform(obj) : obj)) : obj;
        }, /**
 * Directly access a specific `field` from the underlying object, returning a
 * clone so outsiders don't mess with stuff.
 *
 * @param {string} field
 * @return {*}
 */
        Facade.prototype.field = function(field) {
            var obj = this.obj[field];
            return this.opts.clone ? transform(obj) : obj;
        }, /**
 * Utility method to always proxy a particular `field`. You can specify deeply
 * nested fields too like:
 *
 *   Facade.proxy('options.Librato');
 *
 * @param {string} field
 * @return {Function}
 */
        Facade.proxy = function(field) {
            return function() {
                return this.proxy(field);
            };
        }, /**
 * Utility method to directly access a `field`.
 *
 * @param {string} field
 * @return {Function}
 */
        Facade.field = function(field) {
            return function() {
                return this.field(field);
            };
        }, /**
 * Proxy multiple `path`.
 *
 * @param {string} path
 * @return {Array}
 */
        Facade.multi = function(path) {
            return function() {
                var multi = this.proxy(path + "s");
                if ("array" === type(multi)) return multi;
                var one = this.proxy(path);
                return one && (one = [ this.opts.clone ? clone(one) : one ]), one || [];
            };
        }, /**
 * Proxy one `path`.
 *
 * @param {string} path
 * @return {*}
 */
        Facade.one = function(path) {
            return function() {
                var one = this.proxy(path);
                if (one) return one;
                var multi = this.proxy(path + "s");
                return "array" === type(multi) ? multi[0] : void 0;
            };
        }, /**
 * Get the basic json object of this facade.
 *
 * @return {Object}
 */
        Facade.prototype.json = function() {
            var ret = this.opts.clone ? clone(this.obj) : this.obj;
            return this.type && (ret.type = this.type()), ret;
        }, /**
 * Get the options of a call (formerly called "context"). If you pass an
 * integration name, it will get the options for that specific integration, or
 * undefined if the integration is not enabled.
 *
 * @param {string} [integration]
 * @return {Object or Null}
 */
        Facade.prototype.options = function(integration) {
            var obj = this.obj.options || this.obj.context || {}, options = this.opts.clone ? clone(obj) : obj;
            if (!integration) return options;
            if (this.enabled(integration)) {
                var integrations = this.integrations(), value = integrations[integration] || objCase(integrations, integration);
                return "object" != typeof value && (value = objCase(this.options(), integration)), 
                "object" == typeof value ? value : {};
            }
        }, Facade.prototype.context = Facade.prototype.options, /**
 * Check whether an integration is enabled.
 *
 * @param {string} integration
 * @return {boolean}
 */
        Facade.prototype.enabled = function(integration) {
            var allEnabled = this.proxy("options.providers.all");
            "boolean" != typeof allEnabled && (allEnabled = this.proxy("options.all")), "boolean" != typeof allEnabled && (allEnabled = this.proxy("integrations.all")), 
            "boolean" != typeof allEnabled && (allEnabled = !0);
            var enabled = allEnabled && isEnabled(integration), options = this.integrations();
            // Next, check for the integration's existence in 'options' to enable it.
            // If the settings are a boolean, use that, otherwise it should be enabled.
            if (// If the integration is explicitly enabled or disabled, use that
            // First, check options.providers for backwards compatibility
            options.providers && options.providers.hasOwnProperty(integration) && (enabled = options.providers[integration]), 
            options.hasOwnProperty(integration)) {
                var settings = options[integration];
                enabled = "boolean" != typeof settings || settings;
            }
            return !!enabled;
        }, /**
 * Get all `integration` options.
 *
 * @api private
 * @param {string} integration
 * @return {Object}
 */
        Facade.prototype.integrations = function() {
            return this.obj.integrations || this.proxy("options.providers") || this.options();
        }, /**
 * Check whether the user is active.
 *
 * @return {boolean}
 */
        Facade.prototype.active = function() {
            var active = this.proxy("options.active");
            return null !== active && void 0 !== active || (active = !0), active;
        }, /**
 * Get `sessionId / anonymousId`.
 *
 * @api public
 * @return {*}
 */
        Facade.prototype.anonymousId = function() {
            return this.field("anonymousId") || this.field("sessionId");
        }, Facade.prototype.sessionId = Facade.prototype.anonymousId, /**
 * Get `groupId` from `context.groupId`.
 *
 * @api public
 * @return {string}
 */
        Facade.prototype.groupId = Facade.proxy("options.groupId"), /**
 * Get the call's "super properties" which are just traits that have been
 * passed in as if from an identify call.
 *
 * @param {Object} aliases
 * @return {Object}
 */
        Facade.prototype.traits = function(aliases) {
            var ret = this.proxy("options.traits") || {}, id = this.userId();
            aliases = aliases || {}, id && (ret.id = id);
            for (var alias in aliases) {
                var value = null == this[alias] ? this.proxy("options.traits." + alias) : this[alias]();
                null != value && (ret[aliases[alias]] = value, delete ret[alias]);
            }
            return ret;
        }, /**
 * Add a convenient way to get the library name and version
 */
        Facade.prototype.library = function() {
            var library = this.proxy("options.library");
            return library ? "string" == typeof library ? {
                name: library,
                version: null
            } : library : {
                name: "unknown",
                version: null
            };
        }, /**
 * Return the device information or an empty object
 *
 * @return {Object}
 */
        Facade.prototype.device = function() {
            var device = this.proxy("context.device");
            "object" !== type(device) && (device = {});
            var library = this.library().name;
            return device.type ? device : (library.indexOf("ios") > -1 && (device.type = "ios"), 
            library.indexOf("android") > -1 && (device.type = "android"), device);
        }, /**
 * Set up some basic proxies.
 */
        Facade.prototype.userAgent = Facade.proxy("context.userAgent"), Facade.prototype.timezone = Facade.proxy("context.timezone"), 
        Facade.prototype.timestamp = Facade.field("timestamp"), Facade.prototype.channel = Facade.field("channel"), 
        Facade.prototype.ip = Facade.proxy("context.ip"), Facade.prototype.userId = Facade.field("userId"), 
        /**
 * Exports.
 */
        module.exports = Facade;
    }, /* 26 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var type = __webpack_require__(22), clone = function clone(obj) {
            var t = type(obj);
            if ("object" === t) {
                var copy = {};
                for (var key in obj) obj.hasOwnProperty(key) && (copy[key] = clone(obj[key]));
                return copy;
            }
            if ("array" === t) {
                for (var copy = new Array(obj.length), i = 0, l = obj.length; i < l; i++) copy[i] = clone(obj[i]);
                return copy;
            }
            if ("regexp" === t) {
                // from millermedeiros/amd-utils - MIT
                var flags = "";
                return flags += obj.multiline ? "m" : "", flags += obj.global ? "g" : "", flags += obj.ignoreCase ? "i" : "", 
                new RegExp(obj.source, flags);
            }
            return "date" === t ? new Date(obj.getTime()) : obj;
        };
        /*
 * Exports.
 */
        module.exports = clone;
    }, /* 27 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var drop = __webpack_require__(173), rest = __webpack_require__(174), has = Object.prototype.hasOwnProperty, objToString = Object.prototype.toString, isObject = function(value) {
            return Boolean(value) && "object" == typeof value;
        }, isPlainObject = function(value) {
            return Boolean(value) && "[object Object]" === objToString.call(value);
        }, shallowCombiner = function(target, source, value, key) {
            return has.call(source, key) && void 0 === target[key] && (target[key] = value), 
            source;
        }, deepCombiner = function(target, source, value, key) {
            return has.call(source, key) && (isPlainObject(target[key]) && isPlainObject(value) ? target[key] = defaultsDeep(target[key], value) : void 0 === target[key] && (target[key] = value)), 
            source;
        }, defaultsWith = function(combiner, target) {
            if (!isObject(target)) return target;
            combiner = combiner || shallowCombiner;
            for (var sources = drop(2, arguments), i = 0; i < sources.length; i += 1) for (var key in sources[i]) combiner(target, sources[i], sources[i][key], key);
            return target;
        }, defaultsDeep = function(target) {
            // TODO: Replace with `partial` call?
            return defaultsWith.apply(null, [ deepCombiner, target ].concat(rest(arguments)));
        }, defaults = function(target) {
            // TODO: Replace with `partial` call?
            return defaultsWith.apply(null, [ null, target ].concat(rest(arguments)));
        };
        /*
 * Exports.
 */
        module.exports = defaults, module.exports.deep = defaultsDeep;
    }, /* 28 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(module, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            (function() {
                // Public: Initializes JSON 3 using the given `context` object, attaching the
                // `stringify` and `parse` functions to the specified `exports` object.
                function runInContext(context, exports) {
                    // Internal: Determines whether the native `JSON.stringify` and `parse`
                    // implementations are spec-compliant. Based on work by Ken Snyder.
                    function has(name) {
                        if (has[name] !== undef) // Return cached feature test result.
                        return has[name];
                        var isSupported;
                        if ("bug-string-char-index" == name) // IE <= 7 doesn't support accessing string characters using square
                        // bracket notation. IE 8 only supports this for primitives.
                        isSupported = "a" != "a"[0]; else if ("json" == name) // Indicates whether both `JSON.stringify` and `JSON.parse` are
                        // supported.
                        isSupported = has("json-stringify") && has("json-parse"); else {
                            var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                            // Test `JSON.stringify`.
                            if ("json-stringify" == name) {
                                var stringify = exports.stringify, stringifySupported = "function" == typeof stringify && isExtended;
                                if (stringifySupported) {
                                    // A test function object with a custom `toJSON` method.
                                    (value = function() {
                                        return 1;
                                    }).toJSON = value;
                                    try {
                                        stringifySupported = // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                        // primitives as object literals.
                                        "0" === stringify(0) && // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                        // literals.
                                        "0" === stringify(new Number()) && '""' == stringify(new String()) && // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                                        // does not define a canonical JSON representation (this applies to
                                        // objects with `toJSON` properties as well, *unless* they are nested
                                        // within an object or array).
                                        stringify(getClass) === undef && // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                                        // FF 3.1b3 pass this test.
                                        stringify(undef) === undef && // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                                        // respectively, if the value is omitted entirely.
                                        stringify() === undef && // FF 3.1b1, 2 throw an error if the given value is not a number,
                                        // string, array, object, Boolean, or `null` literal. This applies to
                                        // objects with custom `toJSON` methods as well, unless they are nested
                                        // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                                        // methods entirely.
                                        "1" === stringify(value) && "[1]" == stringify([ value ]) && // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                                        // `"[null]"`.
                                        "[null]" == stringify([ undef ]) && // YUI 3.0.0b1 fails to serialize `null` literals.
                                        "null" == stringify(null) && // FF 3.1b1, 2 halts serialization if an array contains a function:
                                        // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                                        // elides non-JSON values from objects and arrays, unless they
                                        // define custom `toJSON` methods.
                                        "[null,null,null]" == stringify([ undef, getClass, null ]) && // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                        // where character escape codes are expected (e.g., `\b` => `\u0008`).
                                        stringify({
                                            a: [ value, !0, !1, null, "\0\b\n\f\r\t" ]
                                        }) == serialized && // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                                        "1" === stringify(null, value) && "[\n 1,\n 2\n]" == stringify([ 1, 2 ], null, 1) && // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                                        // serialize extended years.
                                        '"-271821-04-20T00:00:00.000Z"' == stringify(new Date(-864e13)) && // The milliseconds are optional in ES 5, but required in 5.1.
                                        '"+275760-09-13T00:00:00.000Z"' == stringify(new Date(864e13)) && // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                                        // four-digit years instead of six-digit years. Credits: @Yaffle.
                                        '"-000001-01-01T00:00:00.000Z"' == stringify(new Date(-621987552e5)) && // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                                        // values less than 1000. Credits: @Yaffle.
                                        '"1969-12-31T23:59:59.999Z"' == stringify(new Date(-1));
                                    } catch (exception) {
                                        stringifySupported = !1;
                                    }
                                }
                                isSupported = stringifySupported;
                            }
                            // Test `JSON.parse`.
                            if ("json-parse" == name) {
                                var parse = exports.parse;
                                if ("function" == typeof parse) try {
                                    // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                                    // Conforming implementations should also coerce the initial argument to
                                    // a string prior to parsing.
                                    if (0 === parse("0") && !parse(!1)) {
                                        // Simple parsing test.
                                        value = parse(serialized);
                                        var parseSupported = 5 == value.a.length && 1 === value.a[0];
                                        if (parseSupported) {
                                            try {
                                                // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                                parseSupported = !parse('"\t"');
                                            } catch (exception) {}
                                            if (parseSupported) try {
                                                // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                                                // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                                // certain octal literals.
                                                parseSupported = 1 !== parse("01");
                                            } catch (exception) {}
                                            if (parseSupported) try {
                                                // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                                // points. These environments, along with FF 3.1b1 and 2,
                                                // also allow trailing commas in JSON objects and arrays.
                                                parseSupported = 1 !== parse("1.");
                                            } catch (exception) {}
                                        }
                                    }
                                } catch (exception) {
                                    parseSupported = !1;
                                }
                                isSupported = parseSupported;
                            }
                        }
                        return has[name] = !!isSupported;
                    }
                    context || (context = root.Object()), exports || (exports = root.Object());
                    // Native constructor aliases.
                    var Number = context.Number || root.Number, String = context.String || root.String, Object = context.Object || root.Object, Date = context.Date || root.Date, SyntaxError = context.SyntaxError || root.SyntaxError, TypeError = context.TypeError || root.TypeError, Math = context.Math || root.Math, nativeJSON = context.JSON || root.JSON;
                    // Delegate to the native `stringify` and `parse` implementations.
                    "object" == typeof nativeJSON && nativeJSON && (exports.stringify = nativeJSON.stringify, 
                    exports.parse = nativeJSON.parse);
                    // Convenience aliases.
                    var isProperty, forEach, undef, objectProto = Object.prototype, getClass = objectProto.toString, isExtended = new Date(-0xc782b5b800cec);
                    try {
                        // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
                        // results for certain dates in Opera >= 10.53.
                        isExtended = -109252 == isExtended.getUTCFullYear() && 0 === isExtended.getUTCMonth() && 1 === isExtended.getUTCDate() && // Safari < 2.0.2 stores the internal millisecond time value correctly,
                        // but clips the values returned by the date methods to the range of
                        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
                        10 == isExtended.getUTCHours() && 37 == isExtended.getUTCMinutes() && 6 == isExtended.getUTCSeconds() && 708 == isExtended.getUTCMilliseconds();
                    } catch (exception) {}
                    if (!has("json")) {
                        // Common `[[Class]]` name aliases.
                        var charIndexBuggy = has("bug-string-char-index");
                        // Define additional utility methods if the `Date` methods are buggy.
                        if (!isExtended) var floor = Math.floor, Months = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], getDay = function(year, month) {
                            return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                        };
                        // Public: Serializes a JavaScript `value` as a JSON string. The optional
                        // `filter` argument may specify either a function that alters how object and
                        // array members are serialized, or an array of strings and numbers that
                        // indicates which properties should be serialized. The optional `width`
                        // argument may be either a string or number that specifies the indentation
                        // level of the output.
                        if (// Internal: Determines if a property is a direct property of the given
                        // object. Delegates to the native `Object#hasOwnProperty` method.
                        (isProperty = objectProto.hasOwnProperty) || (isProperty = function(property) {
                            var constructor, members = {};
                            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
                            // supports the mutable *proto* property.
                            // Capture a reference to the top-level `Object` constructor.
                            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
                            // other environments.
                            return (members.__proto__ = null, members.__proto__ = {
                                // The *proto* property cannot be set multiple times in recent
                                // versions of Firefox and SeaMonkey.
                                toString: 1
                            }, members).toString != getClass ? isProperty = function(property) {
                                // Capture and break the object's prototype chain (see section 8.6.2
                                // of the ES 5.1 spec). The parenthesized expression prevents an
                                // unsafe transformation by the Closure Compiler.
                                var original = this.__proto__, result = property in (this.__proto__ = null, this);
                                // Restore the original prototype chain.
                                return this.__proto__ = original, result;
                            } : (constructor = members.constructor, isProperty = function(property) {
                                var parent = (this.constructor || constructor).prototype;
                                return property in this && !(property in parent && this[property] === parent[property]);
                            }), members = null, isProperty.call(this, property);
                        }), // Internal: Normalizes the `for...in` iteration algorithm across
                        // environments. Each enumerated key is yielded to a `callback` function.
                        forEach = function(object, callback) {
                            var Properties, members, property, size = 0;
                            // Tests for bugs in the current environment's `for...in` algorithm. The
                            // `valueOf` property inherits the non-enumerable flag from
                            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
                            (Properties = function() {
                                this.valueOf = 0;
                            }).prototype.valueOf = 0, // Iterate over a new instance of the `Properties` class.
                            members = new Properties();
                            for (property in members) // Ignore all properties inherited from `Object.prototype`.
                            isProperty.call(members, property) && size++;
                            // Normalize the iteration algorithm.
                            // Safari <= 2.0.4 enumerates shadowed properties twice.
                            // A list of non-enumerable properties inherited from `Object.prototype`.
                            // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                            // properties.
                            return Properties = members = null, size ? forEach = 2 == size ? function(object, callback) {
                                // Create a set of iterated properties.
                                var property, members = {}, isFunction = "[object Function]" == getClass.call(object);
                                for (property in object) // Store each property name to prevent double enumeration. The
                                // `prototype` property of functions is not enumerated due to cross-
                                // environment inconsistencies.
                                isFunction && "prototype" == property || isProperty.call(members, property) || !(members[property] = 1) || !isProperty.call(object, property) || callback(property);
                            } : function(object, callback) {
                                var property, isConstructor, isFunction = "[object Function]" == getClass.call(object);
                                for (property in object) isFunction && "prototype" == property || !isProperty.call(object, property) || (isConstructor = "constructor" === property) || callback(property);
                                // Manually invoke the callback for the `constructor` property due to
                                // cross-environment inconsistencies.
                                (isConstructor || isProperty.call(object, property = "constructor")) && callback(property);
                            } : (members = [ "valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor" ], 
                            forEach = function(object, callback) {
                                var property, length, isFunction = "[object Function]" == getClass.call(object), hasProperty = !isFunction && "function" != typeof object.constructor && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                                for (property in object) // Gecko <= 1.0 enumerates the `prototype` property of functions under
                                // certain conditions; IE does not.
                                isFunction && "prototype" == property || !hasProperty.call(object, property) || callback(property);
                                // Manually invoke the callback for each non-enumerable property.
                                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) ;
                            }), forEach(object, callback);
                        }, !has("json-stringify")) {
                            // Internal: A map of control characters and their escaped equivalents.
                            var Escapes = {
                                92: "\\\\",
                                34: '\\"',
                                8: "\\b",
                                12: "\\f",
                                10: "\\n",
                                13: "\\r",
                                9: "\\t"
                            }, toPaddedString = function(width, value) {
                                // The `|| 0` expression is necessary to work around a bug in
                                // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
                                return ("000000" + (value || 0)).slice(-width);
                            }, quote = function(value) {
                                for (var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10, symbols = useCharIndex && (charIndexBuggy ? value.split("") : value); index < length; index++) {
                                    var charCode = value.charCodeAt(index);
                                    // If the character is a control character, append its Unicode or
                                    // shorthand escape sequence; otherwise, append the character as-is.
                                    switch (charCode) {
                                      case 8:
                                      case 9:
                                      case 10:
                                      case 12:
                                      case 13:
                                      case 34:
                                      case 92:
                                        result += Escapes[charCode];
                                        break;

                                      default:
                                        if (charCode < 32) {
                                            result += "\\u00" + toPaddedString(2, charCode.toString(16));
                                            break;
                                        }
                                        result += useCharIndex ? symbols[index] : value.charAt(index);
                                    }
                                }
                                return result + '"';
                            }, serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                                var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                                try {
                                    // Necessary for host object support.
                                    value = object[property];
                                } catch (exception) {}
                                if ("object" == typeof value && value) if ("[object Date]" != (className = getClass.call(value)) || isProperty.call(value, "toJSON")) "function" == typeof value.toJSON && ("[object Number]" != className && "[object String]" != className && "[object Array]" != className || isProperty.call(value, "toJSON")) && (// Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                                // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                                // ignores all `toJSON` methods on these objects unless they are
                                // defined directly on an instance.
                                value = value.toJSON(property)); else if (value > -1 / 0 && value < 1 / 0) {
                                    // Dates are serialized according to the `Date#toJSON` method
                                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                    // for the ISO 8601 date time string format.
                                    if (getDay) {
                                        for (// Manually compute the year, month, date, hours, minutes,
                                        // seconds, and milliseconds if the `getUTC*` methods are
                                        // buggy. Adapted from @Yaffle's `date-shim` project.
                                        date = floor(value / 864e5), year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) ;
                                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) ;
                                        date = 1 + date - getDay(year, month), // The `time` value specifies the time within the day (see ES
                                        // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                                        // to compute `A modulo B`, as the `%` operator does not
                                        // correspond to the `modulo` operation for negative numbers.
                                        time = (value % 864e5 + 864e5) % 864e5, // The hours, minutes, seconds, and milliseconds are obtained by
                                        // decomposing the time within the day. See section 15.9.1.10.
                                        hours = floor(time / 36e5) % 24, minutes = floor(time / 6e4) % 60, seconds = floor(time / 1e3) % 60, 
                                        milliseconds = time % 1e3;
                                    } else year = value.getUTCFullYear(), month = value.getUTCMonth(), date = value.getUTCDate(), 
                                    hours = value.getUTCHours(), minutes = value.getUTCMinutes(), seconds = value.getUTCSeconds(), 
                                    milliseconds = value.getUTCMilliseconds();
                                    // Serialize extended years correctly.
                                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + // Months, dates, hours, minutes, and seconds should have two
                                    // digits; milliseconds should have three.
                                    "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + // Milliseconds are optional in ES 5.0, but required in 5.1.
                                    "." + toPaddedString(3, milliseconds) + "Z";
                                } else value = null;
                                if (callback && (// If a replacement function was provided, call it to obtain the value
                                // for serialization.
                                value = callback.call(object, property, value)), null === value) return "null";
                                if ("[object Boolean]" == (className = getClass.call(value))) // Booleans are represented literally.
                                return "" + value;
                                if ("[object Number]" == className) // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                                // `"null"`.
                                return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                                if ("[object String]" == className) // Strings are double-quoted and escaped.
                                return quote("" + value);
                                // Recursively serialize objects and arrays.
                                if ("object" == typeof value) {
                                    // Check for cyclic structures. This is a linear search; performance
                                    // is inversely proportional to the number of unique nested objects.
                                    for (length = stack.length; length--; ) if (stack[length] === value) // Cyclic structures cannot be serialized by `JSON.stringify`.
                                    throw TypeError();
                                    if (// Add the object to the stack of traversed objects.
                                    stack.push(value), results = [], // Save the current indentation level and indent one additional level.
                                    prefix = indentation, indentation += whitespace, "[object Array]" == className) {
                                        // Recursively serialize array elements.
                                        for (index = 0, length = value.length; index < length; index++) element = serialize(index, value, callback, properties, whitespace, indentation, stack), 
                                        results.push(element === undef ? "null" : element);
                                        result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
                                    } else // Recursively serialize object members. Members are selected from
                                    // either a user-specified list of property names, or the object
                                    // itself.
                                    forEach(properties || value, function(property) {
                                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                        element !== undef && // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                                        // is not the empty string, let `member` {quote(property) + ":"}
                                        // be the concatenation of `member` and the `space` character."
                                        // The "`space` character" refers to the literal space
                                        // character, not the `space` {width} argument provided to
                                        // `JSON.stringify`.
                                        results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                                    }), result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
                                    // Remove the object from the traversed object stack.
                                    return stack.pop(), result;
                                }
                            };
                            // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
                            exports.stringify = function(source, filter, width) {
                                var whitespace, callback, properties, className;
                                if (objectTypes[typeof filter] && filter) if ("[object Function]" == (className = getClass.call(filter))) callback = filter; else if ("[object Array]" == className) {
                                    // Convert the property names array into a makeshift set.
                                    properties = {};
                                    for (var value, index = 0, length = filter.length; index < length; value = filter[index++], 
                                    ("[object String]" == (className = getClass.call(value)) || "[object Number]" == className) && (properties[value] = 1)) ;
                                }
                                if (width) if ("[object Number]" == (className = getClass.call(width))) {
                                    // Convert the `width` to an integer and create a string containing
                                    // `width` number of space characters.
                                    if ((width -= width % 1) > 0) for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") ;
                                } else "[object String]" == className && (whitespace = width.length <= 10 ? width : width.slice(0, 10));
                                // Opera <= 7.54u2 discards the values associated with empty string keys
                                // (`""`) only if they are used directly within an object member list
                                // (e.g., `!("" in { "": 1})`).
                                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                            };
                        }
                        // Public: Parses a JSON source string.
                        if (!has("json-parse")) {
                            var Index, Source, fromCharCode = String.fromCharCode, Unescapes = {
                                92: "\\",
                                34: '"',
                                47: "/",
                                98: "\b",
                                116: "\t",
                                110: "\n",
                                102: "\f",
                                114: "\r"
                            }, abort = function() {
                                throw Index = Source = null, SyntaxError();
                            }, lex = function() {
                                for (var value, begin, position, isSigned, charCode, source = Source, length = source.length; Index < length; ) switch (charCode = source.charCodeAt(Index)) {
                                  case 9:
                                  case 10:
                                  case 13:
                                  case 32:
                                    // Skip whitespace tokens, including tabs, carriage returns, line
                                    // feeds, and space characters.
                                    Index++;
                                    break;

                                  case 123:
                                  case 125:
                                  case 91:
                                  case 93:
                                  case 58:
                                  case 44:
                                    // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                                    // the current position.
                                    return value = charIndexBuggy ? source.charAt(Index) : source[Index], Index++, value;

                                  case 34:
                                    // `"` delimits a JSON string; advance to the next character and
                                    // begin parsing the string. String tokens are prefixed with the
                                    // sentinel `@` character to distinguish them from punctuators and
                                    // end-of-string tokens.
                                    for (value = "@", Index++; Index < length; ) if ((charCode = source.charCodeAt(Index)) < 32) // Unescaped ASCII control characters (those with a code unit
                                    // less than the space character) are not permitted.
                                    abort(); else if (92 == charCode) switch (// A reverse solidus (`\`) marks the beginning of an escaped
                                    // control character (including `"`, `\`, and `/`) or Unicode
                                    // escape sequence.
                                    charCode = source.charCodeAt(++Index)) {
                                      case 92:
                                      case 34:
                                      case 47:
                                      case 98:
                                      case 116:
                                      case 110:
                                      case 102:
                                      case 114:
                                        // Revive escaped control characters.
                                        value += Unescapes[charCode], Index++;
                                        break;

                                      case 117:
                                        for (// `\u` marks the beginning of a Unicode escape sequence.
                                        // Advance to the first character and validate the
                                        // four-digit code point.
                                        begin = ++Index, position = Index + 4; Index < position; Index++) // A valid sequence comprises four hexdigits (case-
                                        // insensitive) that form a single hexadecimal value.
                                        (charCode = source.charCodeAt(Index)) >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70 || // Invalid Unicode escape sequence.
                                        abort();
                                        // Revive the escaped character.
                                        value += fromCharCode("0x" + source.slice(begin, Index));
                                        break;

                                      default:
                                        // Invalid escape sequence.
                                        abort();
                                    } else {
                                        if (34 == charCode) // An unescaped double-quote character marks the end of the
                                        // string.
                                        break;
                                        // Optimize for the common case where a string is valid.
                                        for (charCode = source.charCodeAt(Index), begin = Index; charCode >= 32 && 92 != charCode && 34 != charCode; ) charCode = source.charCodeAt(++Index);
                                        // Append the string as-is.
                                        value += source.slice(begin, Index);
                                    }
                                    if (34 == source.charCodeAt(Index)) // Advance to the next character and return the revived string.
                                    return Index++, value;
                                    // Unterminated string.
                                    abort();

                                  default:
                                    // Parse an integer or floating-point value.
                                    if (// Parse numbers and literals.
                                    begin = Index, // Advance past the negative sign, if one is specified.
                                    45 == charCode && (isSigned = !0, charCode = source.charCodeAt(++Index)), charCode >= 48 && charCode <= 57) {
                                        // Parse the integer component.
                                        for (// Leading zeroes are interpreted as octal literals.
                                        48 == charCode && (charCode = source.charCodeAt(Index + 1)) >= 48 && charCode <= 57 && // Illegal octal literal.
                                        abort(), isSigned = !1; Index < length && (charCode = source.charCodeAt(Index)) >= 48 && charCode <= 57; Index++) ;
                                        // Floats cannot contain a leading decimal point; however, this
                                        // case is already accounted for by the parser.
                                        if (46 == source.charCodeAt(Index)) {
                                            // Parse the decimal component.
                                            for (position = ++Index; position < length && (charCode = source.charCodeAt(position)) >= 48 && charCode <= 57; position++) ;
                                            position == Index && // Illegal trailing decimal.
                                            abort(), Index = position;
                                        }
                                        if (101 == (// Parse exponents. The `e` denoting the exponent is
                                        // case-insensitive.
                                        charCode = source.charCodeAt(Index)) || 69 == charCode) {
                                            // Parse the exponential component.
                                            for (charCode = source.charCodeAt(++Index), // Skip past the sign following the exponent, if one is
                                            // specified.
                                            43 != charCode && 45 != charCode || Index++, position = Index; position < length && (charCode = source.charCodeAt(position)) >= 48 && charCode <= 57; position++) ;
                                            position == Index && // Illegal empty exponent.
                                            abort(), Index = position;
                                        }
                                        // Coerce the parsed value to a JavaScript number.
                                        return +source.slice(begin, Index);
                                    }
                                    // `true`, `false`, and `null` literals.
                                    if (// A negative sign may only precede numbers.
                                    isSigned && abort(), "true" == source.slice(Index, Index + 4)) return Index += 4, 
                                    !0;
                                    if ("false" == source.slice(Index, Index + 5)) return Index += 5, !1;
                                    if ("null" == source.slice(Index, Index + 4)) return Index += 4, null;
                                    // Unrecognized token.
                                    abort();
                                }
                                // Return the sentinel `$` character if the parser has reached the end
                                // of the source string.
                                return "$";
                            }, get = function(value) {
                                var results, hasMembers;
                                if ("$" == value && // Unexpected end of input.
                                abort(), "string" == typeof value) {
                                    if ("@" == (charIndexBuggy ? value.charAt(0) : value[0])) // Remove the sentinel `@` character.
                                    return value.slice(1);
                                    // Parse object and array literals.
                                    if ("[" == value) {
                                        for (// Parses a JSON array, returning a new JavaScript array.
                                        results = []; "]" != (value = lex()); hasMembers || (hasMembers = !0)) // If the array literal contains elements, the current token
                                        // should be a comma separating the previous element from the
                                        // next.
                                        hasMembers && ("," == value ? "]" == (value = lex()) && // Unexpected trailing `,` in array literal.
                                        abort() : // A `,` must separate each array element.
                                        abort()), // Elisions and leading commas are not permitted.
                                        "," == value && abort(), results.push(get(value));
                                        return results;
                                    }
                                    if ("{" == value) {
                                        for (// Parses a JSON object, returning a new JavaScript object.
                                        results = {}; "}" != (value = lex()); hasMembers || (hasMembers = !0)) // If the object literal contains members, the current token
                                        // should be a comma separator.
                                        hasMembers && ("," == value ? "}" == (value = lex()) && // Unexpected trailing `,` in object literal.
                                        abort() : // A `,` must separate each object member.
                                        abort()), // Leading commas are not permitted, object property names must be
                                        // double-quoted strings, and a `:` must separate each property
                                        // name and value.
                                        "," != value && "string" == typeof value && "@" == (charIndexBuggy ? value.charAt(0) : value[0]) && ":" == lex() || abort(), 
                                        results[value.slice(1)] = get(lex());
                                        return results;
                                    }
                                    // Unexpected token encountered.
                                    abort();
                                }
                                return value;
                            }, update = function(source, property, callback) {
                                var element = walk(source, property, callback);
                                element === undef ? delete source[property] : source[property] = element;
                            }, walk = function(source, property, callback) {
                                var length, value = source[property];
                                if ("object" == typeof value && value) // `forEach` can't be used to traverse an array in Opera <= 8.54
                                // because its `Object#hasOwnProperty` implementation returns `false`
                                // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                                if ("[object Array]" == getClass.call(value)) for (length = value.length; length--; ) update(value, length, callback); else forEach(value, function(property) {
                                    update(value, property, callback);
                                });
                                return callback.call(source, property, value);
                            };
                            // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
                            exports.parse = function(source, callback) {
                                var result, value;
                                // If a JSON string contains multiple tokens, it is invalid.
                                // Reset the parser state.
                                return Index = 0, Source = "" + source, result = get(lex()), "$" != lex() && abort(), 
                                Index = Source = null, callback && "[object Function]" == getClass.call(callback) ? walk((value = {}, 
                                value[""] = result, value), "", callback) : result;
                            };
                        }
                    }
                    return exports.runInContext = runInContext, exports;
                }
                // Detect the `define` function exposed by asynchronous module loaders. The
                // strict `define` check is necessary for compatibility with `r.js`.
                var isLoader = __webpack_require__(176), objectTypes = {
                    function: !0,
                    object: !0
                }, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, root = objectTypes[typeof window] && window || this, freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && "object" == typeof global && global;
                if (!freeGlobal || freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal), 
                freeExports && !isLoader) // Export for CommonJS environments.
                runInContext(root, freeExports); else {
                    // Export for web browsers and JavaScript engines.
                    var nativeJSON = root.JSON, previousJSON = root.JSON3, isRestored = !1, JSON3 = runInContext(root, root.JSON3 = {
                        // Public: Restores the original value of the global `JSON` object and
                        // returns a reference to the `JSON3` object.
                        noConflict: function() {
                            return isRestored || (isRestored = !0, root.JSON = nativeJSON, root.JSON3 = previousJSON, 
                            nativeJSON = previousJSON = null), JSON3;
                        }
                    });
                    root.JSON = {
                        parse: JSON3.parse,
                        stringify: JSON3.stringify
                    };
                }
                // Export for asynchronous module loaders.
                isLoader && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return JSON3;
                }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            }).call(this);
        }).call(exports, __webpack_require__(175)(module), __webpack_require__(17));
    }, /* 29 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _defineProperty = __webpack_require__(126), _defineProperty2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_defineProperty);
        exports.default = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
    }, /* 30 */
    /***/
    function(module, exports, __webpack_require__) {
        // optional / simple context binding
        var aFunction = __webpack_require__(138);
        module.exports = function(fn, that, length) {
            if (aFunction(fn), void 0 === that) return fn;
            switch (length) {
              case 1:
                return function(a) {
                    return fn.call(that, a);
                };

              case 2:
                return function(a, b) {
                    return fn.call(that, a, b);
                };

              case 3:
                return function(a, b, c) {
                    return fn.call(that, a, b, c);
                };
            }
            return function() {
                return fn.apply(that, arguments);
            };
        };
    }, /* 31 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.13 ToObject(argument)
        var defined = __webpack_require__(36);
        module.exports = function(it) {
            return Object(defined(it));
        };
    }, /* 32 */
    /***/
    function(module, exports) {
        exports.f = {}.propertyIsEnumerable;
    }, /* 33 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var hop = Object.prototype.hasOwnProperty, strCharAt = String.prototype.charAt, toStr = Object.prototype.toString, charAt = function(str, index) {
            return strCharAt.call(str, index);
        }, has = function(context, prop) {
            return hop.call(context, prop);
        }, isString = function(val) {
            return "[object String]" === toStr.call(val);
        }, isArrayLike = function(val) {
            return null != val && "function" != typeof val && "number" == typeof val.length;
        }, indexKeys = function(target, pred) {
            pred = pred || has;
            for (var results = [], i = 0, len = target.length; i < len; i += 1) pred(target, i) && results.push(String(i));
            return results;
        }, objectKeys = function(target, pred) {
            pred = pred || has;
            var results = [];
            for (var key in target) pred(target, key) && results.push(String(key));
            return results;
        }, keys = function(source) {
            // IE6-8 compatibility (string)
            // IE6-8 compatibility (arguments)
            return null == source ? [] : isString(source) ? indexKeys(source, charAt) : isArrayLike(source) ? indexKeys(source, has) : objectKeys(source);
        };
        /*
 * Exports.
 */
        module.exports = keys;
    }, /* 34 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _iterator = __webpack_require__(135), _iterator2 = _interopRequireDefault(_iterator), _symbol = __webpack_require__(146), _symbol2 = _interopRequireDefault(_symbol), _typeof = "function" == typeof _symbol2.default && "symbol" == typeof _iterator2.default ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
        };
        exports.default = "function" == typeof _symbol2.default && "symbol" === _typeof(_iterator2.default) ? function(obj) {
            return void 0 === obj ? "undefined" : _typeof(obj);
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : void 0 === obj ? "undefined" : _typeof(obj);
        };
    }, /* 35 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var $at = __webpack_require__(137)(!0);
        // 21.1.3.27 String.prototype[@@iterator]()
        __webpack_require__(52)(String, "String", function(iterated) {
            this._t = String(iterated), // target
            this._i = 0;
        }, function() {
            var point, O = this._t, index = this._i;
            return index >= O.length ? {
                value: void 0,
                done: !0
            } : (point = $at(O, index), this._i += point.length, {
                value: point,
                done: !1
            });
        });
    }, /* 36 */
    /***/
    function(module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function(it) {
            if (void 0 == it) throw TypeError("Can't call method on  " + it);
            return it;
        };
    }, /* 37 */
    /***/
    function(module, exports) {
        module.exports = function(bitmap, value) {
            return {
                enumerable: !(1 & bitmap),
                configurable: !(2 & bitmap),
                writable: !(4 & bitmap),
                value: value
            };
        };
    }, /* 38 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __webpack_require__(13), dPs = __webpack_require__(140), enumBugKeys = __webpack_require__(60), IE_PROTO = __webpack_require__(58)("IE_PROTO"), Empty = function() {}, createDict = function() {
            // Thrash, waste and sodomy: IE GC bug
            var iframeDocument, iframe = __webpack_require__(84)("iframe"), i = enumBugKeys.length;
            for (iframe.style.display = "none", __webpack_require__(143).appendChild(iframe), 
            iframe.src = "javascript:", // eslint-disable-line no-script-url
            // createDict = iframe.contentWindow.Object;
            // html.removeChild(iframe);
            iframeDocument = iframe.contentWindow.document, iframeDocument.open(), iframeDocument.write("<script>document.F=Object<\/script>"), 
            iframeDocument.close(), createDict = iframeDocument.F; i--; ) delete createDict.prototype[enumBugKeys[i]];
            return createDict();
        };
        module.exports = Object.create || function(O, Properties) {
            var result;
            // add "__proto__" for Object.getPrototypeOf polyfill
            return null !== O ? (Empty.prototype = anObject(O), result = new Empty(), Empty.prototype = null, 
            result[IE_PROTO] = O) : result = createDict(), void 0 === Properties ? result : dPs(result, Properties);
        };
    }, /* 39 */
    /***/
    function(module, exports) {
        var id = 0, px = Math.random();
        module.exports = function(key) {
            return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36));
        };
    }, /* 40 */
    /***/
    function(module, exports, __webpack_require__) {
        var def = __webpack_require__(7).f, has = __webpack_require__(19), TAG = __webpack_require__(2)("toStringTag");
        module.exports = function(it, tag, stat) {
            it && !has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
                configurable: !0,
                value: tag
            });
        };
    }, /* 41 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(144);
        for (var global = __webpack_require__(6), hide = __webpack_require__(12), Iterators = __webpack_require__(24), TO_STRING_TAG = __webpack_require__(2)("toStringTag"), collections = [ "NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList" ], i = 0; i < 5; i++) {
            var NAME = collections[i], Collection = global[NAME], proto = Collection && Collection.prototype;
            proto && !proto[TO_STRING_TAG] && hide(proto, TO_STRING_TAG, NAME), Iterators[NAME] = Iterators.Array;
        }
    }, /* 42 */
    /***/
    function(module, exports, __webpack_require__) {
        var META = __webpack_require__(39)("meta"), isObject = __webpack_require__(14), has = __webpack_require__(19), setDesc = __webpack_require__(7).f, id = 0, isExtensible = Object.isExtensible || function() {
            return !0;
        }, FREEZE = !__webpack_require__(18)(function() {
            return isExtensible(Object.preventExtensions({}));
        }), setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    // object ID
                    w: {}
                }
            });
        }, fastKey = function(it, create) {
            // return primitive with prefix
            if (!isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return "F";
                // not necessary to add metadata
                if (!create) return "E";
                // add missing metadata
                setMeta(it);
            }
            return it[META].i;
        }, getWeak = function(it, create) {
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return !0;
                // not necessary to add metadata
                if (!create) return !1;
                // add missing metadata
                setMeta(it);
            }
            return it[META].w;
        }, onFreeze = function(it) {
            return FREEZE && meta.NEED && isExtensible(it) && !has(it, META) && setMeta(it), 
            it;
        }, meta = module.exports = {
            KEY: META,
            NEED: !1,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze
        };
    }, /* 43 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(157),
            __esModule: !0
        };
    }, /* 44 */
    /***/
    function(module, exports) {
        /**
 * Compose applying the function to a nested key
 */
        function multiple(fn) {
            return function(obj, path, val, options) {
                normalize = options && isFunction(options.normalizer) ? options.normalizer : defaultNormalize, 
                path = normalize(path);
                for (var key, finished = !1; !finished; ) !function() {
                    for (key in obj) {
                        var normalizedKey = normalize(key);
                        if (0 === path.indexOf(normalizedKey)) {
                            var temp = path.substr(normalizedKey.length);
                            if ("." === temp.charAt(0) || 0 === temp.length) {
                                path = temp.substr(1);
                                var child = obj[key];
                                // we're at the end and there is nothing.
                                // we're at the end and there is nothing.
                                // we're at the end and there is something.
                                // step into child
                                return null == child ? void (finished = !0) : path.length ? void (obj = child) : void (finished = !0);
                            }
                        }
                    }
                    key = void 0, // if we found no matching properties
                    // on the current object, there's no match.
                    finished = !0;
                }();
                if (key) return null == obj ? obj : fn(obj, key, val);
            };
        }
        /**
 * Find an object by its key
 *
 * find({ first_name : 'Calvin' }, 'firstName')
 */
        function find(obj, key) {
            if (obj.hasOwnProperty(key)) return obj[key];
        }
        /**
 * Delete a value for a given key
 *
 * del({ a : 'b', x : 'y' }, 'X' }) -> { a : 'b' }
 */
        function del(obj, key) {
            return obj.hasOwnProperty(key) && delete obj[key], obj;
        }
        /**
 * Replace an objects existing value with a new one
 *
 * replace({ a : 'b' }, 'a', 'c') -> { a : 'c' }
 */
        function replace(obj, key, val) {
            return obj.hasOwnProperty(key) && (obj[key] = val), obj;
        }
        /**
 * Normalize a `dot.separated.path`.
 *
 * A.HELL(!*&#(!)O_WOR   LD.bar => ahelloworldbar
 *
 * @param {String} path
 * @return {String}
 */
        function defaultNormalize(path) {
            return path.replace(/[^a-zA-Z0-9\.]+/g, "").toLowerCase();
        }
        /**
 * Check if a value is a function.
 *
 * @param {*} val
 * @return {boolean} Returns `true` if `val` is a function, otherwise `false`.
 */
        function isFunction(val) {
            return "function" == typeof val;
        }
        /**
 * Module exports, export
 */
        module.exports = multiple(find), module.exports.find = module.exports, /**
 * Export the replacement function, return the modified object
 */
        module.exports.replace = function(obj, key, val, options) {
            return multiple(replace).call(this, obj, key, val, options), obj;
        }, /**
 * Export the delete function, return the modified object
 */
        module.exports.del = function(obj, key, options) {
            return multiple(del).call(this, obj, key, null, options), obj;
        };
    }, /* 45 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* globals window, HTMLElement */
        /**!
 * is
 * the definitive JavaScript type testing library
 *
 * @copyright 2013-2014 Enrico Marino / Jordan Harband
 * @license MIT
 */
        var symbolValueOf, objProto = Object.prototype, owns = objProto.hasOwnProperty, toStr = objProto.toString;
        "function" == typeof Symbol && (symbolValueOf = Symbol.prototype.valueOf);
        var isActualNaN = function(value) {
            return value !== value;
        }, NON_HOST_TYPES = {
            boolean: 1,
            number: 1,
            string: 1,
            undefined: 1
        }, base64Regex = /^([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/, hexRegex = /^[A-Fa-f0-9]+$/, is = {};
        /**
 * Test general.
 */
        /**
 * is.type
 * Test if `value` is a type of `type`.
 *
 * @param {Mixed} value value to test
 * @param {String} type type
 * @return {Boolean} true if `value` is a type of `type`, false otherwise
 * @api public
 */
        is.a = is.type = function(value, type) {
            return typeof value === type;
        }, /**
 * is.defined
 * Test if `value` is defined.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if 'value' is defined, false otherwise
 * @api public
 */
        is.defined = function(value) {
            return void 0 !== value;
        }, /**
 * is.empty
 * Test if `value` is empty.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is empty, false otherwise
 * @api public
 */
        is.empty = function(value) {
            var key, type = toStr.call(value);
            if ("[object Array]" === type || "[object Arguments]" === type || "[object String]" === type) return 0 === value.length;
            if ("[object Object]" === type) {
                for (key in value) if (owns.call(value, key)) return !1;
                return !0;
            }
            return !value;
        }, /**
 * is.equal
 * Test if `value` is equal to `other`.
 *
 * @param {Mixed} value value to test
 * @param {Mixed} other value to compare with
 * @return {Boolean} true if `value` is equal to `other`, false otherwise
 */
        is.equal = function(value, other) {
            if (value === other) return !0;
            var key, type = toStr.call(value);
            if (type !== toStr.call(other)) return !1;
            if ("[object Object]" === type) {
                for (key in value) if (!(is.equal(value[key], other[key]) && key in other)) return !1;
                for (key in other) if (!(is.equal(value[key], other[key]) && key in value)) return !1;
                return !0;
            }
            if ("[object Array]" === type) {
                if ((key = value.length) !== other.length) return !1;
                for (;key--; ) if (!is.equal(value[key], other[key])) return !1;
                return !0;
            }
            return "[object Function]" === type ? value.prototype === other.prototype : "[object Date]" === type && value.getTime() === other.getTime();
        }, /**
 * is.hosted
 * Test if `value` is hosted by `host`.
 *
 * @param {Mixed} value to test
 * @param {Mixed} host host to test with
 * @return {Boolean} true if `value` is hosted by `host`, false otherwise
 * @api public
 */
        is.hosted = function(value, host) {
            var type = typeof host[value];
            return "object" === type ? !!host[value] : !NON_HOST_TYPES[type];
        }, /**
 * is.instance
 * Test if `value` is an instance of `constructor`.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an instance of `constructor`
 * @api public
 */
        is.instance = is.instanceof = function(value, constructor) {
            return value instanceof constructor;
        }, /**
 * is.nil / is.null
 * Test if `value` is null.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is null, false otherwise
 * @api public
 */
        is.nil = is.null = function(value) {
            return null === value;
        }, /**
 * is.undef / is.undefined
 * Test if `value` is undefined.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is undefined, false otherwise
 * @api public
 */
        is.undef = is.undefined = function(value) {
            return void 0 === value;
        }, /**
 * Test arguments.
 */
        /**
 * is.args
 * Test if `value` is an arguments object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an arguments object, false otherwise
 * @api public
 */
        is.args = is.arguments = function(value) {
            var isStandardArguments = "[object Arguments]" === toStr.call(value), isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);
            return isStandardArguments || isOldArguments;
        }, /**
 * Test array.
 */
        /**
 * is.array
 * Test if 'value' is an array.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an array, false otherwise
 * @api public
 */
        is.array = Array.isArray || function(value) {
            return "[object Array]" === toStr.call(value);
        }, /**
 * is.arguments.empty
 * Test if `value` is an empty arguments object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an empty arguments object, false otherwise
 * @api public
 */
        is.args.empty = function(value) {
            return is.args(value) && 0 === value.length;
        }, /**
 * is.array.empty
 * Test if `value` is an empty array.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an empty array, false otherwise
 * @api public
 */
        is.array.empty = function(value) {
            return is.array(value) && 0 === value.length;
        }, /**
 * is.arraylike
 * Test if `value` is an arraylike object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an arguments object, false otherwise
 * @api public
 */
        is.arraylike = function(value) {
            return !!value && !is.bool(value) && owns.call(value, "length") && isFinite(value.length) && is.number(value.length) && value.length >= 0;
        }, /**
 * Test boolean.
 */
        /**
 * is.bool
 * Test if `value` is a boolean.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a boolean, false otherwise
 * @api public
 */
        is.bool = is.boolean = function(value) {
            return "[object Boolean]" === toStr.call(value);
        }, /**
 * is.false
 * Test if `value` is false.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is false, false otherwise
 * @api public
 */
        is.false = function(value) {
            return is.bool(value) && !1 === Boolean(Number(value));
        }, /**
 * is.true
 * Test if `value` is true.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is true, false otherwise
 * @api public
 */
        is.true = function(value) {
            return is.bool(value) && !0 === Boolean(Number(value));
        }, /**
 * Test date.
 */
        /**
 * is.date
 * Test if `value` is a date.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a date, false otherwise
 * @api public
 */
        is.date = function(value) {
            return "[object Date]" === toStr.call(value);
        }, /**
 * is.date.valid
 * Test if `value` is a valid date.
 *
 * @param {Mixed} value value to test
 * @returns {Boolean} true if `value` is a valid date, false otherwise
 */
        is.date.valid = function(value) {
            return is.date(value) && !isNaN(Number(value));
        }, /**
 * Test element.
 */
        /**
 * is.element
 * Test if `value` is an html element.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an HTML Element, false otherwise
 * @api public
 */
        is.element = function(value) {
            return void 0 !== value && "undefined" != typeof HTMLElement && value instanceof HTMLElement && 1 === value.nodeType;
        }, /**
 * Test error.
 */
        /**
 * is.error
 * Test if `value` is an error object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an error object, false otherwise
 * @api public
 */
        is.error = function(value) {
            return "[object Error]" === toStr.call(value);
        }, /**
 * Test function.
 */
        /**
 * is.fn / is.function (deprecated)
 * Test if `value` is a function.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a function, false otherwise
 * @api public
 */
        is.fn = is.function = function(value) {
            if ("undefined" != typeof window && value === window.alert) return !0;
            var str = toStr.call(value);
            return "[object Function]" === str || "[object GeneratorFunction]" === str || "[object AsyncFunction]" === str;
        }, /**
 * Test number.
 */
        /**
 * is.number
 * Test if `value` is a number.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a number, false otherwise
 * @api public
 */
        is.number = function(value) {
            return "[object Number]" === toStr.call(value);
        }, /**
 * is.infinite
 * Test if `value` is positive or negative infinity.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise
 * @api public
 */
        is.infinite = function(value) {
            return value === 1 / 0 || value === -1 / 0;
        }, /**
 * is.decimal
 * Test if `value` is a decimal number.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a decimal number, false otherwise
 * @api public
 */
        is.decimal = function(value) {
            return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 != 0;
        }, /**
 * is.divisibleBy
 * Test if `value` is divisible by `n`.
 *
 * @param {Number} value value to test
 * @param {Number} n dividend
 * @return {Boolean} true if `value` is divisible by `n`, false otherwise
 * @api public
 */
        is.divisibleBy = function(value, n) {
            var isDividendInfinite = is.infinite(value), isDivisorInfinite = is.infinite(n), isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && 0 !== n;
            return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n == 0;
        }, /**
 * is.integer
 * Test if `value` is an integer.
 *
 * @param value to test
 * @return {Boolean} true if `value` is an integer, false otherwise
 * @api public
 */
        is.integer = is.int = function(value) {
            return is.number(value) && !isActualNaN(value) && value % 1 == 0;
        }, /**
 * is.maximum
 * Test if `value` is greater than 'others' values.
 *
 * @param {Number} value value to test
 * @param {Array} others values to compare with
 * @return {Boolean} true if `value` is greater than `others` values
 * @api public
 */
        is.maximum = function(value, others) {
            if (isActualNaN(value)) throw new TypeError("NaN is not a valid value");
            if (!is.arraylike(others)) throw new TypeError("second argument must be array-like");
            for (var len = others.length; --len >= 0; ) if (value < others[len]) return !1;
            return !0;
        }, /**
 * is.minimum
 * Test if `value` is less than `others` values.
 *
 * @param {Number} value value to test
 * @param {Array} others values to compare with
 * @return {Boolean} true if `value` is less than `others` values
 * @api public
 */
        is.minimum = function(value, others) {
            if (isActualNaN(value)) throw new TypeError("NaN is not a valid value");
            if (!is.arraylike(others)) throw new TypeError("second argument must be array-like");
            for (var len = others.length; --len >= 0; ) if (value > others[len]) return !1;
            return !0;
        }, /**
 * is.nan
 * Test if `value` is not a number.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is not a number, false otherwise
 * @api public
 */
        is.nan = function(value) {
            return !is.number(value) || value !== value;
        }, /**
 * is.even
 * Test if `value` is an even number.
 *
 * @param {Number} value value to test
 * @return {Boolean} true if `value` is an even number, false otherwise
 * @api public
 */
        is.even = function(value) {
            return is.infinite(value) || is.number(value) && value === value && value % 2 == 0;
        }, /**
 * is.odd
 * Test if `value` is an odd number.
 *
 * @param {Number} value value to test
 * @return {Boolean} true if `value` is an odd number, false otherwise
 * @api public
 */
        is.odd = function(value) {
            return is.infinite(value) || is.number(value) && value === value && value % 2 != 0;
        }, /**
 * is.ge
 * Test if `value` is greater than or equal to `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean}
 * @api public
 */
        is.ge = function(value, other) {
            if (isActualNaN(value) || isActualNaN(other)) throw new TypeError("NaN is not a valid value");
            return !is.infinite(value) && !is.infinite(other) && value >= other;
        }, /**
 * is.gt
 * Test if `value` is greater than `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean}
 * @api public
 */
        is.gt = function(value, other) {
            if (isActualNaN(value) || isActualNaN(other)) throw new TypeError("NaN is not a valid value");
            return !is.infinite(value) && !is.infinite(other) && value > other;
        }, /**
 * is.le
 * Test if `value` is less than or equal to `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean} if 'value' is less than or equal to 'other'
 * @api public
 */
        is.le = function(value, other) {
            if (isActualNaN(value) || isActualNaN(other)) throw new TypeError("NaN is not a valid value");
            return !is.infinite(value) && !is.infinite(other) && value <= other;
        }, /**
 * is.lt
 * Test if `value` is less than `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean} if `value` is less than `other`
 * @api public
 */
        is.lt = function(value, other) {
            if (isActualNaN(value) || isActualNaN(other)) throw new TypeError("NaN is not a valid value");
            return !is.infinite(value) && !is.infinite(other) && value < other;
        }, /**
 * is.within
 * Test if `value` is within `start` and `finish`.
 *
 * @param {Number} value value to test
 * @param {Number} start lower bound
 * @param {Number} finish upper bound
 * @return {Boolean} true if 'value' is is within 'start' and 'finish'
 * @api public
 */
        is.within = function(value, start, finish) {
            if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) throw new TypeError("NaN is not a valid value");
            if (!is.number(value) || !is.number(start) || !is.number(finish)) throw new TypeError("all arguments must be numbers");
            return is.infinite(value) || is.infinite(start) || is.infinite(finish) || value >= start && value <= finish;
        }, /**
 * Test object.
 */
        /**
 * is.object
 * Test if `value` is an object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an object, false otherwise
 * @api public
 */
        is.object = function(value) {
            return "[object Object]" === toStr.call(value);
        }, /**
 * is.primitive
 * Test if `value` is a primitive.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a primitive, false otherwise
 * @api public
 */
        is.primitive = function(value) {
            return !value || !("object" == typeof value || is.object(value) || is.fn(value) || is.array(value));
        }, /**
 * is.hash
 * Test if `value` is a hash - a plain object literal.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a hash, false otherwise
 * @api public
 */
        is.hash = function(value) {
            return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
        }, /**
 * Test regexp.
 */
        /**
 * is.regexp
 * Test if `value` is a regular expression.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a regexp, false otherwise
 * @api public
 */
        is.regexp = function(value) {
            return "[object RegExp]" === toStr.call(value);
        }, /**
 * Test string.
 */
        /**
 * is.string
 * Test if `value` is a string.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if 'value' is a string, false otherwise
 * @api public
 */
        is.string = function(value) {
            return "[object String]" === toStr.call(value);
        }, /**
 * Test base64 string.
 */
        /**
 * is.base64
 * Test if `value` is a valid base64 encoded string.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if 'value' is a base64 encoded string, false otherwise
 * @api public
 */
        is.base64 = function(value) {
            return is.string(value) && (!value.length || base64Regex.test(value));
        }, /**
 * Test base64 string.
 */
        /**
 * is.hex
 * Test if `value` is a valid hex encoded string.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if 'value' is a hex encoded string, false otherwise
 * @api public
 */
        is.hex = function(value) {
            return is.string(value) && (!value.length || hexRegex.test(value));
        }, /**
 * is.symbol
 * Test if `value` is an ES6 Symbol
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a Symbol, false otherise
 * @api public
 */
        is.symbol = function(value) {
            return "function" == typeof Symbol && "[object Symbol]" === toStr.call(value) && "symbol" == typeof symbolValueOf.call(value);
        }, module.exports = is;
    }, /* 46 */
    /***/
    function(module, exports) {
        module.exports = function(string) {
            return /.+\@.+\..+/.test(string);
        };
    }, /* 47 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Initialize a new `Emitter`.
 *
 * @api public
 */
        function Emitter(obj) {
            if (obj) return mixin(obj);
        }
        /**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */
        function mixin(obj) {
            for (var key in Emitter.prototype) obj[key] = Emitter.prototype[key];
            return obj;
        }
        module.exports = Emitter, /**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */
        Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn), 
            this;
        }, /**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */
        Emitter.prototype.once = function(event, fn) {
            function on() {
                this.off(event, on), fn.apply(this, arguments);
            }
            return on.fn = fn, this.on(event, on), this;
        }, /**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */
        Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
            // all
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, 
            this;
            // specific event
            var callbacks = this._callbacks["$" + event];
            if (!callbacks) return this;
            // remove all handlers
            if (1 == arguments.length) return delete this._callbacks["$" + event], this;
            for (var cb, i = 0; i < callbacks.length; i++) if ((cb = callbacks[i]) === fn || cb.fn === fn) {
                callbacks.splice(i, 1);
                break;
            }
            return this;
        }, /**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */
        Emitter.prototype.emit = function(event) {
            this._callbacks = this._callbacks || {};
            var args = [].slice.call(arguments, 1), callbacks = this._callbacks["$" + event];
            if (callbacks) {
                callbacks = callbacks.slice(0);
                for (var i = 0, len = callbacks.length; i < len; ++i) callbacks[i].apply(this, args);
            }
            return this;
        }, /**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */
        Emitter.prototype.listeners = function(event) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + event] || [];
        }, /**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */
        Emitter.prototype.hasListeners = function(event) {
            return !!this.listeners(event).length;
        };
    }, /* 48 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Cookie` with `options`.
 *
 * @param {Object} options
 */
        function Cookie(options) {
            this.options(options);
        }
        /**
 * Module dependencies.
 */
        var bindAll = __webpack_require__(23), clone = __webpack_require__(26), cookie = __webpack_require__(49), debug = __webpack_require__(4)("analytics.js:cookie"), defaults = __webpack_require__(27), json = __webpack_require__(28), topDomain = __webpack_require__(103);
        /**
 * Get or set the cookie options.
 *
 * @param {Object} options
 *   @field {Number} maxage (1 year)
 *   @field {String} domain
 *   @field {String} path
 *   @field {Boolean} secure
 */
        Cookie.prototype.options = function(options) {
            if (0 === arguments.length) return this._options;
            options = options || {};
            var domain = "." + topDomain(window.location.href);
            "." === domain && (domain = null), this._options = defaults(options, {
                // default to a year
                maxage: 31536e6,
                path: "/",
                domain: domain
            }), // http://curl.haxx.se/rfc/cookie_spec.html
            // https://publicsuffix.org/list/effective_tld_names.dat
            //
            // try setting a dummy cookie with the options
            // if the cookie isn't set, it probably means
            // that the domain is on the public suffix list
            // like myapp.herokuapp.com or localhost / ip.
            this.set("ajs:test", !0), this.get("ajs:test") || (debug("fallback to domain=null"), 
            this._options.domain = null), this.remove("ajs:test");
        }, /**
 * Set a `key` and `value` in our cookie.
 *
 * @param {String} key
 * @param {Object} value
 * @return {Boolean} saved
 */
        Cookie.prototype.set = function(key, value) {
            try {
                return value = json.stringify(value), cookie(key, value, clone(this._options)), 
                !0;
            } catch (e) {
                return !1;
            }
        }, /**
 * Get a value from our cookie by `key`.
 *
 * @param {String} key
 * @return {Object} value
 */
        Cookie.prototype.get = function(key) {
            try {
                var value = cookie(key);
                return value = value ? json.parse(value) : null;
            } catch (e) {
                return null;
            }
        }, /**
 * Remove a value from our cookie by `key`.
 *
 * @param {String} key
 * @return {Boolean} removed
 */
        Cookie.prototype.remove = function(key) {
            try {
                return cookie(key, null, clone(this._options)), !0;
            } catch (e) {
                return !1;
            }
        }, /**
 * Expose the cookie singleton.
 */
        module.exports = bindAll(new Cookie()), /**
 * Expose the `Cookie` constructor.
 */
        module.exports.Cookie = Cookie;
    }, /* 49 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Set cookie `name` to `value`.
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @api private
 */
        function set(name, value, options) {
            options = options || {};
            var str = encode(name) + "=" + encode(value);
            null == value && (options.maxage = -1), options.maxage && (options.expires = new Date(+new Date() + options.maxage)), 
            options.path && (str += "; path=" + options.path), options.domain && (str += "; domain=" + options.domain), 
            options.expires && (str += "; expires=" + options.expires.toUTCString()), options.secure && (str += "; secure"), 
            document.cookie = str;
        }
        /**
 * Return all cookies.
 *
 * @return {Object}
 * @api private
 */
        function all() {
            var str;
            try {
                str = document.cookie;
            } catch (err) {
                return "undefined" != typeof console && "function" == typeof console.error && console.error(err.stack || err), 
                {};
            }
            return parse(str);
        }
        /**
 * Get cookie `name`.
 *
 * @param {String} name
 * @return {String}
 * @api private
 */
        function get(name) {
            return all()[name];
        }
        /**
 * Parse cookie `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */
        function parse(str) {
            var pair, obj = {}, pairs = str.split(/ *; */);
            if ("" == pairs[0]) return obj;
            for (var i = 0; i < pairs.length; ++i) pair = pairs[i].split("="), obj[decode(pair[0])] = decode(pair[1]);
            return obj;
        }
        /**
 * Encode.
 */
        function encode(value) {
            try {
                return encodeURIComponent(value);
            } catch (e) {
                debug("error `encode(%o)` - %o", value, e);
            }
        }
        /**
 * Decode.
 */
        function decode(value) {
            try {
                return decodeURIComponent(value);
            } catch (e) {
                debug("error `decode(%o)` - %o", value, e);
            }
        }
        /**
 * Module dependencies.
 */
        var debug = __webpack_require__(4)("cookie");
        /**
 * Set or get cookie `name` with `value` and `options` object.
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {Mixed}
 * @api public
 */
        module.exports = function(name, value, options) {
            switch (arguments.length) {
              case 3:
              case 2:
                return set(name, value, options);

              case 1:
                return get(name);

              default:
                return all();
            }
        };
    }, /* 50 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */
        (function(process, setImmediate) {
            var callable, byObserver;
            callable = function(fn) {
                if ("function" != typeof fn) throw new TypeError(fn + " is not a function");
                return fn;
            }, byObserver = function(Observer) {
                var queue, node = document.createTextNode(""), i = 0;
                return new Observer(function() {
                    var data;
                    if (queue) {
                        if (data = queue, queue = null, "function" == typeof data) return void data();
                        data.forEach(function(fn) {
                            fn();
                        });
                    }
                }).observe(node, {
                    characterData: !0
                }), function(fn) {
                    if (callable(fn), queue) return void ("function" == typeof queue ? queue = [ queue, fn ] : queue.push(fn));
                    queue = fn, node.data = i = ++i % 2;
                };
            }, module.exports = function() {
                // Node.js
                if (void 0 !== process && process && "function" == typeof process.nextTick) return process.nextTick;
                // MutationObserver=
                if ("object" == typeof document && document) {
                    if ("function" == typeof MutationObserver) return byObserver(MutationObserver);
                    if ("function" == typeof WebKitMutationObserver) return byObserver(WebKitMutationObserver);
                }
                // W3C Draft
                // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
                // W3C Draft
                // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
                // Wide available standard
                return "function" == typeof setImmediate ? function(cb) {
                    setImmediate(callable(cb));
                } : "function" == typeof setTimeout ? function(cb) {
                    setTimeout(callable(cb), 0);
                } : null;
            }();
        }).call(exports, __webpack_require__(69), __webpack_require__(185).setImmediate);
    }, /* 51 */
    /***/
    function(module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil, floor = Math.floor;
        module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
    }, /* 52 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__(53), $export = __webpack_require__(3), redefine = __webpack_require__(85), hide = __webpack_require__(12), has = __webpack_require__(19), Iterators = __webpack_require__(24), $iterCreate = __webpack_require__(139), setToStringTag = __webpack_require__(40), getPrototypeOf = __webpack_require__(87), ITERATOR = __webpack_require__(2)("iterator"), BUGGY = !([].keys && "next" in [].keys()), returnThis = function() {
            return this;
        };
        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var methods, key, IteratorPrototype, getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case "keys":
                  case "values":
                    return function() {
                        return new Constructor(this, kind);
                    };
                }
                return function() {
                    return new Constructor(this, kind);
                };
            }, TAG = NAME + " Iterator", DEF_VALUES = "values" == DEFAULT, VALUES_BUG = !1, proto = Base.prototype, $native = proto[ITERATOR] || proto["@@iterator"] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0, $anyNative = "Array" == NAME ? proto.entries || $native : $native;
            if (// Fix native
            $anyNative && (IteratorPrototype = getPrototypeOf($anyNative.call(new Base()))) !== Object.prototype && (// Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, !0), // fix for some old engines
            LIBRARY || has(IteratorPrototype, ITERATOR) || hide(IteratorPrototype, ITERATOR, returnThis)), 
            // fix Array#{values, @@iterator}.name in V8 / FF
            DEF_VALUES && $native && "values" !== $native.name && (VALUES_BUG = !0, $default = function() {
                return $native.call(this);
            }), // Define iterator
            LIBRARY && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || hide(proto, ITERATOR, $default), 
            // Plug for library
            Iterators[NAME] = $default, Iterators[TAG] = returnThis, DEFAULT) if (methods = {
                values: DEF_VALUES ? $default : getMethod("values"),
                keys: IS_SET ? $default : getMethod("keys"),
                entries: $entries
            }, FORCED) for (key in methods) key in proto || redefine(proto, key, methods[key]); else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            return methods;
        };
    }, /* 53 */
    /***/
    function(module, exports) {
        module.exports = !0;
    }, /* 54 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __webpack_require__(14);
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function(it, S) {
            if (!isObject(it)) return it;
            var fn, val;
            if (S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            if ("function" == typeof (fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
            if (!S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value");
        };
    }, /* 55 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __webpack_require__(56);
        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return "String" == cof(it) ? it.split("") : Object(it);
        };
    }, /* 56 */
    /***/
    function(module, exports) {
        var toString = {}.toString;
        module.exports = function(it) {
            return toString.call(it).slice(8, -1);
        };
    }, /* 57 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.15 ToLength
        var toInteger = __webpack_require__(51), min = Math.min;
        module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
        };
    }, /* 58 */
    /***/
    function(module, exports, __webpack_require__) {
        var shared = __webpack_require__(59)("keys"), uid = __webpack_require__(39);
        module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key));
        };
    }, /* 59 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(6), store = global["__core-js_shared__"] || (global["__core-js_shared__"] = {});
        module.exports = function(key) {
            return store[key] || (store[key] = {});
        };
    }, /* 60 */
    /***/
    function(module, exports) {
        // IE 8- don't enum bug keys
        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, /* 61 */
    /***/
    function(module, exports, __webpack_require__) {
        exports.f = __webpack_require__(2);
    }, /* 62 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(6), core = __webpack_require__(0), LIBRARY = __webpack_require__(53), wksExt = __webpack_require__(61), defineProperty = __webpack_require__(7).f;
        module.exports = function(name) {
            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
            "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
                value: wksExt.f(name)
            });
        };
    }, /* 63 */
    /***/
    function(module, exports) {
        exports.f = Object.getOwnPropertySymbols;
    }, /* 64 */
    /***/
    function(module, exports, __webpack_require__) {
        // most Object methods by ES6 should accept primitives
        var $export = __webpack_require__(3), core = __webpack_require__(0), fails = __webpack_require__(18);
        module.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
            exp[KEY] = exec(fn), $export($export.S + $export.F * fails(function() {
                fn(1);
            }), "Object", exp);
        };
    }, /* 65 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(156),
            __esModule: !0
        };
    }, /* 66 */
    /***/
    function(module, exports) {
        "function" == typeof Object.create ? // implementation from standard node.js 'util' module
        module.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            });
        } : // old school shim for old browsers
        module.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
        };
    }, /* 67 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * If the number passed val is seconds from the epoch, turn it into milliseconds.
 * Milliseconds would be greater than 31557600000 (December 31, 1970).
 *
 * @param {number} num
 */
        function toMs(num) {
            return num < 315576e5 ? 1e3 * num : num;
        }
        var is = __webpack_require__(45), isodate = __webpack_require__(93), milliseconds = __webpack_require__(164), seconds = __webpack_require__(165);
        /**
 * Returns a new Javascript Date object, allowing a variety of extra input types
 * over the native Date constructor.
 *
 * @param {Date|string|number} val
 */
        module.exports = function(val) {
            // date strings
            return is.date(val) ? val : is.number(val) ? new Date(toMs(val)) : isodate.is(val) ? isodate.parse(val) : milliseconds.is(val) ? milliseconds.parse(val) : seconds.is(val) ? seconds.parse(val) : new Date(val);
        };
    }, /* 68 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Track` facade with a `dictionary` of arguments.
 *
 * @param {object} dictionary
 *   @property {string} event
 *   @property {string} userId
 *   @property {string} sessionId
 *   @property {Object} properties
 *   @property {Object} options
 * @param {Object} opts
 *   @property {boolean|undefined} clone
 */
        function Track(dictionary, opts) {
            Facade.call(this, dictionary, opts);
        }
        /**
 * Get float from currency value.
 *
 * @param {*} val
 * @return {number}
 */
        function currency(val) {
            if (val) {
                if ("number" == typeof val) return val;
                if ("string" == typeof val) return val = val.replace(/\$/g, ""), val = parseFloat(val), 
                isNaN(val) ? void 0 : val;
            }
        }
        var inherit = __webpack_require__(9).inherit, type = __webpack_require__(9).type, Facade = __webpack_require__(25), Identify = __webpack_require__(98), isEmail = __webpack_require__(46), get = __webpack_require__(44);
        /**
 * Inherit from `Facade`.
 */
        inherit(Track, Facade), /**
 * Return the facade's action.
 *
 * @return {string}
 */
        Track.prototype.action = function() {
            return "track";
        }, Track.prototype.type = Track.prototype.action, /**
 * Setup some basic proxies.
 */
        Track.prototype.event = Facade.field("event"), Track.prototype.value = Facade.proxy("properties.value"), 
        /**
 * Misc
 */
        Track.prototype.category = Facade.proxy("properties.category"), /**
 * Ecommerce
 */
        /**
 * ids
 */
        Track.prototype.id = Facade.proxy("properties.id"), Track.prototype.productId = function() {
            return this.proxy("properties.product_id") || this.proxy("properties.productId");
        }, Track.prototype.promotionId = function() {
            return this.proxy("properties.promotion_id") || this.proxy("properties.promotionId");
        }, Track.prototype.cartId = function() {
            return this.proxy("properties.cart_id") || this.proxy("properties.cartId");
        }, Track.prototype.checkoutId = function() {
            return this.proxy("properties.checkout_id") || this.proxy("properties.checkoutId");
        }, Track.prototype.paymentId = function() {
            return this.proxy("properties.payment_id") || this.proxy("properties.paymentId");
        }, Track.prototype.couponId = function() {
            return this.proxy("properties.coupon_id") || this.proxy("properties.couponId");
        }, Track.prototype.wishlistId = function() {
            return this.proxy("properties.wishlist_id") || this.proxy("properties.wishlistId");
        }, Track.prototype.reviewId = function() {
            return this.proxy("properties.review_id") || this.proxy("properties.reviewId");
        }, Track.prototype.orderId = function() {
            // doesn't follow above convention since this fallback order was how it used to be
            return this.proxy("properties.id") || this.proxy("properties.order_id") || this.proxy("properties.orderId");
        }, Track.prototype.sku = Facade.proxy("properties.sku"), Track.prototype.tax = Facade.proxy("properties.tax"), 
        Track.prototype.name = Facade.proxy("properties.name"), Track.prototype.price = Facade.proxy("properties.price"), 
        Track.prototype.total = Facade.proxy("properties.total"), Track.prototype.repeat = Facade.proxy("properties.repeat"), 
        Track.prototype.coupon = Facade.proxy("properties.coupon"), Track.prototype.shipping = Facade.proxy("properties.shipping"), 
        Track.prototype.discount = Facade.proxy("properties.discount"), Track.prototype.shippingMethod = function() {
            return this.proxy("properties.shipping_method") || this.proxy("properties.shippingMethod");
        }, Track.prototype.paymentMethod = function() {
            return this.proxy("properties.payment_method") || this.proxy("properties.paymentMethod");
        }, /**
 * Description
 */
        Track.prototype.description = Facade.proxy("properties.description"), /**
 * Plan
 */
        Track.prototype.plan = Facade.proxy("properties.plan"), /**
 * Get subtotal.
 *
 * @return {number}
 */
        Track.prototype.subtotal = function() {
            var subtotal = get(this.properties(), "subtotal"), total = this.total() || this.revenue();
            if (subtotal) return subtotal;
            if (!total) return 0;
            if (this.total()) {
                var n = this.tax();
                n && (total -= n), n = this.shipping(), n && (total -= n), n = this.discount(), 
                n && (total += n);
            }
            return total;
        }, /**
 * Get products.
 *
 * @return {Array}
 */
        Track.prototype.products = function() {
            var props = this.properties(), products = get(props, "products");
            return "array" === type(products) ? products : [];
        }, /**
 * Get quantity.
 *
 * @return {number}
 */
        Track.prototype.quantity = function() {
            return (this.obj.properties || {}).quantity || 1;
        }, /**
 * Get currency.
 *
 * @return {string}
 */
        Track.prototype.currency = function() {
            return (this.obj.properties || {}).currency || "USD";
        }, /**
 * BACKWARDS COMPATIBILITY: should probably re-examine where these come from.
 */
        Track.prototype.referrer = function() {
            return this.proxy("context.referrer.url") || this.proxy("context.page.referrer") || this.proxy("properties.referrer");
        }, Track.prototype.query = Facade.proxy("options.query"), /**
 * Get the call's properties.
 *
 * @param {Object} aliases
 * @return {Object}
 */
        Track.prototype.properties = function(aliases) {
            var ret = this.field("properties") || {};
            aliases = aliases || {};
            for (var alias in aliases) {
                var value = null == this[alias] ? this.proxy("properties." + alias) : this[alias]();
                null != value && (ret[aliases[alias]] = value, delete ret[alias]);
            }
            return ret;
        }, /**
 * Get the call's username.
 *
 * @return {string|undefined}
 */
        Track.prototype.username = function() {
            return this.proxy("traits.username") || this.proxy("properties.username") || this.userId() || this.sessionId();
        }, /**
 * Get the call's email, using an the user ID if it's a valid email.
 *
 * @return {string|undefined}
 */
        Track.prototype.email = function() {
            var email = this.proxy("traits.email") || this.proxy("properties.email") || this.proxy("options.traits.email");
            if (email) return email;
            var userId = this.userId();
            return isEmail(userId) ? userId : void 0;
        }, /**
 * Get the call's revenue, parsing it from a string with an optional leading
 * dollar sign.
 *
 * For products/services that don't have shipping and are not directly taxed,
 * they only care about tracking `revenue`. These are things like
 * SaaS companies, who sell monthly subscriptions. The subscriptions aren't
 * taxed directly, and since it's a digital product, it has no shipping.
 *
 * The only case where there's a difference between `revenue` and `total`
 * (in the context of analytics) is on ecommerce platforms, where they want
 * the `revenue` function to actually return the `total` (which includes
 * tax and shipping, total = subtotal + tax + shipping). This is probably
 * because on their backend they assume tax and shipping has been applied to
 * the value, and so can get the revenue on their own.
 *
 * @return {number}
 */
        Track.prototype.revenue = function() {
            var revenue = this.proxy("properties.revenue"), event = this.event(), orderCompletedRegExp = /^[ _]?completed[ _]?order[ _]?|^[ _]?order[ _]?completed[ _]?$/i;
            // it's always revenue, unless it's called during an order completion.
            return !revenue && event && event.match(orderCompletedRegExp) && (revenue = this.proxy("properties.total")), 
            currency(revenue);
        }, /**
 * Get cents.
 *
 * @return {number}
 */
        Track.prototype.cents = function() {
            var revenue = this.revenue();
            return "number" != typeof revenue ? this.value() || 0 : 100 * revenue;
        }, /**
 * A utility to turn the pieces of a track call into an identify. Used for
 * integrations with super properties or rate limits.
 *
 * TODO: remove me.
 *
 * @return {Facade}
 */
        Track.prototype.identify = function() {
            var json = this.json();
            return json.traits = this.traits(), new Identify(json, this.opts);
        }, /**
 * Exports.
 */
        module.exports = Track;
    }, /* 69 */
    /***/
    function(module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
            return setTimeout(fun, 0);
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
            return clearTimeout(marker);
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        // shim for using process in browser
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", // empty string to avoid regexp issues
        process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, 
        process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, /* 70 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var each = __webpack_require__(5), foldl = function(iterator, accumulator, collection) {
            if ("function" != typeof iterator) throw new TypeError("Expected a function but received a " + typeof iterator);
            return each(function(val, i, collection) {
                accumulator = iterator(accumulator, val, i, collection);
            }, collection), accumulator;
        };
        /*
 * Exports.
 */
        module.exports = foldl;
    }, /* 71 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var has = Object.prototype.hasOwnProperty, extend = function(dest) {
            for (var sources = Array.prototype.slice.call(arguments, 1), i = 0; i < sources.length; i += 1) for (var key in sources[i]) has.call(sources[i], key) && (dest[key] = sources[i][key]);
            return dest;
        };
        /*
 * Exports.
 */
        module.exports = extend;
    }, /* 72 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Store` with `options`.
 *
 * @param {Object} options
 */
        function Store(options) {
            this.options(options);
        }
        /*
 * Module dependencies.
 */
        var bindAll = __webpack_require__(23), defaults = __webpack_require__(27), store = __webpack_require__(183);
        /**
 * Set the `options` for the store.
 *
 * @param {Object} options
 *   @field {Boolean} enabled (true)
 */
        Store.prototype.options = function(options) {
            if (0 === arguments.length) return this._options;
            options = options || {}, defaults(options, {
                enabled: !0
            }), this.enabled = options.enabled && store.enabled, this._options = options;
        }, /**
 * Set a `key` and `value` in local storage.
 *
 * @param {string} key
 * @param {Object} value
 */
        Store.prototype.set = function(key, value) {
            return !!this.enabled && store.set(key, value);
        }, /**
 * Get a value from local storage by `key`.
 *
 * @param {string} key
 * @return {Object}
 */
        Store.prototype.get = function(key) {
            return this.enabled ? store.get(key) : null;
        }, /**
 * Remove a value from local storage by `key`.
 *
 * @param {string} key
 */
        Store.prototype.remove = function(key) {
            return !!this.enabled && store.remove(key);
        }, /**
 * Expose the store singleton.
 */
        module.exports = bindAll(new Store()), /**
 * Expose the `Store` constructor.
 */
        module.exports.Store = Store;
    }, /* 73 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var each = __webpack_require__(5), strIndexOf = String.prototype.indexOf, sameValueZero = function(value1, value2) {
            // Normal values and check for 0 / -0
            // Normal values and check for 0 / -0
            return value1 === value2 ? 0 !== value1 || 1 / value1 == 1 / value2 : value1 !== value1 && value2 !== value2;
        }, includes = function(searchElement, collection) {
            var found = !1;
            // Delegate to String.prototype.indexOf when `collection` is a string
            // Delegate to String.prototype.indexOf when `collection` is a string
            // Iterate through enumerable/own array elements and object properties.
            return "string" == typeof collection ? -1 !== strIndexOf.call(collection, searchElement) : (each(function(value) {
                if (sameValueZero(value, searchElement)) // Exit iteration early when found
                return found = !0, !1;
            }, collection), found);
        };
        /*
 * Exports.
 */
        module.exports = includes;
    }, /* 74 */
    /***/
    function(module, exports, __webpack_require__) {
        // **`parse()` - Parse a UUID into it's component bytes**
        function parse(s, buf, offset) {
            var i = buf && offset || 0, ii = 0;
            // Zero out remaining bytes if string was short
            for (buf = buf || [], s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
                ii < 16 && (// Don't overflow!
                buf[i + ii++] = _hexToByte[oct]);
            }); ii < 16; ) buf[i + ii++] = 0;
            return buf;
        }
        // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
        function unparse(buf, offset) {
            var i = offset || 0, bth = _byteToHex;
            return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
        }
        // See https://github.com/broofa/node-uuid for API details
        function v1(options, buf, offset) {
            var i = buf && offset || 0, b = buf || [];
            options = options || {};
            var clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq, msecs = void 0 !== options.msecs ? options.msecs : new Date().getTime(), nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1, dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
            // Per 4.2.1.2 Throw error if too many uuids are requested
            if (// Per 4.2.1.2, Bump clockseq on clock regression
            dt < 0 && void 0 === options.clockseq && (clockseq = clockseq + 1 & 16383), // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
            // time interval
            (dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
            _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq, // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
            msecs += 122192928e5;
            // `time_low`
            var tl = (1e4 * (268435455 & msecs) + nsecs) % 4294967296;
            b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = 255 & tl;
            // `time_mid`
            var tmh = msecs / 4294967296 * 1e4 & 268435455;
            b[i++] = tmh >>> 8 & 255, b[i++] = 255 & tmh, // `time_high_and_version`
            b[i++] = tmh >>> 24 & 15 | 16, // include version
            b[i++] = tmh >>> 16 & 255, // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
            b[i++] = clockseq >>> 8 | 128, // `clock_seq_low`
            b[i++] = 255 & clockseq;
            for (var node = options.node || _nodeId, n = 0; n < 6; n++) b[i + n] = node[n];
            return buf || unparse(b);
        }
        // **`v4()` - Generate random UUID**
        // See https://github.com/broofa/node-uuid for API details
        function v4(options, buf, offset) {
            // Deprecated - 'format' argument, as supported in v1.2
            var i = buf && offset || 0;
            "string" == typeof options && (buf = "binary" == options ? new Array(16) : null, 
            options = null), options = options || {};
            var rnds = options.random || (options.rng || _rng)();
            // Copy bytes to buffer, if provided
            if (// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
            rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) for (var ii = 0; ii < 16; ii++) buf[i + ii] = rnds[ii];
            return buf || unparse(rnds);
        }
        for (var _rng = __webpack_require__(190), _byteToHex = [], _hexToByte = {}, i = 0; i < 256; i++) _byteToHex[i] = (i + 256).toString(16).substr(1), 
        _hexToByte[_byteToHex[i]] = i;
        // **`v1()` - Generate time-based UUID**
        //
        // Inspired by https://github.com/LiosK/UUID.js
        // and http://docs.python.org/library/uuid.html
        // random #'s we need to init node and clockseq
        var _seedBytes = _rng(), _nodeId = [ 1 | _seedBytes[0], _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5] ], _clockseq = 16383 & (_seedBytes[6] << 8 | _seedBytes[7]), _lastMSecs = 0, _lastNSecs = 0, uuid = v4;
        uuid.v1 = v1, uuid.v4 = v4, uuid.parse = parse, uuid.unparse = unparse, module.exports = uuid;
    }, /* 75 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Module dependencies.
 */
        var trim = __webpack_require__(99), type = __webpack_require__(196), pattern = /(\w+)\[(\d+)\]/, encode = function(str) {
            try {
                return encodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }, decode = function(str) {
            try {
                return decodeURIComponent(str.replace(/\+/g, " "));
            } catch (e) {
                return str;
            }
        };
        /**
 * Parse the given query `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */
        exports.parse = function(str) {
            if ("string" != typeof str) return {};
            if ("" == (str = trim(str))) return {};
            "?" == str.charAt(0) && (str = str.slice(1));
            for (var obj = {}, pairs = str.split("&"), i = 0; i < pairs.length; i++) {
                var m, parts = pairs[i].split("="), key = decode(parts[0]);
                (m = pattern.exec(key)) ? (obj[m[1]] = obj[m[1]] || [], obj[m[1]][m[2]] = decode(parts[1])) : obj[parts[0]] = null == parts[1] ? "" : decode(parts[1]);
            }
            return obj;
        }, /**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */
        exports.stringify = function(obj) {
            if (!obj) return "";
            var pairs = [];
            for (var key in obj) {
                var value = obj[key];
                if ("array" != type(value)) pairs.push(encode(key) + "=" + encode(obj[key])); else for (var i = 0; i < value.length; ++i) pairs.push(encode(key + "[" + i + "]") + "=" + encode(value[i]));
            }
            return pairs.join("&");
        };
    }, /* 76 */
    /***/
    function(module, exports, __webpack_require__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __webpack_require__(56), TAG = __webpack_require__(2)("toStringTag"), ARG = "Arguments" == cof(function() {
            return arguments;
        }()), tryGet = function(it, key) {
            try {
                return it[key];
            } catch (e) {}
        };
        module.exports = function(it) {
            var O, T, B;
            return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (T = tryGet(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B;
        };
    }, /* 77 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.InMemoryStore = void 0;
        var _keys = __webpack_require__(16), _keys2 = _interopRequireDefault(_keys), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), InMemoryStore = exports.InMemoryStore = function InMemoryStore() {
            var _this = this;
            (0, _classCallCheck3.default)(this, InMemoryStore), this._data = {}, this.length = 0, 
            this.setItem = function(key, value) {
                return _this._data[key] = value, _this.length = (0, _keys2.default)(_this._data).length, 
                value;
            }, this.getItem = function(key) {
                return key in _this._data ? _this._data[key] : null;
            }, this.removeItem = function(key) {
                return key in _this._data && delete _this._data[key], _this.length = (0, _keys2.default)(_this._data).length, 
                null;
            }, this.clear = function() {
                _this._data = {}, _this.length = 0;
            }, this.key = function(index) {
                return (0, _keys2.default)(_this._data)[index];
            };
        };
        exports.default = new InMemoryStore();
    }, /* 78 */
    /***/
    function(module, exports, __webpack_require__) {
        var ctx = __webpack_require__(30), call = __webpack_require__(252), isArrayIter = __webpack_require__(253), anObject = __webpack_require__(13), toLength = __webpack_require__(57), getIterFn = __webpack_require__(109), BREAK = {}, RETURN = {}, exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
            var length, step, iterator, result, iterFn = ITERATOR ? function() {
                return iterable;
            } : getIterFn(iterable), f = ctx(fn, that, entries ? 2 : 1), index = 0;
            if ("function" != typeof iterFn) throw TypeError(iterable + " is not iterable!");
            // fast case for arrays with default iterator
            if (isArrayIter(iterFn)) {
                for (length = toLength(iterable.length); length > index; index++) if ((result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index])) === BREAK || result === RETURN) return result;
            } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) if ((result = call(iterator, f, step.value, entries)) === BREAK || result === RETURN) return result;
        };
        exports.BREAK = BREAK, exports.RETURN = RETURN;
    }, /* 79 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(119), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _possibleConstructorReturn2 = __webpack_require__(120), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(121), _inherits3 = _interopRequireDefault(_inherits2), _InMemoryStorage = __webpack_require__(77), _InMemoryStorage2 = _interopRequireDefault(_InMemoryStorage), _SafeStorage2 = __webpack_require__(122), _SafeStorage3 = _interopRequireDefault(_SafeStorage2), _class = function(_SafeStorage) {
            function _class(environmentPrefix) {
                (0, _classCallCheck3.default)(this, _class);
                var storageToUse = void 0;
                try {
                    storageToUse = window.sessionStorage || _InMemoryStorage2.default;
                } catch (err) {
                    storageToUse = _InMemoryStorage2.default;
                }
                return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, storageToUse, environmentPrefix));
            }
            return (0, _inherits3.default)(_class, _SafeStorage), _class;
        }(_SafeStorage3.default);
        exports.default = _class;
    }, /* 80 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(268),
            __esModule: !0
        };
    }, /* 81 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.defaultHistoryReplaceFn = void 0;
        var _keys = __webpack_require__(16), _keys2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_keys), _queryString = __webpack_require__(129), _objectUtils = __webpack_require__(130), defaultHistoryReplaceFn = exports.defaultHistoryReplaceFn = function(newUrl) {
            return window.history.replaceState({}, "", newUrl);
        }, urlParamExtractor = function(isCaptureParam) {
            var historyReplaceFn = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : defaultHistoryReplaceFn, originalUrl = window.location.href, fragmentHash = window.location.hash, removedFragmentURL = "" !== fragmentHash ? originalUrl.replace(fragmentHash, "") : originalUrl, _parseUrl = (0, 
            _queryString.parseUrl)(removedFragmentURL), url = _parseUrl.url, query = _parseUrl.query, captureParams = (0, 
            _objectUtils.pickBy)(query, isCaptureParam);
            // Do not modify URL if no matches
            if ((0, _keys2.default)(captureParams).length > 0) {
                var queryWithoutCaptureParams = (0, _objectUtils.omitBy)(query, isCaptureParam);
                // Replace the URL minus captured parameters
                if ((0, _keys2.default)(queryWithoutCaptureParams).length > 0) {
                    historyReplaceFn(url + "?" + (0, _queryString.stringify)(queryWithoutCaptureParams) + fragmentHash);
                } else historyReplaceFn("" + url + fragmentHash);
            }
            return captureParams;
        };
        exports.default = urlParamExtractor;
    }, /* 82 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function validateContainersObject(container) {
            if (!(0, _objectUtils.isPlainObject)(container)) throw new Error("properties.containers must be an Object");
            if (!("id" in container)) throw new Error("properties.containers is missing field 'id'");
            if ("string" != typeof container.id) throw new Error("properties.containers.id must be of type String");
            if ("type" in container && "string" != typeof container.type) throw new Error("properties.containers.type must be of type String");
        }
        function validateContainers(containers) {
            if (containers) {
                if (containers && containers.constructor !== Object) throw new Error("properties.containers must be an Object");
                (0, _values2.default)(containers).forEach(function(container) {
                    return validateContainersObject(container);
                });
            }
        }
        function validateActionEvent(event) {
            if (!event) throw new Error("Missing event");
            if (!event.source) throw new Error("Missing event.source");
            if (!event.actionSubject) throw new Error("Missing event.actionSubject");
            if (!event.action) throw new Error("Missing event.action");
            validateContainers(event.containers);
        }
        function validateScreenEvent(name) {
            if (!name) throw new Error("Missing name");
        }
        function validateTrackEvent(event) {
            validateActionEvent(event);
        }
        function validateDwellBaseEvent(event) {
            if (!event) throw new Error("Missing event");
            if (!event.source) throw new Error("Missing event.source");
            if (!event.actionSubject) throw new Error("Missing event.actionSubject");
        }
        function validateUIEvent(event) {
            validateActionEvent(event);
        }
        function validateOperationalEvent(event) {
            validateActionEvent(event);
        }
        function validateIdentifyEvent(userIdType, userId) {
            if (!userIdType) throw new Error("Missing userIdType");
            if (!userId) throw new Error("Missing userId");
            if (!(0, _analyticsWebTypes.isType)(_analyticsWebTypes.userType, userIdType)) throw new Error("Invalid userIdType '" + userIdType + "', must be an userType: [" + (0, 
            _analyticsWebTypes.objectValues)(_analyticsWebTypes.userType) + "]");
        }
        function validatePlatform(productInfo) {
            if (!(0, _analyticsWebTypes.isType)(_analyticsWebTypes.platformType, productInfo.platform)) throw new Error("Invalid productInfo.platform '" + productInfo.platform + "', must be a platformType: [" + (0, 
            _analyticsWebTypes.objectValues)(_analyticsWebTypes.platformType) + "]");
            if (productInfo.origin === _analyticsWebTypes.originType.DESKTOP && !(0, _analyticsWebTypes.isType)(_analyticsWebTypes.desktopPlatforms, productInfo.platform)) throw new Error("Invalid productInfo.platform '" + productInfo.platform + "', must be one of [mac, linux, windows]");
            if (productInfo.origin === _analyticsWebTypes.originType.WEB && !(0, _analyticsWebTypes.isType)(_analyticsWebTypes.webPlatforms, productInfo.platform)) throw new Error("Invalid productInfo.platform '" + productInfo.platform + "', must be one of [web, mobileWeb]");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _values = __webpack_require__(80), _values2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_values);
        exports.validateContainersObject = validateContainersObject, exports.validateContainers = validateContainers, 
        exports.validateScreenEvent = validateScreenEvent, exports.validateTrackEvent = validateTrackEvent, 
        exports.validateDwellBaseEvent = validateDwellBaseEvent, exports.validateUIEvent = validateUIEvent, 
        exports.validateOperationalEvent = validateOperationalEvent, exports.validateIdentifyEvent = validateIdentifyEvent, 
        exports.validatePlatform = validatePlatform;
        var _analyticsWebTypes = __webpack_require__(11), _objectUtils = __webpack_require__(132);
    }, /* 83 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = !__webpack_require__(8) && !__webpack_require__(18)(function() {
            return 7 != Object.defineProperty(__webpack_require__(84)("div"), "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 84 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14), document = __webpack_require__(6).document, is = isObject(document) && isObject(document.createElement);
        module.exports = function(it) {
            return is ? document.createElement(it) : {};
        };
    }, /* 85 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(12);
    }, /* 86 */
    /***/
    function(module, exports, __webpack_require__) {
        var has = __webpack_require__(19), toIObject = __webpack_require__(15), arrayIndexOf = __webpack_require__(141)(!1), IE_PROTO = __webpack_require__(58)("IE_PROTO");
        module.exports = function(object, names) {
            var key, O = toIObject(object), i = 0, result = [];
            for (key in O) key != IE_PROTO && has(O, key) && result.push(key);
            // Don't enum bug & hidden keys
            for (;names.length > i; ) has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
            return result;
        };
    }, /* 87 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __webpack_require__(19), toObject = __webpack_require__(31), IE_PROTO = __webpack_require__(58)("IE_PROTO"), ObjectProto = Object.prototype;
        module.exports = Object.getPrototypeOf || function(O) {
            return O = toObject(O), has(O, IE_PROTO) ? O[IE_PROTO] : "function" == typeof O.constructor && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectProto : null;
        };
    }, /* 88 */
    /***/
    function(module, exports) {
        module.exports = function(done, value) {
            return {
                value: value,
                done: !!done
            };
        };
    }, /* 89 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.2.2 IsArray(argument)
        var cof = __webpack_require__(56);
        module.exports = Array.isArray || function(arg) {
            return "Array" == cof(arg);
        };
    }, /* 90 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys = __webpack_require__(86), hiddenKeys = __webpack_require__(60).concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function(O) {
            return $keys(O, hiddenKeys);
        };
    }, /* 91 */
    /***/
    function(module, exports, __webpack_require__) {
        var pIE = __webpack_require__(32), createDesc = __webpack_require__(37), toIObject = __webpack_require__(15), toPrimitive = __webpack_require__(54), has = __webpack_require__(19), IE8_DOM_DEFINE = __webpack_require__(83), gOPD = Object.getOwnPropertyDescriptor;
        exports.f = __webpack_require__(8) ? gOPD : function(O, P) {
            if (O = toIObject(O), P = toPrimitive(P, !0), IE8_DOM_DEFINE) try {
                return gOPD(O, P);
            } catch (e) {}
            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
        };
    }, /* 92 */
    /***/
    function(module, exports) {}, /* 93 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Matcher, slightly modified from:
 *
 * https://github.com/csnover/js-iso8601/blob/lax/iso8601.js
 */
        var matcher = /^(\d{4})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:([ T])(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
        /**
 * Convert an ISO date string to a date. Fallback to native `Date.parse`.
 *
 * https://github.com/csnover/js-iso8601/blob/lax/iso8601.js
 *
 * @param {String} iso
 * @return {Date}
 */
        exports.parse = function(iso) {
            var numericKeys = [ 1, 5, 6, 7, 11, 12 ], arr = matcher.exec(iso), offset = 0;
            // fallback to native parsing
            if (!arr) return new Date(iso);
            /* eslint-disable no-cond-assign */
            // remove undefined values
            for (var val, i = 0; val = numericKeys[i]; i++) arr[val] = parseInt(arr[val], 10) || 0;
            /* eslint-enable no-cond-assign */
            // allow undefined days and months
            arr[2] = parseInt(arr[2], 10) || 1, arr[3] = parseInt(arr[3], 10) || 1, // month is 0-11
            arr[2]--, // allow abitrary sub-second precision
            arr[8] = arr[8] ? (arr[8] + "00").substring(0, 3) : 0, // apply timezone if one exists
            " " === arr[4] ? offset = new Date().getTimezoneOffset() : "Z" !== arr[9] && arr[10] && (offset = 60 * arr[11] + arr[12], 
            "+" === arr[10] && (offset = 0 - offset));
            var millis = Date.UTC(arr[1], arr[2], arr[3], arr[5], arr[6] + offset, arr[7], arr[8]);
            return new Date(millis);
        }, /**
 * Checks whether a `string` is an ISO date string. `strict` mode requires that
 * the date string at least have a year, month and date.
 *
 * @param {String} string
 * @param {Boolean} strict
 * @return {Boolean}
 */
        exports.is = function(string, strict) {
            return (!strict || !1 !== /^\d{4}-\d{2}-\d{2}/.test(string)) && matcher.test(string);
        };
    }, /* 94 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Traverse an object or array, and return a clone with all ISO strings parsed
 * into Date objects.
 *
 * @param {Object} obj
 * @return {Object}
 */
        function traverse(input, strict) {
            return void 0 === strict && (strict = !0), "object" === type(input) ? object(input, strict) : "array" === type(input) ? array(input, strict) : input;
        }
        /**
 * Object traverser.
 *
 * @param {Object} obj
 * @param {Boolean} strict
 * @return {Object}
 */
        function object(obj, strict) {
            return each(obj, function(key, val) {
                isodate.is(val, strict) ? obj[key] = isodate.parse(val) : "object" !== type(val) && "array" !== type(val) || traverse(val, strict);
            }), obj;
        }
        /**
 * Array traverser.
 *
 * @param {Array} arr
 * @param {Boolean} strict
 * @return {Array}
 */
        function array(arr, strict) {
            return each(arr, function(val, x) {
                "object" === type(val) ? traverse(val, strict) : isodate.is(val, strict) && (arr[x] = isodate.parse(val));
            }), arr;
        }
        var type = __webpack_require__(22), each = __webpack_require__(95), isodate = __webpack_require__(93);
        /**
 * Expose `traverse`.
 */
        module.exports = traverse;
    }, /* 95 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Iterate string chars.
 *
 * @param {String} obj
 * @param {Function} fn
 * @param {Object} ctx
 * @api private
 */
        function string(obj, fn, ctx) {
            for (var i = 0; i < obj.length; ++i) fn.call(ctx, obj.charAt(i), i);
        }
        /**
 * Iterate object keys.
 *
 * @param {Object} obj
 * @param {Function} fn
 * @param {Object} ctx
 * @api private
 */
        function object(obj, fn, ctx) {
            for (var key in obj) has.call(obj, key) && fn.call(ctx, key, obj[key]);
        }
        /**
 * Iterate array-ish.
 *
 * @param {Array|Object} obj
 * @param {Function} fn
 * @param {Object} ctx
 * @api private
 */
        function array(obj, fn, ctx) {
            for (var i = 0; i < obj.length; ++i) fn.call(ctx, obj[i], i);
        }
        /**
 * Module dependencies.
 */
        try {
            var type = __webpack_require__(96);
        } catch (err) {
            var type = __webpack_require__(96);
        }
        var toFunction = __webpack_require__(166), has = Object.prototype.hasOwnProperty;
        /**
 * Iterate the given `obj` and invoke `fn(val, i)`
 * in optional context `ctx`.
 *
 * @param {String|Array|Object} obj
 * @param {Function} fn
 * @param {Object} [ctx]
 * @api public
 */
        module.exports = function(obj, fn, ctx) {
            switch (fn = toFunction(fn), ctx = ctx || this, type(obj)) {
              case "array":
                return array(obj, fn, ctx);

              case "object":
                return "number" == typeof obj.length ? array(obj, fn, ctx) : object(obj, fn, ctx);

              case "string":
                return string(obj, fn, ctx);
            }
        };
    }, /* 96 */
    /***/
    function(module, exports) {
        /**
 * toString ref.
 */
        var toString = Object.prototype.toString;
        /**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */
        module.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Function]":
                return "function";

              case "[object Date]":
                return "date";

              case "[object RegExp]":
                return "regexp";

              case "[object Arguments]":
                return "arguments";

              case "[object Array]":
                return "array";

              case "[object String]":
                return "string";
            }
            return null === val ? "null" : void 0 === val ? "undefined" : val && 1 === val.nodeType ? "element" : val === Object(val) ? "object" : typeof val;
        };
    }, /* 97 */
    /***/
    function(module, exports) {
        /**
 * Return immediate identifiers in `str`.
 *
 * @param {String} str
 * @return {Array}
 * @api private
 */
        function props(str) {
            return str.replace(/\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^\/]+)\//g, "").replace(globals, "").match(/[a-zA-Z_]\w*/g) || [];
        }
        /**
 * Return `str` with `props` mapped with `fn`.
 *
 * @param {String} str
 * @param {Array} props
 * @param {Function} fn
 * @return {String}
 * @api private
 */
        function map(str, props, fn) {
            var re = /\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^\/]+)\/|[a-zA-Z_]\w*/g;
            return str.replace(re, function(_) {
                return "(" == _[_.length - 1] ? fn(_) : ~props.indexOf(_) ? fn(_) : _;
            });
        }
        /**
 * Return unique array.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */
        function unique(arr) {
            for (var ret = [], i = 0; i < arr.length; i++) ~ret.indexOf(arr[i]) || ret.push(arr[i]);
            return ret;
        }
        /**
 * Map with prefix `str`.
 */
        function prefixed(str) {
            return function(_) {
                return str + _;
            };
        }
        /**
 * Global Names
 */
        var globals = /\b(Array|Date|Object|Math|JSON)\b/g;
        /**
 * Return immediate identifiers parsed from `str`.
 *
 * @param {String} str
 * @param {String|Function} map function or prefix
 * @return {Array}
 * @api public
 */
        module.exports = function(str, fn) {
            var p = unique(props(str));
            return fn && "string" == typeof fn && (fn = prefixed(fn)), fn ? map(str, p, fn) : p;
        };
    }, /* 98 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Identify` facade with a `dictionary` of arguments.
 *
 * @param {Object} dictionary
 *   @param {string} userId
 *   @param {string} sessionId
 *   @param {Object} traits
 *   @param {Object} options
 * @param {Object} opts
 *   @property {boolean|undefined} clone
 */
        function Identify(dictionary, opts) {
            Facade.call(this, dictionary, opts);
        }
        var Facade = __webpack_require__(25), get = __webpack_require__(44), inherit = __webpack_require__(9).inherit, isEmail = __webpack_require__(46), newDate = __webpack_require__(67), trim = __webpack_require__(99), type = __webpack_require__(9).type;
        /**
 * Inherit from `Facade`.
 */
        inherit(Identify, Facade), /**
 * Get the facade's action.
 */
        Identify.prototype.action = function() {
            return "identify";
        }, Identify.prototype.type = Identify.prototype.action, /**
 * Get the user's traits.
 *
 * @param {Object} aliases
 * @return {Object}
 */
        Identify.prototype.traits = function(aliases) {
            var ret = this.field("traits") || {}, id = this.userId();
            aliases = aliases || {}, id && (ret.id = id);
            for (var alias in aliases) {
                var value = null == this[alias] ? this.proxy("traits." + alias) : this[alias]();
                null != value && (ret[aliases[alias]] = value, alias !== aliases[alias] && delete ret[alias]);
            }
            return ret;
        }, /**
 * Get the user's email, falling back to their user ID if it's a valid email.
 *
 * @return {string}
 */
        Identify.prototype.email = function() {
            var email = this.proxy("traits.email");
            if (email) return email;
            var userId = this.userId();
            return isEmail(userId) ? userId : void 0;
        }, /**
 * Get the user's created date, optionally looking for `createdAt` since lots of
 * people do that instead.
 *
 * @return {Date|undefined}
 */
        Identify.prototype.created = function() {
            var created = this.proxy("traits.created") || this.proxy("traits.createdAt");
            if (created) return newDate(created);
        }, /**
 * Get the company created date.
 *
 * @return {Date|undefined}
 */
        Identify.prototype.companyCreated = function() {
            var created = this.proxy("traits.company.created") || this.proxy("traits.company.createdAt");
            if (created) return newDate(created);
        }, /**
 * Get the user's name, optionally combining a first and last name if that's all
 * that was provided.
 *
 * @return {string|undefined}
 */
        Identify.prototype.name = function() {
            var name = this.proxy("traits.name");
            if ("string" == typeof name) return trim(name);
            var firstName = this.firstName(), lastName = this.lastName();
            return firstName && lastName ? trim(firstName + " " + lastName) : void 0;
        }, /**
 * Get the user's first name, optionally splitting it out of a single name if
 * that's all that was provided.
 *
 * @return {string|undefined}
 */
        Identify.prototype.firstName = function() {
            var firstName = this.proxy("traits.firstName");
            if ("string" == typeof firstName) return trim(firstName);
            var name = this.proxy("traits.name");
            return "string" == typeof name ? trim(name).split(" ")[0] : void 0;
        }, /**
 * Get the user's last name, optionally splitting it out of a single name if
 * that's all that was provided.
 *
 * @return {string|undefined}
 */
        Identify.prototype.lastName = function() {
            var lastName = this.proxy("traits.lastName");
            if ("string" == typeof lastName) return trim(lastName);
            var name = this.proxy("traits.name");
            if ("string" == typeof name) {
                var space = trim(name).indexOf(" ");
                if (-1 !== space) return trim(name.substr(space + 1));
            }
        }, /**
 * Get the user's unique id.
 *
 * @return {string|undefined}
 */
        Identify.prototype.uid = function() {
            return this.userId() || this.username() || this.email();
        }, /**
 * Get description.
 *
 * @return {string}
 */
        Identify.prototype.description = function() {
            return this.proxy("traits.description") || this.proxy("traits.background");
        }, /**
 * Get the age.
 *
 * If the age is not explicitly set
 * the method will compute it from `.birthday()`
 * if possible.
 *
 * @return {number}
 */
        Identify.prototype.age = function() {
            var date = this.birthday(), age = get(this.traits(), "age");
            if (null != age) return age;
            if ("date" === type(date)) {
                return new Date().getFullYear() - date.getFullYear();
            }
        }, /**
 * Get the avatar.
 *
 * .photoUrl needed because help-scout
 * implementation uses `.avatar || .photoUrl`.
 *
 * .avatarUrl needed because trakio uses it.
 *
 * @return {*}
 */
        Identify.prototype.avatar = function() {
            var traits = this.traits();
            return get(traits, "avatar") || get(traits, "photoUrl") || get(traits, "avatarUrl");
        }, /**
 * Get the position.
 *
 * .jobTitle needed because some integrations use it.
 *
 * @return {*}
 */
        Identify.prototype.position = function() {
            var traits = this.traits();
            return get(traits, "position") || get(traits, "jobTitle");
        }, /**
 * Setup sme basic "special" trait proxies.
 */
        Identify.prototype.username = Facade.proxy("traits.username"), Identify.prototype.website = Facade.one("traits.website"), 
        Identify.prototype.websites = Facade.multi("traits.website"), Identify.prototype.phone = Facade.one("traits.phone"), 
        Identify.prototype.phones = Facade.multi("traits.phone"), Identify.prototype.address = Facade.proxy("traits.address"), 
        Identify.prototype.gender = Facade.proxy("traits.gender"), Identify.prototype.birthday = Facade.proxy("traits.birthday"), 
        /**
 * Exports.
 */
        module.exports = Identify;
    }, /* 99 */
    /***/
    function(module, exports) {
        function trim(str) {
            return str.replace(/^\s*|\s*$/g, "");
        }
        exports = module.exports = trim, exports.left = function(str) {
            return str.replace(/^\s*/, "");
        }, exports.right = function(str) {
            return str.replace(/\s*$/, "");
        };
    }, /* 100 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize new `Page` facade with `dictionary`.
 *
 * @param {Object} dictionary
 *   @param {string} category
 *   @param {string} name
 *   @param {Object} traits
 *   @param {Object} options
 * @param {Object} opts
 *   @property {Boolean|Undefined} clone
 */
        function Page(dictionary, opts) {
            Facade.call(this, dictionary, opts);
        }
        var inherit = __webpack_require__(9).inherit, Facade = __webpack_require__(25), Track = __webpack_require__(68), isEmail = __webpack_require__(46);
        /**
 * Inherit from `Facade`
 */
        inherit(Page, Facade), /**
 * Get the facade's action.
 *
 * @return {string}
 */
        Page.prototype.action = function() {
            return "page";
        }, Page.prototype.type = Page.prototype.action, /**
 * Fields
 */
        Page.prototype.category = Facade.field("category"), Page.prototype.name = Facade.field("name"), 
        /**
 * Proxies.
 */
        Page.prototype.title = Facade.proxy("properties.title"), Page.prototype.path = Facade.proxy("properties.path"), 
        Page.prototype.url = Facade.proxy("properties.url"), /**
 * Referrer.
 */
        Page.prototype.referrer = function() {
            return this.proxy("context.referrer.url") || this.proxy("context.page.referrer") || this.proxy("properties.referrer");
        }, /**
 * Get the page properties mixing `category` and `name`.
 *
 * @param {Object} aliases
 * @return {Object}
 */
        Page.prototype.properties = function(aliases) {
            var props = this.field("properties") || {}, category = this.category(), name = this.name();
            aliases = aliases || {}, category && (props.category = category), name && (props.name = name);
            for (var alias in aliases) {
                var value = null == this[alias] ? this.proxy("properties." + alias) : this[alias]();
                null != value && (props[aliases[alias]] = value, alias !== aliases[alias] && delete props[alias]);
            }
            return props;
        }, /**
 * Get the user's email, falling back to their user ID if it's a valid email.
 *
 * @return {string}
 */
        Page.prototype.email = function() {
            var email = this.proxy("context.traits.email") || this.proxy("properties.email");
            if (email) return email;
            var userId = this.userId();
            return isEmail(userId) ? userId : void 0;
        }, /**
 * Get the page fullName.
 *
 * @return {string}
 */
        Page.prototype.fullName = function() {
            var category = this.category(), name = this.name();
            return name && category ? category + " " + name : name;
        }, /**
 * Get event with `name`.
 *
 * @return {string}
 */
        Page.prototype.event = function(name) {
            return name ? "Viewed " + name + " Page" : "Loaded a Page";
        }, /**
 * Convert this Page to a Track facade with `name`.
 *
 * @param {string} name
 * @return {Track}
 */
        Page.prototype.track = function(name) {
            var json = this.json();
            return json.event = this.event(name), json.timestamp = this.timestamp(), json.properties = this.properties(), 
            new Track(json, this.opts);
        }, /**
 * Exports.
 */
        module.exports = Page;
    }, /* 101 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // Chain is essentially a linked list of middlewares to run in order.
        function middlewareChain(dest) {
            var middlewares = [];
            // fn is the callback to be run once all middlewares have been applied.
            // Return a copy to prevent external mutations.
            return dest.getMiddlewares = function() {
                return middlewares.slice();
            }, dest.add = function(middleware) {
                if ("function" != typeof middleware) throw new Error("attempted to add non-function middleware");
                // Check for identical object references - bug check.
                if (-1 !== middlewares.indexOf(middleware)) throw new Error("middleware is already registered");
                middlewares.push(middleware);
            }, function(run, facade, callback) {
                if ("object" != typeof facade) throw new Error("applyMiddlewares requires a payload object");
                if ("function" != typeof callback) throw new Error("applyMiddlewares requires a function callback");
                // Attach callback to the end of the chain.
                var middlewaresToApply = middlewares.slice();
                middlewaresToApply.push(callback), executeChain(run, facade, middlewaresToApply, 0);
            };
        }
        // Go over all middlewares until all have been applied.
        function executeChain(run, payload, middlewares, index) {
            // If the facade has been nullified, immediately skip to the final middleware.
            if (null === payload) return void middlewares[middlewares.length - 1](null);
            // Check if the payload is still a Facade. If not, convert it to one.
            payload instanceof Facade || (payload = new Facade(payload));
            var mw = middlewares[index];
            mw && (// If there's another middleware, continue down the chain. Otherwise, call the final function.
            middlewares[index + 1] ? run(mw, payload, function(result) {
                executeChain(run, result, middlewares, ++index);
            }) : mw(payload));
        }
        var Facade = __webpack_require__(21);
        module.exports.SourceMiddlewareChain = function() {
            var apply = middlewareChain(this);
            this.applyMiddlewares = function(facade, integrations, callback) {
                return apply(function(mw, payload, next) {
                    mw({
                        integrations: integrations,
                        next: next,
                        payload: payload
                    });
                }, facade, callback);
            };
        }, module.exports.IntegrationMiddlewareChain = function() {
            var apply = middlewareChain(this);
            this.applyMiddlewares = function(facade, integration, callback) {
                return apply(function(mw, payload, next) {
                    mw(payload, integration, next);
                }, facade, callback);
            };
        }, module.exports.middlewareChain = middlewareChain;
    }, /* 102 */
    /***/
    function(module, exports) {
        /**
 * Slice reference.
 */
        var slice = [].slice;
        /**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */
        module.exports = function(obj, fn) {
            if ("string" == typeof fn && (fn = obj[fn]), "function" != typeof fn) throw new Error("bind() requires a function");
            var args = slice.call(arguments, 2);
            return function() {
                return fn.apply(obj, args.concat(slice.call(arguments)));
            };
        };
    }, /* 103 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Get the top domain.
 *
 * The function constructs the levels of domain and attempts to set a global
 * cookie on each one when it succeeds it returns the top level domain.
 *
 * The method returns an empty string when the hostname is an ip or `localhost`.
 *
 * Example levels:
 *
 *      domain.levels('http://www.google.co.uk');
 *      // => ["co.uk", "google.co.uk", "www.google.co.uk"]
 *
 * Example:
 *
 *      domain('http://localhost:3000/baz');
 *      // => ''
 *      domain('http://dev:3000/baz');
 *      // => ''
 *      domain('http://127.0.0.1:3000/baz');
 *      // => ''
 *      domain('http://segment.io/baz');
 *      // => 'segment.io'
 *
 * @param {string} url
 * @return {string}
 * @api public
 */
        function domain(url) {
            // Lookup the real top level one.
            for (var cookie = exports.cookie, levels = exports.levels(url), i = 0; i < levels.length; ++i) {
                var domain = levels[i], opts = {
                    domain: "." + domain
                };
                if (cookie("__tld__", 1, opts), cookie("__tld__")) return cookie("__tld__", null, opts), 
                domain;
            }
            return "";
        }
        /**
 * Module dependencies.
 */
        var parse = __webpack_require__(104).parse, cookie = __webpack_require__(49);
        /**
 * Levels returns all levels of the given url.
 *
 * @param {string} url
 * @return {Array}
 * @api public
 */
        domain.levels = function(url) {
            var host = parse(url).hostname, parts = host.split("."), last = parts[parts.length - 1], levels = [];
            // Ip address.
            if (4 === parts.length && last === parseInt(last, 10)) return levels;
            // Localhost.
            if (parts.length <= 1) return levels;
            // Create levels.
            for (var i = parts.length - 2; i >= 0; --i) levels.push(parts.slice(i).join("."));
            return levels;
        }, /**
 * Expose cookie on domain.
 */
        domain.cookie = cookie, /*
 * Exports.
 */
        exports = module.exports = domain;
    }, /* 104 */
    /***/
    function(module, exports) {
        /**
 * Return default port for `protocol`.
 *
 * @param  {String} protocol
 * @return {String}
 * @api private
 */
        function port(protocol) {
            switch (protocol) {
              case "http:":
                return 80;

              case "https:":
                return 443;

              default:
                return location.port;
            }
        }
        /**
 * Parse the given `url`.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */
        exports.parse = function(url) {
            var a = document.createElement("a");
            return a.href = url, {
                href: a.href,
                host: a.host || location.host,
                port: "0" === a.port || "" === a.port ? port(a.protocol) : a.port,
                hash: a.hash,
                hostname: a.hostname || location.hostname,
                pathname: "/" != a.pathname.charAt(0) ? "/" + a.pathname : a.pathname,
                protocol: a.protocol && ":" != a.protocol ? a.protocol : location.protocol,
                search: a.search,
                query: a.search.slice(1)
            };
        }, /**
 * Check if `url` is absolute.
 *
 * @param {String} url
 * @return {Boolean}
 * @api public
 */
        exports.isAbsolute = function(url) {
            return 0 == url.indexOf("//") || !!~url.indexOf("://");
        }, /**
 * Check if `url` is relative.
 *
 * @param {String} url
 * @return {Boolean}
 * @api public
 */
        exports.isRelative = function(url) {
            return !exports.isAbsolute(url);
        }, /**
 * Check if `url` is cross domain.
 *
 * @param {String} url
 * @return {Boolean}
 * @api public
 */
        exports.isCrossDomain = function(url) {
            url = exports.parse(url);
            var location = exports.parse(window.location.href);
            return url.hostname !== location.hostname || url.port !== location.port || url.protocol !== location.protocol;
        };
    }, /* 105 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Send the given `obj` to `url` with `fn(err, req)`.
 *
 * @param {String} url
 * @param {Object} obj
 * @param {Object} headers
 * @param {Function} fn
 * @api private
 */
        function json(url, obj, headers, fn) {
            function done() {
                if (4 === req.readyState) return fn(null, req);
            }
            3 === arguments.length && (fn = headers, headers = {});
            var req = new XMLHttpRequest();
            req.onerror = fn, req.onreadystatechange = done, req.open("POST", url, !0);
            // TODO: Remove this eslint disable
            // eslint-disable-next-line guard-for-in
            for (var k in headers) req.setRequestHeader(k, headers[k]);
            req.send(JSON.stringify(obj));
        }
        /**
 * Send the given `obj` to `url` with `fn(err, req)`.
 *
 * @param {String} url
 * @param {Object} obj
 * @param {Function} fn
 * @api private
 */
        function base64(url, obj, _, fn) {
            3 === arguments.length && (fn = _);
            var prefix = exports.prefix, data = encode(obj);
            url += "?" + prefix + "=" + data, jsonp(url, {
                param: exports.callback
            }, function(err, obj) {
                if (err) return fn(err);
                fn(null, {
                    url: url,
                    body: obj
                });
            });
        }
        /**
 * Encodes `obj`.
 *
 * @param {Object} obj
 */
        function encode(obj) {
            var str = "";
            return str = JSON.stringify(obj), str = base64encode(str), str = str.replace(/\+/g, "-").replace(/\//g, "_"), 
            encodeURIComponent(str);
        }
        /*
 * Module dependencies.
 */
        var JSON = __webpack_require__(28), base64encode = __webpack_require__(178), cors = __webpack_require__(180), jsonp = __webpack_require__(181);
        /*
 * Exports.
 */
        exports = module.exports = cors ? json : base64, /**
 * Expose `callback`
 */
        exports.callback = "callback", /**
 * Expose `prefix`
 */
        exports.prefix = "data", /**
 * Expose `json`.
 */
        exports.json = json, /**
 * Expose `base64`.
 */
        exports.base64 = base64, /**
 * Expose `type`
 */
        exports.type = cors ? "xhr" : "jsonp";
    }, /* 106 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize new `Entity` with `options`.
 *
 * @param {Object} options
 */
        function Entity(options) {
            this.options(options), this.initialize();
        }
        /*
 * Module dependencies.
 */
        var clone = __webpack_require__(26), cookie = __webpack_require__(48), debug = __webpack_require__(4)("analytics:entity"), defaults = __webpack_require__(27), extend = __webpack_require__(71), memory = __webpack_require__(107), store = __webpack_require__(72), isodateTraverse = __webpack_require__(94);
        /**
 * Expose `Entity`
 */
        module.exports = Entity, /**
 * Initialize picks the storage.
 *
 * Checks to see if cookies can be set
 * otherwise fallsback to localStorage.
 */
        Entity.prototype.initialize = function() {
            // cookies are enabled.
            // cookies are enabled.
            // localStorage is enabled.
            // fallback to memory storage.
            return cookie.set("ajs:cookies", !0), cookie.get("ajs:cookies") ? (cookie.remove("ajs:cookies"), 
            void (this._storage = cookie)) : store.enabled ? void (this._storage = store) : (debug("warning using memory store both cookies and localStorage are disabled"), 
            void (this._storage = memory));
        }, /**
 * Get the storage.
 */
        Entity.prototype.storage = function() {
            return this._storage;
        }, /**
 * Get or set storage `options`.
 *
 * @param {Object} options
 *   @property {Object} cookie
 *   @property {Object} localStorage
 *   @property {Boolean} persist (default: `true`)
 */
        Entity.prototype.options = function(options) {
            if (0 === arguments.length) return this._options;
            this._options = defaults(options || {}, this.defaults || {});
        }, /**
 * Get or set the entity's `id`.
 *
 * @param {String} id
 */
        Entity.prototype.id = function(id) {
            switch (arguments.length) {
              case 0:
                return this._getId();

              case 1:
                return this._setId(id);
            }
        }, /**
 * Get the entity's id.
 *
 * @return {String}
 */
        Entity.prototype._getId = function() {
            if (!this._options.persist) return void 0 === this._id ? null : this._id;
            // Check cookies.
            var cookieId = this._getIdFromCookie();
            if (cookieId) return cookieId;
            // Check localStorage.
            var lsId = this._getIdFromLocalStorage();
            // Copy the id to cookies so we can read it directly from cookies next time.
            return lsId ? (this._setIdInCookies(lsId), lsId) : null;
        }, /**
 * Get the entity's id from cookies.
 *
 * @return {String}
 */
        Entity.prototype._getIdFromCookie = function() {
            return this.storage().get(this._options.cookie.key);
        }, /**
 * Get the entity's id from cookies.
 *
 * @return {String}
 */
        Entity.prototype._getIdFromLocalStorage = function() {
            return this._options.localStorageFallbackDisabled ? null : store.get(this._options.cookie.key);
        }, /**
 * Set the entity's `id`.
 *
 * @param {String} id
 */
        Entity.prototype._setId = function(id) {
            this._options.persist ? (this._setIdInCookies(id), this._setIdInLocalStorage(id)) : this._id = id;
        }, /**
 * Set the entity's `id` in cookies.
 *
 * @param {String} id
 */
        Entity.prototype._setIdInCookies = function(id) {
            this.storage().set(this._options.cookie.key, id);
        }, /**
 * Set the entity's `id` in local storage.
 *
 * @param {String} id
 */
        Entity.prototype._setIdInLocalStorage = function(id) {
            this._options.localStorageFallbackDisabled || store.set(this._options.cookie.key, id);
        }, /**
 * Get or set the entity's `traits`.
 *
 * BACKWARDS COMPATIBILITY: aliased to `properties`
 *
 * @param {Object} traits
 */
        Entity.prototype.properties = Entity.prototype.traits = function(traits) {
            switch (arguments.length) {
              case 0:
                return this._getTraits();

              case 1:
                return this._setTraits(traits);
            }
        }, /**
 * Get the entity's traits. Always convert ISO date strings into real dates,
 * since they aren't parsed back from local storage.
 *
 * @return {Object}
 */
        Entity.prototype._getTraits = function() {
            var ret = this._options.persist ? store.get(this._options.localStorage.key) : this._traits;
            return ret ? isodateTraverse(clone(ret)) : {};
        }, /**
 * Set the entity's `traits`.
 *
 * @param {Object} traits
 */
        Entity.prototype._setTraits = function(traits) {
            traits = traits || {}, this._options.persist ? store.set(this._options.localStorage.key, traits) : this._traits = traits;
        }, /**
 * Identify the entity with an `id` and `traits`. If we it's the same entity,
 * extend the existing `traits` instead of overwriting.
 *
 * @param {String} id
 * @param {Object} traits
 */
        Entity.prototype.identify = function(id, traits) {
            traits = traits || {};
            var current = this.id();
            null !== current && current !== id || (traits = extend(this.traits(), traits)), 
            id && this.id(id), this.debug("identify %o, %o", id, traits), this.traits(traits), 
            this.save();
        }, /**
 * Save the entity to local storage and the cookie.
 *
 * @return {Boolean}
 */
        Entity.prototype.save = function() {
            return !!this._options.persist && (this._setId(this.id()), this._setTraits(this.traits()), 
            !0);
        }, /**
 * Log the entity out, reseting `id` and `traits` to defaults.
 */
        Entity.prototype.logout = function() {
            this.id(null), this.traits({}), this.storage().remove(this._options.cookie.key), 
            store.remove(this._options.cookie.key), store.remove(this._options.localStorage.key);
        }, /**
 * Reset all entity state, logging out and returning options to defaults.
 */
        Entity.prototype.reset = function() {
            this.logout(), this.options({});
        }, /**
 * Load saved entity `id` or `traits` from storage.
 */
        Entity.prototype.load = function() {
            this.id(this.id()), this.traits(this.traits());
        };
    }, /* 107 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize `Memory` store
 */
        function Memory() {
            this.store = {};
        }
        /*
 * Module Dependencies.
 */
        var bindAll = __webpack_require__(23), clone = __webpack_require__(26), has = Object.prototype.hasOwnProperty;
        /**
 * Expose `Memory`
 */
        module.exports = bindAll(new Memory()), /**
 * Set a `key` and `value`.
 *
 * @param {String} key
 * @param {Mixed} value
 * @return {Boolean}
 */
        Memory.prototype.set = function(key, value) {
            return this.store[key] = clone(value), !0;
        }, /**
 * Get a `key`.
 *
 * @param {String} key
 */
        Memory.prototype.get = function(key) {
            if (has.call(this.store, key)) return clone(this.store[key]);
        }, /**
 * Remove a `key`.
 *
 * @param {String} key
 * @return {Boolean}
 */
        Memory.prototype.remove = function(key) {
            return delete this.store[key], !0;
        };
    }, /* 108 */
    /***/
    function(module, exports, __webpack_require__) {
        !function(factory) {
            // Node/CommonJS
            module.exports = factory();
        }(function(undefined) {
            "use strict";
            function cmn(q, a, b, x, s, t) {
                return a = add32(add32(a, q), add32(x, t)), add32(a << s | a >>> 32 - s, b);
            }
            function ff(a, b, c, d, x, s, t) {
                return cmn(b & c | ~b & d, a, b, x, s, t);
            }
            function gg(a, b, c, d, x, s, t) {
                return cmn(b & d | c & ~d, a, b, x, s, t);
            }
            function hh(a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            }
            function ii(a, b, c, d, x, s, t) {
                return cmn(c ^ (b | ~d), a, b, x, s, t);
            }
            function md5cycle(x, k) {
                var a = x[0], b = x[1], c = x[2], d = x[3];
                a = ff(a, b, c, d, k[0], 7, -680876936), d = ff(d, a, b, c, k[1], 12, -389564586), 
                c = ff(c, d, a, b, k[2], 17, 606105819), b = ff(b, c, d, a, k[3], 22, -1044525330), 
                a = ff(a, b, c, d, k[4], 7, -176418897), d = ff(d, a, b, c, k[5], 12, 1200080426), 
                c = ff(c, d, a, b, k[6], 17, -1473231341), b = ff(b, c, d, a, k[7], 22, -45705983), 
                a = ff(a, b, c, d, k[8], 7, 1770035416), d = ff(d, a, b, c, k[9], 12, -1958414417), 
                c = ff(c, d, a, b, k[10], 17, -42063), b = ff(b, c, d, a, k[11], 22, -1990404162), 
                a = ff(a, b, c, d, k[12], 7, 1804603682), d = ff(d, a, b, c, k[13], 12, -40341101), 
                c = ff(c, d, a, b, k[14], 17, -1502002290), b = ff(b, c, d, a, k[15], 22, 1236535329), 
                a = gg(a, b, c, d, k[1], 5, -165796510), d = gg(d, a, b, c, k[6], 9, -1069501632), 
                c = gg(c, d, a, b, k[11], 14, 643717713), b = gg(b, c, d, a, k[0], 20, -373897302), 
                a = gg(a, b, c, d, k[5], 5, -701558691), d = gg(d, a, b, c, k[10], 9, 38016083), 
                c = gg(c, d, a, b, k[15], 14, -660478335), b = gg(b, c, d, a, k[4], 20, -405537848), 
                a = gg(a, b, c, d, k[9], 5, 568446438), d = gg(d, a, b, c, k[14], 9, -1019803690), 
                c = gg(c, d, a, b, k[3], 14, -187363961), b = gg(b, c, d, a, k[8], 20, 1163531501), 
                a = gg(a, b, c, d, k[13], 5, -1444681467), d = gg(d, a, b, c, k[2], 9, -51403784), 
                c = gg(c, d, a, b, k[7], 14, 1735328473), b = gg(b, c, d, a, k[12], 20, -1926607734), 
                a = hh(a, b, c, d, k[5], 4, -378558), d = hh(d, a, b, c, k[8], 11, -2022574463), 
                c = hh(c, d, a, b, k[11], 16, 1839030562), b = hh(b, c, d, a, k[14], 23, -35309556), 
                a = hh(a, b, c, d, k[1], 4, -1530992060), d = hh(d, a, b, c, k[4], 11, 1272893353), 
                c = hh(c, d, a, b, k[7], 16, -155497632), b = hh(b, c, d, a, k[10], 23, -1094730640), 
                a = hh(a, b, c, d, k[13], 4, 681279174), d = hh(d, a, b, c, k[0], 11, -358537222), 
                c = hh(c, d, a, b, k[3], 16, -722521979), b = hh(b, c, d, a, k[6], 23, 76029189), 
                a = hh(a, b, c, d, k[9], 4, -640364487), d = hh(d, a, b, c, k[12], 11, -421815835), 
                c = hh(c, d, a, b, k[15], 16, 530742520), b = hh(b, c, d, a, k[2], 23, -995338651), 
                a = ii(a, b, c, d, k[0], 6, -198630844), d = ii(d, a, b, c, k[7], 10, 1126891415), 
                c = ii(c, d, a, b, k[14], 15, -1416354905), b = ii(b, c, d, a, k[5], 21, -57434055), 
                a = ii(a, b, c, d, k[12], 6, 1700485571), d = ii(d, a, b, c, k[3], 10, -1894986606), 
                c = ii(c, d, a, b, k[10], 15, -1051523), b = ii(b, c, d, a, k[1], 21, -2054922799), 
                a = ii(a, b, c, d, k[8], 6, 1873313359), d = ii(d, a, b, c, k[15], 10, -30611744), 
                c = ii(c, d, a, b, k[6], 15, -1560198380), b = ii(b, c, d, a, k[13], 21, 1309151649), 
                a = ii(a, b, c, d, k[4], 6, -145523070), d = ii(d, a, b, c, k[11], 10, -1120210379), 
                c = ii(c, d, a, b, k[2], 15, 718787259), b = ii(b, c, d, a, k[9], 21, -343485551), 
                x[0] = add32(a, x[0]), x[1] = add32(b, x[1]), x[2] = add32(c, x[2]), x[3] = add32(d, x[3]);
            }
            function md5blk(s) {
                var i, md5blks = [];
                /* Andy King said do it this way. */
                for (i = 0; i < 64; i += 4) md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                return md5blks;
            }
            function md5blk_array(a) {
                var i, md5blks = [];
                /* Andy King said do it this way. */
                for (i = 0; i < 64; i += 4) md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
                return md5blks;
            }
            function md51(s) {
                var i, length, tail, tmp, lo, hi, n = s.length, state = [ 1732584193, -271733879, -1732584194, 271733878 ];
                for (i = 64; i <= n; i += 64) md5cycle(state, md5blk(s.substring(i - 64, i)));
                for (s = s.substring(i - 64), length = s.length, tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
                i = 0; i < length; i += 1) tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
                if (tail[i >> 2] |= 128 << (i % 4 << 3), i > 55) for (md5cycle(state, tail), i = 0; i < 16; i += 1) tail[i] = 0;
                // Beware that the final length might not fit in 32 bits so we take care of that
                return tmp = 8 * n, tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/), lo = parseInt(tmp[2], 16), 
                hi = parseInt(tmp[1], 16) || 0, tail[14] = lo, tail[15] = hi, md5cycle(state, tail), 
                state;
            }
            function md51_array(a) {
                var i, length, tail, tmp, lo, hi, n = a.length, state = [ 1732584193, -271733879, -1732584194, 271733878 ];
                for (i = 64; i <= n; i += 64) md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
                for (// Not sure if it is a bug, however IE10 will always produce a sub array of length 1
                // containing the last element of the parent array if the sub array specified starts
                // beyond the length of the parent array - weird.
                // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
                a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0), length = a.length, tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
                i = 0; i < length; i += 1) tail[i >> 2] |= a[i] << (i % 4 << 3);
                if (tail[i >> 2] |= 128 << (i % 4 << 3), i > 55) for (md5cycle(state, tail), i = 0; i < 16; i += 1) tail[i] = 0;
                // Beware that the final length might not fit in 32 bits so we take care of that
                return tmp = 8 * n, tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/), lo = parseInt(tmp[2], 16), 
                hi = parseInt(tmp[1], 16) || 0, tail[14] = lo, tail[15] = hi, md5cycle(state, tail), 
                state;
            }
            function rhex(n) {
                var j, s = "";
                for (j = 0; j < 4; j += 1) s += hex_chr[n >> 8 * j + 4 & 15] + hex_chr[n >> 8 * j & 15];
                return s;
            }
            function hex(x) {
                var i;
                for (i = 0; i < x.length; i += 1) x[i] = rhex(x[i]);
                return x.join("");
            }
            // ---------------------------------------------------
            /**
     * Helpers.
     */
            function toUtf8(str) {
                return /[\u0080-\uFFFF]/.test(str) && (str = unescape(encodeURIComponent(str))), 
                str;
            }
            function utf8Str2ArrayBuffer(str, returnUInt8Array) {
                var i, length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff);
                for (i = 0; i < length; i += 1) arr[i] = str.charCodeAt(i);
                return returnUInt8Array ? arr : buff;
            }
            function arrayBuffer2Utf8Str(buff) {
                return String.fromCharCode.apply(null, new Uint8Array(buff));
            }
            function concatenateArrayBuffers(first, second, returnUInt8Array) {
                var result = new Uint8Array(first.byteLength + second.byteLength);
                return result.set(new Uint8Array(first)), result.set(new Uint8Array(second), first.byteLength), 
                returnUInt8Array ? result : result.buffer;
            }
            function hexToBinaryString(hex) {
                var x, bytes = [], length = hex.length;
                for (x = 0; x < length - 1; x += 2) bytes.push(parseInt(hex.substr(x, 2), 16));
                return String.fromCharCode.apply(String, bytes);
            }
            // ---------------------------------------------------
            /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */
            function SparkMD5() {
                // call reset to init the instance
                this.reset();
            }
            /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */
            /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
            var add32 = function(a, b) {
                return a + b & 4294967295;
            }, hex_chr = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" ];
            // In some cases the fast add32 function cannot be used..
            // ---------------------------------------------------
            /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */
            /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
            /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
            /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
            /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
            /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
            /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
            /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
            /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
            /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
            /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
            // ---------------------------------------------------
            /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
            /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
            /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
            /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
            /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
            /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
            /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
            return "5d41402abc4b2a76b9719d911017c592" !== hex(md51("hello")) && (add32 = function(x, y) {
                var lsw = (65535 & x) + (65535 & y);
                return (x >> 16) + (y >> 16) + (lsw >> 16) << 16 | 65535 & lsw;
            }), "undefined" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || function() {
                function clamp(val, length) {
                    return val = 0 | val || 0, val < 0 ? Math.max(val + length, 0) : Math.min(val, length);
                }
                ArrayBuffer.prototype.slice = function(from, to) {
                    var num, target, targetArray, sourceArray, length = this.byteLength, begin = clamp(from, length), end = length;
                    return to !== undefined && (end = clamp(to, length)), begin > end ? new ArrayBuffer(0) : (num = end - begin, 
                    target = new ArrayBuffer(num), targetArray = new Uint8Array(target), sourceArray = new Uint8Array(this, begin, num), 
                    targetArray.set(sourceArray), target);
                };
            }(), SparkMD5.prototype.append = function(str) {
                // Converts the string to utf8 bytes if necessary
                // Then append as binary
                return this.appendBinary(toUtf8(str)), this;
            }, SparkMD5.prototype.appendBinary = function(contents) {
                this._buff += contents, this._length += contents.length;
                var i, length = this._buff.length;
                for (i = 64; i <= length; i += 64) md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
                return this._buff = this._buff.substring(i - 64), this;
            }, SparkMD5.prototype.end = function(raw) {
                var i, ret, buff = this._buff, length = buff.length, tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                for (i = 0; i < length; i += 1) tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
                return this._finish(tail, length), ret = hex(this._hash), raw && (ret = hexToBinaryString(ret)), 
                this.reset(), ret;
            }, SparkMD5.prototype.reset = function() {
                return this._buff = "", this._length = 0, this._hash = [ 1732584193, -271733879, -1732584194, 271733878 ], 
                this;
            }, SparkMD5.prototype.getState = function() {
                return {
                    buff: this._buff,
                    length: this._length,
                    hash: this._hash
                };
            }, SparkMD5.prototype.setState = function(state) {
                return this._buff = state.buff, this._length = state.length, this._hash = state.hash, 
                this;
            }, SparkMD5.prototype.destroy = function() {
                delete this._hash, delete this._buff, delete this._length;
            }, SparkMD5.prototype._finish = function(tail, length) {
                var tmp, lo, hi, i = length;
                if (tail[i >> 2] |= 128 << (i % 4 << 3), i > 55) for (md5cycle(this._hash, tail), 
                i = 0; i < 16; i += 1) tail[i] = 0;
                // Do the final computation based on the tail and length
                // Beware that the final length may not fit in 32 bits so we take care of that
                tmp = 8 * this._length, tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/), lo = parseInt(tmp[2], 16), 
                hi = parseInt(tmp[1], 16) || 0, tail[14] = lo, tail[15] = hi, md5cycle(this._hash, tail);
            }, SparkMD5.hash = function(str, raw) {
                // Converts the string to utf8 bytes if necessary
                // Then compute it using the binary function
                return SparkMD5.hashBinary(toUtf8(str), raw);
            }, SparkMD5.hashBinary = function(content, raw) {
                var hash = md51(content), ret = hex(hash);
                return raw ? hexToBinaryString(ret) : ret;
            }, SparkMD5.ArrayBuffer = function() {
                // call reset to init the instance
                this.reset();
            }, SparkMD5.ArrayBuffer.prototype.append = function(arr) {
                var i, buff = concatenateArrayBuffers(this._buff.buffer, arr, !0), length = buff.length;
                for (this._length += arr.byteLength, i = 64; i <= length; i += 64) md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
                return this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0), 
                this;
            }, SparkMD5.ArrayBuffer.prototype.end = function(raw) {
                var i, ret, buff = this._buff, length = buff.length, tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                for (i = 0; i < length; i += 1) tail[i >> 2] |= buff[i] << (i % 4 << 3);
                return this._finish(tail, length), ret = hex(this._hash), raw && (ret = hexToBinaryString(ret)), 
                this.reset(), ret;
            }, SparkMD5.ArrayBuffer.prototype.reset = function() {
                return this._buff = new Uint8Array(0), this._length = 0, this._hash = [ 1732584193, -271733879, -1732584194, 271733878 ], 
                this;
            }, SparkMD5.ArrayBuffer.prototype.getState = function() {
                var state = SparkMD5.prototype.getState.call(this);
                // Convert buffer to a string
                return state.buff = arrayBuffer2Utf8Str(state.buff), state;
            }, SparkMD5.ArrayBuffer.prototype.setState = function(state) {
                // Convert string to buffer
                return state.buff = utf8Str2ArrayBuffer(state.buff, !0), SparkMD5.prototype.setState.call(this, state);
            }, SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy, SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish, 
            SparkMD5.ArrayBuffer.hash = function(arr, raw) {
                var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
                return raw ? hexToBinaryString(ret) : ret;
            }, SparkMD5;
        });
    }, /* 109 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(76), ITERATOR = __webpack_require__(2)("iterator"), Iterators = __webpack_require__(24);
        module.exports = __webpack_require__(0).getIteratorMethod = function(it) {
            if (void 0 != it) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
        };
    }, /* 110 */
    /***/
    function(module, exports, __webpack_require__) {
        var getKeys = __webpack_require__(20), toIObject = __webpack_require__(15), isEnum = __webpack_require__(32).f;
        module.exports = function(isEntries) {
            return function(it) {
                for (var key, O = toIObject(it), keys = getKeys(O), length = keys.length, i = 0, result = []; length > i; ) isEnum.call(O, key = keys[i++]) && result.push(isEntries ? [ key, O[key] ] : O[key]);
                return result;
            };
        };
    }, /* 111 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Create a new `Integration` constructor.
 *
 * @constructs Integration
 * @param {string} name
 * @return {Function} Integration
 */
        function createIntegration(name) {
            /**
   * Initialize a new `Integration`.
   *
   * @class
   * @param {Object} options
   */
            function Integration(options) {
                if (options && options.addIntegration) // plugin
                return options.addIntegration(Integration);
                this.debug = debug("analytics:integration:" + slug(name)), this.options = defaults(clone(options) || {}, this.defaults), 
                this._queue = [], this.once("ready", bind(this, this.flush)), Integration.emit("construct", this), 
                this.ready = bind(this, this.ready), this._wrapInitialize(), this._wrapPage(), this._wrapTrack();
            }
            return Integration.prototype.defaults = {}, Integration.prototype.globals = [], 
            Integration.prototype.templates = {}, Integration.prototype.name = name, extend(Integration, statics), 
            extend(Integration.prototype, protos), Integration;
        }
        /**
 * Module dependencies.
 */
        var bind = __webpack_require__(102), clone = __webpack_require__(26), debug = __webpack_require__(4), defaults = __webpack_require__(27), extend = __webpack_require__(71), slug = __webpack_require__(211), protos = __webpack_require__(212), statics = __webpack_require__(221);
        /**
 * Exports.
 */
        module.exports = createIntegration;
    }, /* 112 */
    /***/
    function(module, exports) {
        /**
 * Add event listener to `el`, `fn()`.
 *
 * @param {Element} el
 * @param {Function} fn
 * @api private
 */
        function add(el, fn) {
            el.addEventListener("load", function(_, e) {
                fn(null, e);
            }, !1), el.addEventListener("error", function(e) {
                var err = new Error('script error "' + el.src + '"');
                err.event = e, fn(err);
            }, !1);
        }
        /**
 * Attach event.
 *
 * @param {Element} el
 * @param {Function} fn
 * @api private
 */
        function attach(el, fn) {
            el.attachEvent("onreadystatechange", function(e) {
                /complete|loaded/.test(el.readyState) && fn(null, e);
            }), el.attachEvent("onerror", function(e) {
                var err = new Error('failed to load the script "' + el.src + '"');
                err.event = e || window.event, fn(err);
            });
        }
        // https://github.com/thirdpartyjs/thirdpartyjs-code/blob/master/examples/templates/02/loading-files/index.html
        /**
 * Invoke `fn(err)` when the given `el` script loads.
 *
 * @param {Element} el
 * @param {Function} fn
 * @api public
 */
        module.exports = function(el, fn) {
            return el.addEventListener ? add(el, fn) : attach(el, fn);
        };
    }, /* 113 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // Some browsers don't support Function.prototype.bind, so just including a simplified version here
        function bind(func, obj) {
            return function() {
                return func.apply(obj, arguments);
            };
        }
        /**
 * @callback processFunc
 * @param {Mixed} item The item added to the queue to process
 * @param {Function} done A function to call when processing is completed.
 *   @param {Error} Optional error parameter if the processing failed
 *   @param {Response} Optional response parameter to emit for async handling
 */
        /**
 * Constructs a Queue backed by localStorage
 *
 * @constructor
 * @param {String} name The name of the queue. Will be used to find abandoned queues and retry their items
 * @param {processFunc} fn The function to call in order to process an item added to the queue
 */
        function Queue(name, opts, fn) {
            "function" == typeof opts && (fn = opts), this.name = name, this.id = uuid(), this.fn = fn, 
            this.maxItems = opts.maxItems || 1 / 0, this.maxAttempts = opts.maxAttempts || 1 / 0, 
            this.backoff = {
                MIN_RETRY_DELAY: opts.minRetryDelay || 1e3,
                MAX_RETRY_DELAY: opts.maxRetryDelay || 3e4,
                FACTOR: opts.backoffFactor || 2,
                JITTER: opts.backoffJitter || 0
            }, // painstakingly tuned. that's why they're not "easily" configurable
            this.timeouts = {
                ACK_TIMER: 1e3,
                RECLAIM_TIMER: 3e3,
                RECLAIM_TIMEOUT: 1e4,
                RECLAIM_WAIT: 500
            }, this.keys = {
                IN_PROGRESS: "inProgress",
                QUEUE: "queue",
                ACK: "ack",
                RECLAIM_START: "reclaimStart",
                RECLAIM_END: "reclaimEnd"
            }, this._schedule = new Schedule(), this._processId = 0, // Set up our empty queues
            this._store = new Store(this.name, this.id, this.keys), this._store.set(this.keys.IN_PROGRESS, {}), 
            this._store.set(this.keys.QUEUE, []), // bind recurring tasks for ease of use
            this._ack = bind(this._ack, this), this._checkReclaim = bind(this._checkReclaim, this), 
            this._processHead = bind(this._processHead, this), this._running = !1;
        }
        var uuid = __webpack_require__(114).v4, Store = __webpack_require__(229), each = __webpack_require__(5), Schedule = __webpack_require__(230), debug = __webpack_require__(4)("localstorage-retry");
        /**
 * Mix in event emitter
 */
        __webpack_require__(47)(Queue.prototype), /**
 * Starts processing the queue
 */
        Queue.prototype.start = function() {
            this._running && this.stop(), this._running = !0, this._ack(), this._checkReclaim(), 
            this._processHead();
        }, /**
 * Stops processing the queue
 */
        Queue.prototype.stop = function() {
            this._schedule.cancelAll(), this._running = !1;
        }, /**
 * Decides whether to retry. Overridable.
 *
 * @param {Object} item The item being processed
 * @param {Number} attemptNumber The attemptNumber (1 for first retry)
 * @param {Error} error The error from previous attempt, if there was one
 * @return {Boolean} Whether to requeue the message
 */
        Queue.prototype.shouldRetry = function(_, attemptNumber) {
            return !(attemptNumber > this.maxAttempts);
        }, /**
 * Calculates the delay (in ms) for a retry attempt
 *
 * @param {Number} attemptNumber The attemptNumber (1 for first retry)
 * @return {Number} The delay in milliseconds to wait before attempting a retry
 */
        Queue.prototype.getDelay = function(attemptNumber) {
            var ms = this.backoff.MIN_RETRY_DELAY * Math.pow(this.backoff.FACTOR, attemptNumber);
            if (this.backoff.JITTER) {
                var rand = Math.random(), deviation = Math.floor(rand * this.backoff.JITTER * ms);
                Math.floor(10 * rand) < 5 ? ms -= deviation : ms += deviation;
            }
            return Number(Math.min(ms, this.backoff.MAX_RETRY_DELAY).toPrecision(1));
        }, /**
 * Adds an item to the queue
 *
 * @param {Mixed} item The item to process
 */
        Queue.prototype.addItem = function(item) {
            this._enqueue({
                item: item,
                attemptNumber: 0,
                time: this._schedule.now()
            });
        }, /**
 * Adds an item to the retry queue
 *
 * @param {Mixed} item The item to retry
 * @param {Number} attemptNumber The attempt number (1 for first retry)
 * @param {Error} [error] The error from previous attempt, if there was one
 */
        Queue.prototype.requeue = function(item, attemptNumber, error) {
            this.shouldRetry(item, attemptNumber, error) ? this._enqueue({
                item: item,
                attemptNumber: attemptNumber,
                time: this._schedule.now() + this.getDelay(attemptNumber)
            }) : this.emit("discard", item, attemptNumber);
        }, Queue.prototype._enqueue = function(entry) {
            var queue = this._store.get(this.keys.QUEUE) || [];
            queue = queue.slice(-(this.maxItems - 1)), queue.push(entry), queue = queue.sort(function(a, b) {
                return a.time - b.time;
            }), this._store.set(this.keys.QUEUE, queue), this._running && this._processHead();
        }, Queue.prototype._processHead = function() {
            var self = this, store = this._store;
            // cancel the scheduled task if it exists
            this._schedule.cancel(this._processId);
            for (// Pop the head off the queue
            var queue = store.get(this.keys.QUEUE) || [], inProgress = store.get(this.keys.IN_PROGRESS) || {}, now = this._schedule.now(), toRun = [], inProgressSize = Object.keys(inProgress).length; queue.length && queue[0].time <= now && inProgressSize++ < self.maxItems; ) {
                var el = queue.shift(), id = uuid();
                // Save this to the in progress map
                inProgress[id] = {
                    item: el.item,
                    attemptNumber: el.attemptNumber,
                    time: self._schedule.now()
                }, function(el, id) {
                    toRun.push({
                        item: el.item,
                        done: function(err, res) {
                            var inProgress = store.get(self.keys.IN_PROGRESS) || {};
                            delete inProgress[id], store.set(self.keys.IN_PROGRESS, inProgress), self.emit("processed", err, res, el.item), 
                            err && self.requeue(el.item, el.attemptNumber + 1, err);
                        }
                    });
                }(el, id);
            }
            store.set(this.keys.QUEUE, queue), store.set(this.keys.IN_PROGRESS, inProgress), 
            each(function(el) {
                // TODO: handle fn timeout
                try {
                    self.fn(el.item, el.done);
                } catch (err) {
                    debug("Process function threw error: " + err);
                }
            }, toRun), // re-read the queue in case the process function finished immediately or added another item
            queue = store.get(this.keys.QUEUE) || [], this._schedule.cancel(this._processId), 
            queue.length > 0 && (this._processId = this._schedule.run(this._processHead, queue[0].time - now));
        }, // Ack continuously to prevent other tabs from claiming our queue
        Queue.prototype._ack = function() {
            this._store.set(this.keys.ACK, this._schedule.now()), this._store.set(this.keys.RECLAIM_START, null), 
            this._store.set(this.keys.RECLAIM_END, null), this._schedule.run(this._ack, this.timeouts.ACK_TIMER);
        }, Queue.prototype._checkReclaim = function() {
            function tryReclaim(store) {
                store.set(self.keys.RECLAIM_START, self.id), store.set(self.keys.ACK, self._schedule.now()), 
                self._schedule.run(function() {
                    store.get(self.keys.RECLAIM_START) === self.id && (store.set(self.keys.RECLAIM_END, self.id), 
                    self._schedule.run(function() {
                        store.get(self.keys.RECLAIM_END) === self.id && store.get(self.keys.RECLAIM_START) === self.id && self._reclaim(store.id);
                    }, self.timeouts.RECLAIM_WAIT));
                }, self.timeouts.RECLAIM_WAIT);
            }
            var self = this;
            each(function(store) {
                store.id !== self.id && (self._schedule.now() - store.get(self.keys.ACK) < self.timeouts.RECLAIM_TIMEOUT || tryReclaim(store));
            }, function(name) {
                for (var res = [], storage = self._store.engine, i = 0; i < storage.length; i++) {
                    var k = storage.key(i), parts = k.split(".");
                    3 === parts.length && parts[0] === name && "ack" === parts[2] && res.push(new Store(name, parts[1], self.keys));
                }
                return res;
            }(this.name)), this._schedule.run(this._checkReclaim, this.timeouts.RECLAIM_TIMER);
        }, Queue.prototype._reclaim = function(id) {
            var self = this, other = new Store(this.name, id, this.keys), our = {
                queue: this._store.get(this.keys.QUEUE) || []
            }, their = {
                inProgress: other.get(this.keys.IN_PROGRESS) || {},
                queue: other.get(this.keys.QUEUE) || []
            };
            // add their queue to ours, resetting run-time to immediate and copying the attempt#
            each(function(el) {
                our.queue.push({
                    item: el.item,
                    attemptNumber: el.attemptNumber,
                    time: self._schedule.now()
                });
            }, their.queue), // if the queue is abandoned, all the in-progress are failed. retry them immediately and increment the attempt#
            each(function(el) {
                our.queue.push({
                    item: el.item,
                    attemptNumber: el.attemptNumber + 1,
                    time: self._schedule.now()
                });
            }, their.inProgress), our.queue = our.queue.sort(function(a, b) {
                return a.time - b.time;
            }), this._store.set(this.keys.QUEUE, our.queue), // remove all keys
            other.remove(this.keys.ACK), other.remove(this.keys.RECLAIM_START), other.remove(this.keys.RECLAIM_END), 
            other.remove(this.keys.IN_PROGRESS), other.remove(this.keys.QUEUE), // process the new items we claimed
            this._processHead();
        }, module.exports = Queue;
    }, /* 114 */
    /***/
    function(module, exports, __webpack_require__) {
        var v1 = __webpack_require__(227), v4 = __webpack_require__(228), uuid = v4;
        uuid.v1 = v1, uuid.v4 = v4, module.exports = uuid;
    }, /* 115 */
    /***/
    function(module, exports) {
        // Unique ID creation requires a high quality random # generator.  In the
        // browser this is a little complicated due to unknown quality of Math.random()
        // and inconsistent support for the `crypto` API.  We do the best we can via
        // feature-detection
        // getRandomValues needs to be invoked in a context where "this" is a Crypto
        // implementation. Also, find the complete implementation of crypto on IE11.
        var getRandomValues = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
        if (getRandomValues) {
            // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
            var rnds8 = new Uint8Array(16);
            // eslint-disable-line no-undef
            module.exports = function() {
                return getRandomValues(rnds8), rnds8;
            };
        } else {
            // Math.random()-based (RNG)
            //
            // If all else fails, use Math.random().  It's fast, but is of unspecified
            // quality.
            var rnds = new Array(16);
            module.exports = function() {
                for (var r, i = 0; i < 16; i++) 0 == (3 & i) && (r = 4294967296 * Math.random()), 
                rnds[i] = r >>> ((3 & i) << 3) & 255;
                return rnds;
            };
        }
    }, /* 116 */
    /***/
    function(module, exports) {
        function bytesToUuid(buf, offset) {
            var i = offset || 0, bth = byteToHex;
            // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
            return [ bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]] ].join("");
        }
        for (var byteToHex = [], i = 0; i < 256; ++i) byteToHex[i] = (i + 256).toString(16).substr(1);
        module.exports = bytesToUuid;
    }, /* 117 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function isSupportedNatively() {
            try {
                if (!window.localStorage) return !1;
                var key = uuid();
                window.localStorage.setItem(key, "test_value");
                var value = window.localStorage.getItem(key);
                // handle localStorage silently failing
                return window.localStorage.removeItem(key), "test_value" === value;
            } catch (e) {
                // Can throw if localStorage is disabled
                return !1;
            }
        }
        var keys = __webpack_require__(33), uuid = __webpack_require__(114).v4, inMemoryStore = {
            _data: {},
            length: 0,
            setItem: function(key, value) {
                return this._data[key] = value, this.length = keys(this._data).length, value;
            },
            getItem: function(key) {
                return key in this._data ? this._data[key] : null;
            },
            removeItem: function(key) {
                return key in this._data && delete this._data[key], this.length = keys(this._data).length, 
                null;
            },
            clear: function() {
                this._data = {}, this.length = 0;
            },
            key: function(index) {
                return keys(this._data)[index];
            }
        };
        // Return a shared instance
        module.exports.defaultEngine = function() {
            return isSupportedNatively() ? window.localStorage : inMemoryStore;
        }(), // Expose the in-memory store explicitly for testing
        module.exports.inMemoryEngine = inMemoryStore;
    }, /* 118 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(119), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _possibleConstructorReturn2 = __webpack_require__(120), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(121), _inherits3 = _interopRequireDefault(_inherits2), _InMemoryStorage = __webpack_require__(77), _InMemoryStorage2 = _interopRequireDefault(_InMemoryStorage), _SafeStorage2 = __webpack_require__(122), _SafeStorage3 = _interopRequireDefault(_SafeStorage2), _class = function(_SafeStorage) {
            function _class(environmentPrefix) {
                (0, _classCallCheck3.default)(this, _class);
                var storageToUse = void 0;
                try {
                    storageToUse = window.localStorage || _InMemoryStorage2.default;
                } catch (err) {
                    storageToUse = _InMemoryStorage2.default;
                }
                return (0, _possibleConstructorReturn3.default)(this, (_class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call(this, storageToUse, environmentPrefix));
            }
            return (0, _inherits3.default)(_class, _SafeStorage), _class;
        }(_SafeStorage3.default);
        exports.default = _class;
    }, /* 119 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(239),
            __esModule: !0
        };
    }, /* 120 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _typeof2 = __webpack_require__(34), _typeof3 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_typeof2);
        exports.default = function(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" !== (void 0 === call ? "undefined" : (0, _typeof3.default)(call)) && "function" != typeof call ? self : call;
        };
    }, /* 121 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _setPrototypeOf = __webpack_require__(241), _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf), _create = __webpack_require__(245), _create2 = _interopRequireDefault(_create), _typeof2 = __webpack_require__(34), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === superClass ? "undefined" : (0, 
            _typeof3.default)(superClass)));
            subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (_setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass);
        };
    }, /* 122 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function isSupported(store) {
            try {
                if (!store) return !1;
                var key = "awc.storage.support";
                store.setItem(key, "test_value");
                var value = store.getItem(key);
                // handle localStorage silently failing
                return store.removeItem(key), "test_value" === value;
            } catch (e) {
                // Can throw if localStorage is disabled
                return !1;
            }
        }
        function isQuotaExceeded(e) {
            var quotaExceeded = !1;
            if (e.code) switch (e.code) {
              case 22:
                quotaExceeded = !0;
                break;

              case 1014:
                // Firefox
                "NS_ERROR_DOM_QUOTA_REACHED" === e.name && (quotaExceeded = !0);
            } else -2147024882 === e.number && (// Internet Explorer 8
            quotaExceeded = !0);
            return quotaExceeded;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.GLOBAL_IN_MEMORY_NAME = exports.AWC_STORAGE_PREFIX = void 0;
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
        exports.isSupported = isSupported, exports.isQuotaExceeded = isQuotaExceeded;
        var _InMemoryStorage = __webpack_require__(77), _InMemoryStorage2 = _interopRequireDefault(_InMemoryStorage), _analyticsWebTypes = __webpack_require__(11), AWC_STORAGE_PREFIX = exports.AWC_STORAGE_PREFIX = "awc", GLOBAL_IN_MEMORY_NAME = exports.GLOBAL_IN_MEMORY_NAME = "awcInMemoryStorageFallback", SafeStorage = function SafeStorage(storageToUse) {
            var _this = this, environmentPrefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            (0, _classCallCheck3.default)(this, SafeStorage), this.getStore = function() {
                return _this._store;
            }, this.getItem = function(key) {
                return _this._store.getItem(_this.createKey(key));
            }, this.removeItem = function(key) {
                return _this._store.removeItem(_this.createKey(key));
            }, this.setItem = function(key, value) {
                try {
                    _this._store.setItem(_this.createKey(key), value);
                } catch (err) {
                    isQuotaExceeded(err) && (_this.swapToInMemory(), _this._store.setItem(_this.createKey(key), value));
                }
            }, this.swapToInMemory = function() {
                var keys = [];
                if (_this._store) for (var i = 0; i < _this._store.length; i++) keys.push(_this._store.key(i));
                var inMemoryStorage = void 0;
                isSupported(window[GLOBAL_IN_MEMORY_NAME]) ? inMemoryStorage = window[GLOBAL_IN_MEMORY_NAME] : (inMemoryStorage = _InMemoryStorage2.default, 
                window[GLOBAL_IN_MEMORY_NAME] || (// If not already attached to window then attach our instance of InMemoryStorage
                // We need to do this because if there are multiple instances of Analytics Client in multiple scopes,
                // there is no way to guarantee the throttling behaviour of the UI veiwed event across those instances without a global singleton
                window[GLOBAL_IN_MEMORY_NAME] = _InMemoryStorage2.default)), keys.forEach(function(key) {
                    if (0 === key.indexOf(_this.getPrefix())) {
                        var value = _this._store.getItem(key);
                        inMemoryStorage.setItem(key, value);
                    }
                }), _this._store = inMemoryStorage;
            }, this.clear = function() {
                return _this._store.clear();
            }, this.key = function(index) {
                return _this._store.key(index);
            }, this.getPrefix = function() {
                return _this._prefix;
            }, this.createKey = function(key) {
                return _this.getPrefix() + "." + key;
            }, this._prefix = environmentPrefix && environmentPrefix !== _analyticsWebTypes.envType.PROD ? AWC_STORAGE_PREFIX + "-" + environmentPrefix : AWC_STORAGE_PREFIX, 
            isSupported(storageToUse) ? this._store = storageToUse : this.swapToInMemory();
        };
        exports.default = SafeStorage;
    }, /* 123 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(249),
            __esModule: !0
        };
    }, /* 124 */
    /***/
    function(module, exports, __webpack_require__) {
        var hide = __webpack_require__(12);
        module.exports = function(target, src, safe) {
            for (var key in src) safe && target[key] ? target[key] = src[key] : hide(target, key, src[key]);
            return target;
        };
    }, /* 125 */
    /***/
    function(module, exports) {
        module.exports = function(it, Constructor, name, forbiddenField) {
            if (!(it instanceof Constructor) || void 0 !== forbiddenField && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
            return it;
        };
    }, /* 126 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(262),
            __esModule: !0
        };
    }, /* 127 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _map = __webpack_require__(123), _map2 = _interopRequireDefault(_map), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(29), _createClass3 = _interopRequireDefault(_createClass2), PageVisibility = function() {
            function PageVisibility() {
                var _this = this;
                (0, _classCallCheck3.default)(this, PageVisibility), this._bindEventListeners = function() {
                    document.addEventListener(_this._visibilityChange, _this._handleVisibilityChange, !1);
                }, this._handleVisibilityChange = function() {
                    var isHidden = document[_this._hidden];
                    _this._isHidden = isHidden, _this._callbacks.forEach(function(callbackFn) {
                        return callbackFn(isHidden);
                    });
                }, this._isHidden = !1, this._callbacks = new _map2.default(), this._hidden = void 0, 
                this._visibilityChange = void 0, void 0 !== document.hidden ? (// Opera 12.10 and Firefox 18 and later support
                this._isHidden = document.hidden, this._hidden = "hidden", this._visibilityChange = "visibilitychange") : void 0 !== document.msHidden ? (this._isHidden = document.msHidden, 
                this._hidden = "msHidden", this._visibilityChange = "msvisibilitychange") : void 0 !== document.webkitHidden && (this._isHidden = document.webkitHidden, 
                this._hidden = "webkitHidden", this._visibilityChange = "webkitvisibilitychange"), 
                void 0 !== document.addEventListener && void 0 !== this._hidden && this._bindEventListeners();
            }
            return (0, _createClass3.default)(PageVisibility, [ {
                key: "addCallback",
                value: function(name, fn) {
                    if ("string" != typeof name) throw new Error("Invalid name, must be string");
                    if ("function" != typeof fn) throw new Error("Invalid callback, must be function");
                    this._callbacks.set(name, fn);
                }
            }, {
                key: "removeCallback",
                value: function(name) {
                    this._callbacks.has(name) && this._callbacks.delete(name);
                }
            }, {
                key: "getIsHidden",
                value: function() {
                    return this._isHidden;
                }
            } ]), PageVisibility;
        }();
        exports.default = PageVisibility;
    }, /* 128 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* eslint no-bitwise: 0 no-mixed-operators: 0 */
        function uuidv4() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(char) {
                var random = 16 * Math.random() | 0;
                return ("x" === char ? random : 3 & random | 8).toString(16);
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = uuidv4;
    }, /* 129 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function encoderForArrayFormat(opts) {
            switch (opts.arrayFormat) {
              case "index":
                return function(key, value, index) {
                    return null === value ? [ encode(key, opts), "[", index, "]" ].join("") : [ encode(key, opts), "[", encode(index, opts), "]=", encode(value, opts) ].join("");
                };

              case "bracket":
                return function(key, value) {
                    return null === value ? encode(key, opts) : [ encode(key, opts), "[]=", encode(value, opts) ].join("");
                };

              default:
                return function(key, value) {
                    return null === value ? encode(key, opts) : [ encode(key, opts), "=", encode(value, opts) ].join("");
                };
            }
        }
        function parserForArrayFormat(opts) {
            var result;
            switch (opts.arrayFormat) {
              case "index":
                return function(key, value, accumulator) {
                    if (result = /\[(\d*)\]$/.exec(key), key = key.replace(/\[\d*\]$/, ""), !result) return void (accumulator[key] = value);
                    void 0 === accumulator[key] && (accumulator[key] = {}), accumulator[key][result[1]] = value;
                };

              case "bracket":
                return function(key, value, accumulator) {
                    return result = /(\[\])$/.exec(key), key = key.replace(/\[\]$/, ""), result ? void 0 === accumulator[key] ? void (accumulator[key] = [ value ]) : void (accumulator[key] = [].concat(accumulator[key], value)) : void (accumulator[key] = value);
                };

              default:
                return function(key, value, accumulator) {
                    if (void 0 === accumulator[key]) return void (accumulator[key] = value);
                    accumulator[key] = [].concat(accumulator[key], value);
                };
            }
        }
        function encode(value, opts) {
            return opts.encode ? opts.strict ? strictUriEncode(value) : encodeURIComponent(value) : value;
        }
        function keysSorter(input) {
            return Array.isArray(input) ? input.sort() : "object" == typeof input ? keysSorter(Object.keys(input)).sort(function(a, b) {
                return Number(a) - Number(b);
            }).map(function(key) {
                return input[key];
            }) : input;
        }
        function extract(str) {
            var queryStart = str.indexOf("?");
            return -1 === queryStart ? "" : str.slice(queryStart + 1);
        }
        function parse(str, opts) {
            opts = objectAssign({
                arrayFormat: "none"
            }, opts);
            var formatter = parserForArrayFormat(opts), ret = Object.create(null);
            return "string" != typeof str ? ret : (str = str.trim().replace(/^[?#&]/, "")) ? (str.split("&").forEach(function(param) {
                var parts = param.replace(/\+/g, " ").split("="), key = parts.shift(), val = parts.length > 0 ? parts.join("=") : void 0;
                // missing `=` should be `null`:
                // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
                val = void 0 === val ? null : decodeComponent(val), formatter(decodeComponent(key), val, ret);
            }), Object.keys(ret).sort().reduce(function(result, key) {
                var val = ret[key];
                // Sort object keys, not values
                return Boolean(val) && "object" == typeof val && !Array.isArray(val) ? result[key] = keysSorter(val) : result[key] = val, 
                result;
            }, Object.create(null))) : ret;
        }
        var strictUriEncode = __webpack_require__(270), objectAssign = __webpack_require__(271), decodeComponent = __webpack_require__(272);
        exports.extract = extract, exports.parse = parse, exports.stringify = function(obj, opts) {
            opts = objectAssign({
                encode: !0,
                strict: !0,
                arrayFormat: "none"
            }, opts), !1 === opts.sort && (opts.sort = function() {});
            var formatter = encoderForArrayFormat(opts);
            return obj ? Object.keys(obj).sort(opts.sort).map(function(key) {
                var val = obj[key];
                if (void 0 === val) return "";
                if (null === val) return encode(key, opts);
                if (Array.isArray(val)) {
                    var result = [];
                    return val.slice().forEach(function(val2) {
                        void 0 !== val2 && result.push(formatter(key, val2, result.length));
                    }), result.join("&");
                }
                return encode(key, opts) + "=" + encode(val, opts);
            }).filter(function(x) {
                return x.length > 0;
            }).join("&") : "";
        }, exports.parseUrl = function(str, opts) {
            return {
                url: str.split("?")[0] || "",
                query: parse(extract(str), opts)
            };
        };
    }, /* 130 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.omit = exports.omitBy = exports.pickBy = exports.pick = exports.mapKeys = void 0;
        var _keys = __webpack_require__(16), _keys2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_keys), mapKeys = function(obj, fn) {
            return (0, _keys2.default)(obj).reduce(function(acc, k) {
                return acc[fn(obj[k], k, obj)] = obj[k], acc;
            }, {});
        }, pick = function(obj, arr) {
            return arr.reduce(function(acc, curr) {
                return curr in obj && (acc[curr] = obj[curr]), acc;
            }, {});
        }, omitBy = function(obj, fn) {
            return (0, _keys2.default)(obj).filter(function(k) {
                return !fn(obj[k], k);
            }).reduce(function(acc, key) {
                return acc[key] = obj[key], acc;
            }, {});
        }, pickBy = function(obj, fn) {
            return (0, _keys2.default)(obj).filter(function(k) {
                return fn(obj[k], k);
            }).reduce(function(acc, key) {
                return acc[key] = obj[key], acc;
            }, {});
        }, omit = function(obj, arr) {
            return (0, _keys2.default)(obj).filter(function(k) {
                return arr.indexOf(k) < 0;
            }).reduce(function(acc, key) {
                return acc[key] = obj[key], acc;
            }, {});
        };
        exports.mapKeys = mapKeys, exports.pick = pick, exports.pickBy = pickBy, exports.omitBy = omitBy, 
        exports.omit = omit;
    }, /* 131 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _defineProperty = __webpack_require__(126), _defineProperty2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_defineProperty);
        exports.default = function(obj, key, value) {
            return key in obj ? (0, _defineProperty2.default)(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        };
    }, /* 132 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // Modified from https://github.com/jonschlinkert/is-plain-object/blob/master/index.js
        function isObject(val) {
            return null !== val && "object" === (void 0 === val ? "undefined" : (0, _typeof3.default)(val)) && !1 === Array.isArray(val);
        }
        function isObjectObject(o) {
            return !0 === isObject(o) && "[object Object]" === Object.prototype.toString.call(o);
        }
        function isPlainObject(o) {
            if (!1 === isObjectObject(o)) return !1;
            // If has modified constructor
            var ctor = o.constructor;
            if ("function" != typeof ctor) return !1;
            // If has modified prototype
            var prot = ctor.prototype;
            return !1 !== isObjectObject(prot) && "isPrototypeOf" in prot;
        }
        var _typeof2 = __webpack_require__(34), _typeof3 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_typeof2);
        module.exports = {
            isPlainObject: isPlainObject
        };
    }, /* 133 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DwellTimeHelperWithBrowserInteraction = exports.DwellTimeHelper = exports.TypeAheadHelper = exports.originTracingType = exports.userType = exports.tenantType = exports.platformType = exports.originType = exports.eventType = exports.envType = exports.apdexType = exports.default = void 0;
        var _analyticsWebClient = __webpack_require__(134), _analyticsWebClient2 = _interopRequireDefault(_analyticsWebClient), _typeAheadHelper = __webpack_require__(279), _typeAheadHelper2 = _interopRequireDefault(_typeAheadHelper), _dwellTimeHelper = __webpack_require__(280), _dwellTimeHelper2 = _interopRequireDefault(_dwellTimeHelper), _DwellTimeHelperWithBrowserInteraction = __webpack_require__(282), _DwellTimeHelperWithBrowserInteraction2 = _interopRequireDefault(_DwellTimeHelperWithBrowserInteraction), _analyticsWebTypes = __webpack_require__(11);
        exports.default = _analyticsWebClient2.default, exports.apdexType = _analyticsWebTypes.apdexType, 
        exports.envType = _analyticsWebTypes.envType, exports.eventType = _analyticsWebTypes.eventType, 
        exports.originType = _analyticsWebTypes.originType, exports.platformType = _analyticsWebTypes.platformType, 
        exports.tenantType = _analyticsWebTypes.tenantType, exports.userType = _analyticsWebTypes.userType, 
        exports.originTracingType = _analyticsWebTypes.originTracingType, exports.TypeAheadHelper = _typeAheadHelper2.default, 
        exports.DwellTimeHelper = _dwellTimeHelper2.default, exports.DwellTimeHelperWithBrowserInteraction = _DwellTimeHelperWithBrowserInteraction2.default;
    }, /* 134 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _typeof2 = __webpack_require__(34), _typeof3 = _interopRequireDefault(_typeof2), _keys = __webpack_require__(16), _keys2 = _interopRequireDefault(_keys), _stringify = __webpack_require__(65), _stringify2 = _interopRequireDefault(_stringify), _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _analytics = __webpack_require__(160), _analytics2 = _interopRequireDefault(_analytics), _analytics3 = __webpack_require__(198), _analytics4 = _interopRequireDefault(_analytics3), _beforeSendIntegration = __webpack_require__(233), _beforeSendIntegration2 = _interopRequireDefault(_beforeSendIntegration), _uiViewedEvent = __webpack_require__(234), _uiViewedEvent2 = _interopRequireDefault(_uiViewedEvent), _apdexEvent = __webpack_require__(248), _apdexEvent2 = _interopRequireDefault(_apdexEvent), _pageVisibility = __webpack_require__(127), _pageVisibility2 = _interopRequireDefault(_pageVisibility), _tabTracking = __webpack_require__(265), _tabTracking2 = _interopRequireDefault(_tabTracking), _sessionTracking = __webpack_require__(266), _sessionTracking2 = _interopRequireDefault(_sessionTracking), _taskSessionStore = __webpack_require__(267), _taskSessionStore2 = _interopRequireDefault(_taskSessionStore), _originTracing = __webpack_require__(273), _originTracing2 = _interopRequireDefault(_originTracing), _analyticsWebTypes = __webpack_require__(11), _eventBuilder = __webpack_require__(274), _eventValidation = __webpack_require__(82), _urlUtils = __webpack_require__(81), _wrapCallback = __webpack_require__(276), _wrapCallback2 = _interopRequireDefault(_wrapCallback), _createGetter = __webpack_require__(278), _createGetter2 = _interopRequireDefault(_createGetter), _SafeSessionStorage = __webpack_require__(79), _SafeSessionStorage2 = _interopRequireDefault(_SafeSessionStorage), ALLOWED_TENANTED_HOSTS = [ "atlassian.net", "jira.com", "jira-dev.com", "admin.atlassian.com", "admin.stg.atlassian.com" ], AnalyticsWebClient = function AnalyticsWebClient() {
            var productInfo = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, settings = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if ((0, _classCallCheck3.default)(this, AnalyticsWebClient), _initialiseProps.call(this), 
            !productInfo) throw new Error("Missing productInfo");
            if (!productInfo.env) throw new Error("Missing productInfo.env");
            if (!productInfo.product) throw new Error("Missing productInfo.product");
            if (!(0, _analyticsWebTypes.isType)(_analyticsWebTypes.envType, productInfo.env)) throw new Error("Invalid productInfo.env '" + productInfo.env + "', must be an envType: [" + (0, 
            _analyticsWebTypes.objectValues)(_analyticsWebTypes.envType) + "]");
            if (productInfo.origin) {
                if (!(0, _analyticsWebTypes.isType)(_analyticsWebTypes.originType, productInfo.origin)) throw new Error("Invalid productInfo.origin '" + productInfo.origin + "', must be an originType: [" + (0, 
                _analyticsWebTypes.objectValues)(_analyticsWebTypes.originType) + "]");
            } else productInfo.origin = _analyticsWebTypes.originType.WEB;
            productInfo.platform ? (0, _eventValidation.validatePlatform)(productInfo) : productInfo.platform = productInfo.origin === _analyticsWebTypes.originType.WEB ? _analyticsWebTypes.platformType.WEB : _analyticsWebTypes.platformType.DESKTOP, 
            productInfo.embeddedProduct = this._createEmbeddedProductGetter(productInfo.embeddedProduct), 
            productInfo.subproduct = this._createSubproductGetter(productInfo.subproduct), this._productInfo = (0, 
            _extends3.default)({}, productInfo), this._tenantInfo = {}, this._orgInfo = {}, 
            this._userInfo = {}, this._context = (0, _eventBuilder.buildContext)(this._productInfo), 
            this._safeSessionStorage = new _SafeSessionStorage2.default();
            var analytics = new _analytics2.default(), useStargate = this._useStargate(settings.useStargate), maxRetryAttempts = settings.maxRetryAttempts || 4, minRetryDelay = settings.minRetryDelay || 1e3;
            analytics.use(_beforeSendIntegration2.default), analytics.use(_analytics4.default), 
            analytics.init({
                BeforeSend: {},
                "Segment.io": {
                    apiKey: settings.apiKey || "",
                    apiHost: settings.apiHost || this._selectHost({
                        useStargate: useStargate,
                        env: productInfo.env
                    }),
                    retryQueue: !0,
                    retryQueuePrefix: "awc-" + productInfo.env,
                    addBundledMetadata: !0,
                    unbundledIntegrations: [ "Amplitude" ],
                    retryQueueOptions: {
                        maxRetryDelay: 4e5,
                        minRetryDelay: minRetryDelay,
                        backoffFactor: 2,
                        maxAttempts: maxRetryAttempts,
                        maxItems: 100
                    },
                    useBatchQueue: settings.useBatchQueue || !1
                }
            }, {
                user: {
                    // Stop the userId from persisting even after the user has logged out
                    persist: !1,
                    // Stop the userId from being loaded from cookies set by other Segment clients
                    cookie: {},
                    // Stop the userId from being loaded from localStorage set by other Segment clients
                    localStorage: {},
                    localStorageFallbackDisabled: !0
                }
            }), this._analytics = analytics, this._pageVisibility = new _pageVisibility2.default(), 
            this._tabTracking = new _tabTracking2.default(), this._sessionTracking = new _sessionTracking2.default({
                sessionExpiryTime: settings.sessionExpiryTime
            }), this.task = new _taskSessionStore2.default(), this.originTracing = new _originTracing2.default(), 
            // Init Apdex
            this._apdexEvent = new _apdexEvent2.default(this.sendOperationalEvent, this._pageVisibility), 
            this._historyReplaceFn = "function" == typeof settings.historyReplaceFn ? settings.historyReplaceFn : _urlUtils.defaultHistoryReplaceFn;
        }, _initialiseProps = function() {
            var _this = this;
            this._useStargate = function(useStargate) {
                return null == useStargate || useStargate;
            }, this._selectHost = function(_ref) {
                var useStargate = _ref.useStargate, env = _ref.env;
                return useStargate ? _this._isTenantedHost() ? window.location.host + "/gateway/api/gasv3/api/v1" : env === _analyticsWebTypes.envType.PROD ? "api-private.atlassian.com/gasv3/api/v1" : "api-private.stg.atlassian.com/gasv3/api/v1" : env === _analyticsWebTypes.envType.PROD ? "as.atlassian.com/api/v1" : "analytics-service.us-east-1.staging.public.atl-paas.net/api/v1";
            }, this._isTenantedHost = function() {
                return ALLOWED_TENANTED_HOSTS.filter(function(host) {
                    return _this._endsWith(window.location.host, host);
                }).length > 0;
            }, this._endsWith = function(str, suffix) {
                return -1 !== str.indexOf(suffix, str.length - suffix.length);
            }, this._changeInternalUserId = function(userId) {
                // Segment library workaround to change userId without triggering an identify call.
                _this._analytics.user().id() !== userId && _this._analytics.user().id(userId);
            }, this._createSubproductGetter = function(subproduct) {
                return (0, _createGetter2.default)(subproduct, "Cannot get subproduct from the callback. Proceeding without it.");
            }, this._createEmbeddedProductGetter = function(embeddedProduct) {
                return (0, _createGetter2.default)(embeddedProduct, "Cannot get embeddedProduct from the callback. Proceeding without it.");
            }, this._getLastScreenEvent = function() {
                try {
                    return JSON.parse(_this._safeSessionStorage.getItem("last.screen.event"));
                } catch (err) {
                    return _this._safeSessionStorage.removeItem("last.screen.event"), null;
                }
            }, this._setLastScreenEvent = function(event) {
                _this._safeSessionStorage.setItem("last.screen.event", (0, _stringify2.default)({
                    name: event.name,
                    attributes: event.attributes
                }));
            }, this.setEmbeddedProduct = function(embeddedProduct) {
                _this._productInfo.embeddedProduct = _this._createEmbeddedProductGetter(embeddedProduct), 
                _this.resetUIViewedTimers();
            }, this.clearEmbeddedProduct = function() {
                _this._productInfo.embeddedProduct = _this._createEmbeddedProductGetter(null);
            }, this.setSubproduct = function(subproduct) {
                _this._productInfo.subproduct = _this._createSubproductGetter(subproduct), _this.resetUIViewedTimers();
            }, this.setOriginTracingHandlers = function(originParamHandlerMapping) {
                var capturedOriginTraces = _this.originTracing.handleOriginParameters(originParamHandlerMapping, _this._historyReplaceFn);
                (0, _keys2.default)(capturedOriginTraces).forEach(function(x) {
                    void 0 !== capturedOriginTraces[x].taskSessionId && _this.task.createTaskSessionWithProvidedId(x, capturedOriginTraces[x].taskSessionId);
                });
                var originAttributes = {};
                (0, _keys2.default)(capturedOriginTraces).forEach(function(x) {
                    capturedOriginTraces[x].originTracingAttributes ? originAttributes[x] = capturedOriginTraces[x].originTracingAttributes : // eslint-disable-next-line no-console
                    console.warn("Handling method for origin parameter " + x + " has not returned any attributes");
                }), (0, _keys2.default)(capturedOriginTraces).length > 0 && _this.sendOperationalEvent({
                    action: "landed",
                    actionSubject: "origin",
                    source: "webClient",
                    attributes: {
                        originTracesLanded: originAttributes
                    }
                }, function() {});
            }, this.setTenantInfo = function(tenantIdType, tenantId) {
                if (!tenantIdType) throw new Error("Missing tenantIdType");
                if (tenantIdType !== _analyticsWebTypes.tenantType.NONE && !tenantId) throw new Error("Missing tenantId");
                if (!(0, _analyticsWebTypes.isType)(_analyticsWebTypes.tenantType, tenantIdType)) throw new Error("Invalid tenantIdType '" + tenantIdType + "', must be an tenantType: [" + (0, 
                _analyticsWebTypes.objectValues)(_analyticsWebTypes.tenantType) + "]");
                _this._tenantInfo = {
                    tenantIdType: tenantIdType,
                    tenantId: tenantId
                };
            }, this.clearTenantInfo = function() {
                _this._tenantInfo = {};
            }, this.setOrgInfo = function(orgId) {
                if (!orgId) throw new Error("Missing orgId");
                _this._orgInfo = {
                    orgId: orgId
                };
            }, this.clearOrgInfo = function() {
                _this._orgInfo = {};
            }, this.setUserInfo = function(userIdType, userId) {
                (0, _eventValidation.validateIdentifyEvent)(userIdType, userId), _this._userInfo = {
                    userIdType: userIdType,
                    userId: userId
                }, _this._changeInternalUserId(userId);
            }, this.clearUserInfo = function() {
                _this._userInfo = {}, _this._changeInternalUserId(null);
            }, this.sendIdentifyEvent = function(userIdType, userId, callback) {
                (0, _eventValidation.validateIdentifyEvent)(userIdType, userId), _this._userInfo = {
                    userIdType: userIdType,
                    userId: userId
                }, _this._analytics.identify(userId, {
                    userIdType: userIdType
                }, _this._context, callback);
            }, this.sendPageEvent = function(name, callback) {
                _this.sendScreenEvent(name, callback);
            }, this.sendScreenEvent = function(event, callback, attributes) {
                var screenName = void 0, screenAttributes = void 0, screenContainers = void 0, screenTags = void 0;
                "object" === (void 0 === event ? "undefined" : (0, _typeof3.default)(event)) ? (/* This is for retrocompatibility */
                screenName = event.name, screenAttributes = event.attributes, screenContainers = event.containers, 
                screenTags = event.tags) : (screenName = event, screenAttributes = attributes), 
                (0, _eventValidation.validateScreenEvent)(screenName), (0, _eventValidation.validateContainers)(screenContainers);
                var builtEvent = (0, _eventBuilder.buildScreenEvent)(_this._productInfo, _this._tenantInfo, _this._userInfo, screenAttributes, event.nonPrivacySafeAttributes, screenTags, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo, screenContainers);
                _this._setLastScreenEvent((0, _extends3.default)({
                    name: screenName
                }, builtEvent)), _this._analytics.page(screenName, builtEvent, _this._context, (0, 
                _wrapCallback2.default)(callback, builtEvent));
            }, this.sendTrackEvent = function(event, callback) {
                (0, _eventValidation.validateTrackEvent)(event);
                var builtEvent = (0, _eventBuilder.buildActionEvent)(_this._productInfo, _this._tenantInfo, _this._userInfo, event, _analyticsWebTypes.eventType.TRACK, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
                _this._analytics.track((0, _eventBuilder.buildActionName)(event), builtEvent, _this._context, (0, 
                _wrapCallback2.default)(callback, builtEvent));
            }, this.sendUIEvent = function(event, callback) {
                (0, _eventValidation.validateUIEvent)(event);
                var builtEvent = (0, _eventBuilder.buildActionEvent)(_this._productInfo, _this._tenantInfo, _this._userInfo, event, _analyticsWebTypes.eventType.UI, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
                _this._analytics.track((0, _eventBuilder.buildActionName)(event), builtEvent, _this._context, (0, 
                _wrapCallback2.default)(callback, builtEvent));
            }, this.sendOperationalEvent = function(event, callback) {
                (0, _eventValidation.validateOperationalEvent)(event);
                var builtEvent = (0, _eventBuilder.buildActionEvent)(_this._productInfo, _this._tenantInfo, _this._userInfo, event, _analyticsWebTypes.eventType.OPERATIONAL, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
                _this._analytics.track((0, _eventBuilder.buildActionName)(event), builtEvent, _this._context, (0, 
                _wrapCallback2.default)(callback, builtEvent));
            }, this.startUIViewedEvent = function(callback) {
                _this.stopUIViewedEvent(), _this._uiViewedEvent = new _uiViewedEvent2.default(_this._productInfo, function() {
                    return {
                        embeddedProduct: _this._productInfo.embeddedProduct(),
                        subproduct: _this._productInfo.subproduct(),
                        tenantIdType: _this._tenantInfo.tenantIdType,
                        tenantId: _this._tenantInfo.tenantId,
                        userId: _this._userInfo.userId,
                        lastScreenEvent: _this._getLastScreenEvent()
                    };
                }, function(event) {
                    return _this.sendUIEvent(event, callback);
                }), _this._uiViewedEvent.start();
            }, this.stopUIViewedEvent = function() {
                _this._uiViewedEvent && (_this._uiViewedEvent.stop(), _this._uiViewedEvent = null);
            }, this.resetUIViewedTimers = function() {
                _this._uiViewedEvent && _this._uiViewedEvent.resetTimers();
            }, this.startApdexEvent = function(apdexEvent) {
                _this._apdexEvent.start(apdexEvent);
            }, this.getApdexStart = function(apdexEvent) {
                return _this._apdexEvent.getStart(apdexEvent);
            }, this.stopApdexEvent = function(apdexEvent, callback) {
                _this._apdexEvent.stop(apdexEvent, callback);
            }, this.onEvent = function(analyticsId, analyticsData) {
                if (!analyticsData) throw new Error("Missing analyticsData");
                if (!analyticsData.eventType) throw new Error("Missing analyticsData.eventType");
                if (!(0, _analyticsWebTypes.isType)(_analyticsWebTypes.eventType, analyticsData.eventType)) throw new Error("Invalid analyticsData.eventType '" + analyticsData.eventType + "', must be an eventType: [" + (0, 
                _analyticsWebTypes.objectValues)(_analyticsWebTypes.eventType) + "]");
                analyticsData.eventType === _analyticsWebTypes.eventType.TRACK ? _this.sendTrackEvent(analyticsData) : analyticsData.eventType === _analyticsWebTypes.eventType.UI ? _this.sendUIEvent(analyticsData) : analyticsData.eventType === _analyticsWebTypes.eventType.OPERATIONAL && _this.sendOperationalEvent(analyticsData);
            };
        };
        exports.default = AnalyticsWebClient;
    }, /* 135 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(136),
            __esModule: !0
        };
    }, /* 136 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(35), __webpack_require__(41), module.exports = __webpack_require__(61).f("iterator");
    }, /* 137 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(51), defined = __webpack_require__(36);
        // true  -> String#at
        // false -> String#codePointAt
        module.exports = function(TO_STRING) {
            return function(that, pos) {
                var a, b, s = String(defined(that)), i = toInteger(pos), l = s.length;
                return i < 0 || i >= l ? TO_STRING ? "" : void 0 : (a = s.charCodeAt(i), a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : b - 56320 + (a - 55296 << 10) + 65536);
            };
        };
    }, /* 138 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            if ("function" != typeof it) throw TypeError(it + " is not a function!");
            return it;
        };
    }, /* 139 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var create = __webpack_require__(38), descriptor = __webpack_require__(37), setToStringTag = __webpack_require__(40), IteratorPrototype = {};
        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        __webpack_require__(12)(IteratorPrototype, __webpack_require__(2)("iterator"), function() {
            return this;
        }), module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, {
                next: descriptor(1, next)
            }), setToStringTag(Constructor, NAME + " Iterator");
        };
    }, /* 140 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(7), anObject = __webpack_require__(13), getKeys = __webpack_require__(20);
        module.exports = __webpack_require__(8) ? Object.defineProperties : function(O, Properties) {
            anObject(O);
            for (var P, keys = getKeys(Properties), length = keys.length, i = 0; length > i; ) dP.f(O, P = keys[i++], Properties[P]);
            return O;
        };
    }, /* 141 */
    /***/
    function(module, exports, __webpack_require__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __webpack_require__(15), toLength = __webpack_require__(57), toIndex = __webpack_require__(142);
        module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
                var value, O = toIObject($this), length = toLength(O.length), index = toIndex(fromIndex, length);
                // Array#includes uses SameValueZero equality algorithm
                if (IS_INCLUDES && el != el) {
                    for (;length > index; ) if ((value = O[index++]) != value) return !0;
                } else for (;length > index; index++) if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                return !IS_INCLUDES && -1;
            };
        };
    }, /* 142 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(51), max = Math.max, min = Math.min;
        module.exports = function(index, length) {
            return index = toInteger(index), index < 0 ? max(index + length, 0) : min(index, length);
        };
    }, /* 143 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(6).document && document.documentElement;
    }, /* 144 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var addToUnscopables = __webpack_require__(145), step = __webpack_require__(88), Iterators = __webpack_require__(24), toIObject = __webpack_require__(15);
        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()
        module.exports = __webpack_require__(52)(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated), // target
            this._i = 0, // next index
            this._k = kind;
        }, function() {
            var O = this._t, kind = this._k, index = this._i++;
            return !O || index >= O.length ? (this._t = void 0, step(1)) : "keys" == kind ? step(0, index) : "values" == kind ? step(0, O[index]) : step(0, [ index, O[index] ]);
        }, "values"), // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators.Arguments = Iterators.Array, addToUnscopables("keys"), addToUnscopables("values"), 
        addToUnscopables("entries");
    }, /* 145 */
    /***/
    function(module, exports) {
        module.exports = function() {};
    }, /* 146 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(147),
            __esModule: !0
        };
    }, /* 147 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(148), __webpack_require__(92), __webpack_require__(152), __webpack_require__(153), 
        module.exports = __webpack_require__(0).Symbol;
    }, /* 148 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // ECMAScript 6 symbols shim
        var global = __webpack_require__(6), has = __webpack_require__(19), DESCRIPTORS = __webpack_require__(8), $export = __webpack_require__(3), redefine = __webpack_require__(85), META = __webpack_require__(42).KEY, $fails = __webpack_require__(18), shared = __webpack_require__(59), setToStringTag = __webpack_require__(40), uid = __webpack_require__(39), wks = __webpack_require__(2), wksExt = __webpack_require__(61), wksDefine = __webpack_require__(62), keyOf = __webpack_require__(149), enumKeys = __webpack_require__(150), isArray = __webpack_require__(89), anObject = __webpack_require__(13), toIObject = __webpack_require__(15), toPrimitive = __webpack_require__(54), createDesc = __webpack_require__(37), _create = __webpack_require__(38), gOPNExt = __webpack_require__(151), $GOPD = __webpack_require__(91), $DP = __webpack_require__(7), $keys = __webpack_require__(20), gOPD = $GOPD.f, dP = $DP.f, gOPN = gOPNExt.f, $Symbol = global.Symbol, $JSON = global.JSON, _stringify = $JSON && $JSON.stringify, HIDDEN = wks("_hidden"), TO_PRIMITIVE = wks("toPrimitive"), isEnum = {}.propertyIsEnumerable, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), OPSymbols = shared("op-symbols"), ObjectProto = Object.prototype, USE_NATIVE = "function" == typeof $Symbol, QObject = global.QObject, setter = !QObject || !QObject.prototype || !QObject.prototype.findChild, setSymbolDesc = DESCRIPTORS && $fails(function() {
            return 7 != _create(dP({}, "a", {
                get: function() {
                    return dP(this, "a", {
                        value: 7
                    }).a;
                }
            })).a;
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            protoDesc && delete ObjectProto[key], dP(it, key, D), protoDesc && it !== ObjectProto && dP(ObjectProto, key, protoDesc);
        } : dP, wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol.prototype);
            return sym._k = tag, sym;
        }, isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
            return "symbol" == typeof it;
        } : function(it) {
            return it instanceof $Symbol;
        }, $defineProperty = function(it, key, D) {
            return it === ObjectProto && $defineProperty(OPSymbols, key, D), anObject(it), key = toPrimitive(key, !0), 
            anObject(D), has(AllSymbols, key) ? (D.enumerable ? (has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = !1), 
            D = _create(D, {
                enumerable: createDesc(0, !1)
            })) : (has(it, HIDDEN) || dP(it, HIDDEN, createDesc(1, {})), it[HIDDEN][key] = !0), 
            setSymbolDesc(it, key, D)) : dP(it, key, D);
        }, $defineProperties = function(it, P) {
            anObject(it);
            for (var key, keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length; l > i; ) $defineProperty(it, key = keys[i++], P[key]);
            return it;
        }, $create = function(it, P) {
            return void 0 === P ? _create(it) : $defineProperties(_create(it), P);
        }, $propertyIsEnumerable = function(key) {
            var E = isEnum.call(this, key = toPrimitive(key, !0));
            return !(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]) || E);
        }, $getOwnPropertyDescriptor = function(it, key) {
            if (it = toIObject(it), key = toPrimitive(key, !0), it !== ObjectProto || !has(AllSymbols, key) || has(OPSymbols, key)) {
                var D = gOPD(it, key);
                return !D || !has(AllSymbols, key) || has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = !0), 
                D;
            }
        }, $getOwnPropertyNames = function(it) {
            for (var key, names = gOPN(toIObject(it)), result = [], i = 0; names.length > i; ) has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
            return result;
        }, $getOwnPropertySymbols = function(it) {
            for (var key, IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0; names.length > i; ) !has(AllSymbols, key = names[i++]) || IS_OP && !has(ObjectProto, key) || result.push(AllSymbols[key]);
            return result;
        };
        // 19.4.1.1 Symbol([description])
        USE_NATIVE || ($Symbol = function() {
            if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
            var tag = uid(arguments.length > 0 ? arguments[0] : void 0), $set = function(value) {
                this === ObjectProto && $set.call(OPSymbols, value), has(this, HIDDEN) && has(this[HIDDEN], tag) && (this[HIDDEN][tag] = !1), 
                setSymbolDesc(this, tag, createDesc(1, value));
            };
            return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
                configurable: !0,
                set: $set
            }), wrap(tag);
        }, redefine($Symbol.prototype, "toString", function() {
            return this._k;
        }), $GOPD.f = $getOwnPropertyDescriptor, $DP.f = $defineProperty, __webpack_require__(90).f = gOPNExt.f = $getOwnPropertyNames, 
        __webpack_require__(32).f = $propertyIsEnumerable, __webpack_require__(63).f = $getOwnPropertySymbols, 
        DESCRIPTORS && !__webpack_require__(53) && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0), 
        wksExt.f = function(name) {
            return wrap(wks(name));
        }), $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Symbol: $Symbol
        });
        for (var symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), i = 0; symbols.length > i; ) wks(symbols[i++]);
        for (var symbols = $keys(wks.store), i = 0; symbols.length > i; ) wksDefine(symbols[i++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
            // 19.4.2.1 Symbol.for(key)
            for: function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
            },
            // 19.4.2.5 Symbol.keyFor(sym)
            keyFor: function(key) {
                if (isSymbol(key)) return keyOf(SymbolRegistry, key);
                throw TypeError(key + " is not a symbol!");
            },
            useSetter: function() {
                setter = !0;
            },
            useSimple: function() {
                setter = !1;
            }
        }), $export($export.S + $export.F * !USE_NATIVE, "Object", {
            // 19.1.2.2 Object.create(O [, Properties])
            create: $create,
            // 19.1.2.4 Object.defineProperty(O, P, Attributes)
            defineProperty: $defineProperty,
            // 19.1.2.3 Object.defineProperties(O, Properties)
            defineProperties: $defineProperties,
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            // 19.1.2.7 Object.getOwnPropertyNames(O)
            getOwnPropertyNames: $getOwnPropertyNames,
            // 19.1.2.8 Object.getOwnPropertySymbols(O)
            getOwnPropertySymbols: $getOwnPropertySymbols
        }), // 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
            var S = $Symbol();
            // MS Edge converts symbol values to JSON as {}
            // WebKit converts symbol values to JSON as null
            // V8 throws on boxed symbols
            return "[null]" != _stringify([ S ]) || "{}" != _stringify({
                a: S
            }) || "{}" != _stringify(Object(S));
        })), "JSON", {
            stringify: function(it) {
                if (void 0 !== it && !isSymbol(it)) {
                    for (// IE8 returns string on undefined
                    var replacer, $replacer, args = [ it ], i = 1; arguments.length > i; ) args.push(arguments[i++]);
                    return replacer = args[1], "function" == typeof replacer && ($replacer = replacer), 
                    !$replacer && isArray(replacer) || (replacer = function(key, value) {
                        if ($replacer && (value = $replacer.call(this, key, value)), !isSymbol(value)) return value;
                    }), args[1] = replacer, _stringify.apply($JSON, args);
                }
            }
        }), // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol.prototype[TO_PRIMITIVE] || __webpack_require__(12)($Symbol.prototype, TO_PRIMITIVE, $Symbol.prototype.valueOf), 
        // 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, "Symbol"), // 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, "Math", !0), // 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, "JSON", !0);
    }, /* 149 */
    /***/
    function(module, exports, __webpack_require__) {
        var getKeys = __webpack_require__(20), toIObject = __webpack_require__(15);
        module.exports = function(object, el) {
            for (var key, O = toIObject(object), keys = getKeys(O), length = keys.length, index = 0; length > index; ) if (O[key = keys[index++]] === el) return key;
        };
    }, /* 150 */
    /***/
    function(module, exports, __webpack_require__) {
        // all enumerable object keys, includes symbols
        var getKeys = __webpack_require__(20), gOPS = __webpack_require__(63), pIE = __webpack_require__(32);
        module.exports = function(it) {
            var result = getKeys(it), getSymbols = gOPS.f;
            if (getSymbols) for (var key, symbols = getSymbols(it), isEnum = pIE.f, i = 0; symbols.length > i; ) isEnum.call(it, key = symbols[i++]) && result.push(key);
            return result;
        };
    }, /* 151 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject = __webpack_require__(15), gOPN = __webpack_require__(90).f, toString = {}.toString, windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], getWindowNames = function(it) {
            try {
                return gOPN(it);
            } catch (e) {
                return windowNames.slice();
            }
        };
        module.exports.f = function(it) {
            return windowNames && "[object Window]" == toString.call(it) ? getWindowNames(it) : gOPN(toIObject(it));
        };
    }, /* 152 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(62)("asyncIterator");
    }, /* 153 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(62)("observable");
    }, /* 154 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(155), module.exports = __webpack_require__(0).Object.keys;
    }, /* 155 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __webpack_require__(31), $keys = __webpack_require__(20);
        __webpack_require__(64)("keys", function() {
            return function(it) {
                return $keys(toObject(it));
            };
        });
    }, /* 156 */
    /***/
    function(module, exports, __webpack_require__) {
        var core = __webpack_require__(0), $JSON = core.JSON || (core.JSON = {
            stringify: JSON.stringify
        });
        module.exports = function(it) {
            // eslint-disable-line no-unused-vars
            return $JSON.stringify.apply($JSON, arguments);
        };
    }, /* 157 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(158), module.exports = __webpack_require__(0).Object.assign;
    }, /* 158 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __webpack_require__(3);
        $export($export.S + $export.F, "Object", {
            assign: __webpack_require__(159)
        });
    }, /* 159 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // 19.1.2.1 Object.assign(target, source, ...)
        var getKeys = __webpack_require__(20), gOPS = __webpack_require__(63), pIE = __webpack_require__(32), toObject = __webpack_require__(31), IObject = __webpack_require__(55), $assign = Object.assign;
        // should work with symbols and should have deterministic property order (V8 bug)
        module.exports = !$assign || __webpack_require__(18)(function() {
            var A = {}, B = {}, S = Symbol(), K = "abcdefghijklmnopqrst";
            return A[S] = 7, K.split("").forEach(function(k) {
                B[k] = k;
            }), 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K;
        }) ? function(target, source) {
            for (// eslint-disable-line no-unused-vars
            var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f; aLen > index; ) for (var key, S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0; length > j; ) isEnum.call(S, key = keys[j++]) && (T[key] = S[key]);
            return T;
        } : $assign;
    }, /* 160 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */
        (function(global) {
            /**
 * Initialize a new `Analytics` instance.
 */
            function Analytics() {
                this._options({}), this.Integrations = {}, this._sourceMiddlewares = new SourceMiddlewareChain(), 
                this._integrationMiddlewares = new IntegrationMiddlewareChain(), this._integrations = {}, 
                this._readied = !1, this._timeout = 300, // XXX: BACKWARDS COMPATIBILITY
                this._user = user, this.log = debug("analytics.js"), bindAll(this);
                var self = this;
                this.on("initialize", function(settings, options) {
                    options.initialPageview && self.page(), self._parseQuery(window.location.search);
                });
            }
            var _analytics = global.analytics, Alias = __webpack_require__(21).Alias, Emitter = __webpack_require__(47), Facade = __webpack_require__(21), Group = __webpack_require__(21).Group, Identify = __webpack_require__(21).Identify, SourceMiddlewareChain = __webpack_require__(101).SourceMiddlewareChain, IntegrationMiddlewareChain = __webpack_require__(101).IntegrationMiddlewareChain, Page = __webpack_require__(21).Page, Track = __webpack_require__(21).Track, bindAll = __webpack_require__(23), clone = __webpack_require__(26), extend = __webpack_require__(170), cookie = __webpack_require__(48), metrics = __webpack_require__(177), debug = __webpack_require__(4), defaults = __webpack_require__(27), each = __webpack_require__(5), foldl = __webpack_require__(70), group = __webpack_require__(182), is = __webpack_require__(45), isMeta = __webpack_require__(184), keys = __webpack_require__(33), memory = __webpack_require__(107), nextTick = __webpack_require__(50), normalize = __webpack_require__(188), on = __webpack_require__(191).bind, pageDefaults = __webpack_require__(192), pick = __webpack_require__(194), prevent = __webpack_require__(195), querystring = __webpack_require__(75), store = __webpack_require__(72), user = __webpack_require__(197), type = __webpack_require__(22);
            /**
 * Mix in event emitter.
 */
            Emitter(Analytics.prototype), /**
 * Use a `plugin`.
 *
 * @param {Function} plugin
 * @return {Analytics}
 */
            Analytics.prototype.use = function(plugin) {
                return plugin(this), this;
            }, /**
 * Define a new `Integration`.
 *
 * @param {Function} Integration
 * @return {Analytics}
 */
            Analytics.prototype.addIntegration = function(Integration) {
                var name = Integration.prototype.name;
                if (!name) throw new TypeError("attempted to add an invalid integration");
                return this.Integrations[name] = Integration, this;
            }, /**
 * Define a new `SourceMiddleware`
 *
 * @param {Function} Middleware
 * @return {Analytics}
 */
            Analytics.prototype.addSourceMiddleware = function(middleware) {
                if (this.initialized) throw new Error("attempted to add a source middleware after initialization");
                return this._sourceMiddlewares.add(middleware), this;
            }, /**
 * Define a new `IntegrationMiddleware`
 *
 * @param {Function} Middleware
 * @return {Analytics}
 */
            Analytics.prototype.addIntegrationMiddleware = function(middleware) {
                if (this.initialized) throw new Error("attempted to add an integration middleware after initialization");
                return this._integrationMiddlewares.add(middleware), this;
            }, /**
 * Initialize with the given integration `settings` and `options`.
 *
 * Aliased to `init` for convenience.
 *
 * @param {Object} [settings={}]
 * @param {Object} [options={}]
 * @return {Analytics}
 */
            Analytics.prototype.init = Analytics.prototype.initialize = function(settings, options) {
                settings = settings || {}, options = options || {}, this._options(options), this._readied = !1;
                // clean unknown integrations from settings
                var self = this;
                each(function(opts, name) {
                    self.Integrations[name] || delete settings[name];
                }, settings), // add integrations
                each(function(opts, name) {
                    // Don't load disabled integrations
                    if (!options.integrations || !1 !== options.integrations[name] && (!1 !== options.integrations.All || options.integrations[name])) {
                        var Integration = self.Integrations[name], clonedOpts = {};
                        extend(!0, clonedOpts, opts);
                        // deep clone opts
                        var integration = new Integration(clonedOpts);
                        self.log("initialize %o - %o", name, opts), self.add(integration);
                    }
                }, settings);
                var integrations = this._integrations;
                // load user now that options are set
                user.load(), group.load();
                // make ready callback
                var readyCallCount = 0, integrationCount = keys(integrations).length, ready = function() {
                    ++readyCallCount >= integrationCount && (self._readied = !0, self.emit("ready"));
                };
                // init if no integrations
                integrationCount <= 0 && ready(), // initialize integrations, passing ready
                // create a list of any integrations that did not initialize - this will be passed with all events for replay support:
                this.failedInitializations = [];
                var initialPageSkipped = !1;
                // backwards compat with angular plugin and used for init logic checks
                return each(function(integration) {
                    if (options.initialPageview && !1 === integration.options.initialPageview) {
                        // We've assumed one initial pageview, so make sure we don't count the first page call.
                        var page = integration.page;
                        integration.page = function() {
                            if (initialPageSkipped) return page.apply(this, arguments);
                            initialPageSkipped = !0;
                        };
                    }
                    integration.analytics = self, integration.once("ready", ready);
                    try {
                        metrics.increment("analytics_js.integration.invoke", {
                            method: "initialize",
                            integration_name: integration.name
                        }), integration.initialize();
                    } catch (e) {
                        var integrationName = integration.name;
                        metrics.increment("analytics_js.integration.invoke.error", {
                            method: "initialize",
                            integration_name: integration.name
                        }), self.failedInitializations.push(integrationName), self.log("Error initializing %s integration: %o", integrationName, e), 
                        // Mark integration as ready to prevent blocking of anyone listening to analytics.ready()
                        integration.ready();
                    }
                }, integrations), this.initialized = !0, this.emit("initialize", settings, options), 
                this;
            }, /**
 * Set the user's `id`.
 *
 * @param {Mixed} id
 */
            Analytics.prototype.setAnonymousId = function(id) {
                return this.user().anonymousId(id), this;
            }, /**
 * Add an integration.
 *
 * @param {Integration} integration
 */
            Analytics.prototype.add = function(integration) {
                return this._integrations[integration.name] = integration, this;
            }, /**
 * Identify a user by optional `id` and `traits`.
 *
 * @param {string} [id=user.id()] User ID.
 * @param {Object} [traits=null] User traits.
 * @param {Object} [options=null]
 * @param {Function} [fn]
 * @return {Analytics}
 */
            Analytics.prototype.identify = function(id, traits, options, fn) {
                // Argument reshuffling.
                /* eslint-disable no-unused-expressions, no-sequences */
                is.fn(options) && (fn = options, options = null), is.fn(traits) && (fn = traits, 
                options = null, traits = null), is.object(id) && (options = traits, traits = id, 
                id = user.id()), /* eslint-enable no-unused-expressions, no-sequences */
                // clone traits before we manipulate so we don't do anything uncouth, and take
                // from `user` so that we carryover anonymous traits
                user.identify(id, traits);
                var msg = this.normalize({
                    options: options,
                    traits: user.traits(),
                    userId: user.id()
                });
                // Add the initialize integrations so the server-side ones can be disabled too
                // emit
                return this.options.integrations && defaults(msg.integrations, this.options.integrations), 
                this._invoke("identify", new Identify(msg)), this.emit("identify", id, traits, options), 
                this._callback(fn), this;
            }, /**
 * Return the current user.
 *
 * @return {Object}
 */
            Analytics.prototype.user = function() {
                return user;
            }, /**
 * Identify a group by optional `id` and `traits`. Or, if no arguments are
 * supplied, return the current group.
 *
 * @param {string} [id=group.id()] Group ID.
 * @param {Object} [traits=null] Group traits.
 * @param {Object} [options=null]
 * @param {Function} [fn]
 * @return {Analytics|Object}
 */
            Analytics.prototype.group = function(id, traits, options, fn) {
                /* eslint-disable no-unused-expressions, no-sequences */
                if (!arguments.length) return group;
                is.fn(options) && (fn = options, options = null), is.fn(traits) && (fn = traits, 
                options = null, traits = null), is.object(id) && (options = traits, traits = id, 
                id = group.id()), /* eslint-enable no-unused-expressions, no-sequences */
                // grab from group again to make sure we're taking from the source
                group.identify(id, traits);
                var msg = this.normalize({
                    options: options,
                    traits: group.traits(),
                    groupId: group.id()
                });
                // Add the initialize integrations so the server-side ones can be disabled too
                return this.options.integrations && defaults(msg.integrations, this.options.integrations), 
                this._invoke("group", new Group(msg)), this.emit("group", id, traits, options), 
                this._callback(fn), this;
            }, /**
 * Track an `event` that a user has triggered with optional `properties`.
 *
 * @param {string} event
 * @param {Object} [properties=null]
 * @param {Object} [options=null]
 * @param {Function} [fn]
 * @return {Analytics}
 */
            Analytics.prototype.track = function(event, properties, options, fn) {
                // Argument reshuffling.
                /* eslint-disable no-unused-expressions, no-sequences */
                is.fn(options) && (fn = options, options = null), is.fn(properties) && (fn = properties, 
                options = null, properties = null);
                /* eslint-enable no-unused-expressions, no-sequences */
                // figure out if the event is archived.
                var plan = this.options.plan || {}, events = plan.track || {}, planIntegrationOptions = {}, msg = this.normalize({
                    properties: properties,
                    options: options,
                    event: event
                });
                if (// plan.
                plan = events[event]) this.log("plan %o - %o", event, plan), // Disabled events should always be sent to Segment.
                planIntegrationOptions = !1 === plan.enabled ? {
                    All: !1,
                    "Segment.io": !0
                } : plan.integrations || {}; else {
                    (events.__default || {
                        enabled: !0
                    }).enabled || (// Disabled events should always be sent to Segment.
                    planIntegrationOptions = {
                        All: !1,
                        "Segment.io": !0
                    });
                }
                // Add the initialize integrations so the server-side ones can be disabled too
                return defaults(msg.integrations, this._mergeInitializeAndPlanIntegrations(planIntegrationOptions)), 
                this._invoke("track", new Track(msg)), this.emit("track", event, properties, options), 
                this._callback(fn), this;
            }, /**
 * Helper method to track an outbound link that would normally navigate away
 * from the page before the analytics calls were sent.
 *
 * BACKWARDS COMPATIBILITY: aliased to `trackClick`.
 *
 * @param {Element|Array} links
 * @param {string|Function} event
 * @param {Object|Function} properties (optional)
 * @return {Analytics}
 */
            Analytics.prototype.trackClick = Analytics.prototype.trackLink = function(links, event, properties) {
                if (!links) return this;
                // always arrays, handles jquery
                "element" === type(links) && (links = [ links ]);
                var self = this;
                return each(function(el) {
                    if ("element" !== type(el)) throw new TypeError("Must pass HTMLElement to `analytics.trackLink`.");
                    on(el, "click", function(e) {
                        var ev = is.fn(event) ? event(el) : event, props = is.fn(properties) ? properties(el) : properties, href = el.getAttribute("href") || el.getAttributeNS("http://www.w3.org/1999/xlink", "href") || el.getAttribute("xlink:href");
                        self.track(ev, props), href && "_blank" !== el.target && !isMeta(e) && (prevent(e), 
                        self._callback(function() {
                            window.location.href = href;
                        }));
                    });
                }, links), this;
            }, /**
 * Helper method to track an outbound form that would normally navigate away
 * from the page before the analytics calls were sent.
 *
 * BACKWARDS COMPATIBILITY: aliased to `trackSubmit`.
 *
 * @param {Element|Array} forms
 * @param {string|Function} event
 * @param {Object|Function} properties (optional)
 * @return {Analytics}
 */
            Analytics.prototype.trackSubmit = Analytics.prototype.trackForm = function(forms, event, properties) {
                if (!forms) return this;
                // always arrays, handles jquery
                "element" === type(forms) && (forms = [ forms ]);
                var self = this;
                return each(function(el) {
                    function handler(e) {
                        prevent(e);
                        var ev = is.fn(event) ? event(el) : event, props = is.fn(properties) ? properties(el) : properties;
                        self.track(ev, props), self._callback(function() {
                            el.submit();
                        });
                    }
                    if ("element" !== type(el)) throw new TypeError("Must pass HTMLElement to `analytics.trackForm`.");
                    // Support the events happening through jQuery or Zepto instead of through
                    // the normal DOM API, because `el.submit` doesn't bubble up events...
                    var $ = window.jQuery || window.Zepto;
                    $ ? $(el).submit(handler) : on(el, "submit", handler);
                }, forms), this;
            }, /**
 * Trigger a pageview, labeling the current page with an optional `category`,
 * `name` and `properties`.
 *
 * @param {string} [category]
 * @param {string} [name]
 * @param {Object|string} [properties] (or path)
 * @param {Object} [options]
 * @param {Function} [fn]
 * @return {Analytics}
 */
            Analytics.prototype.page = function(category, name, properties, options, fn) {
                // Argument reshuffling.
                /* eslint-disable no-unused-expressions, no-sequences */
                is.fn(options) && (fn = options, options = null), is.fn(properties) && (fn = properties, 
                options = properties = null), is.fn(name) && (fn = name, options = properties = name = null), 
                "object" === type(category) && (options = name, properties = category, name = category = null), 
                "object" === type(name) && (options = properties, properties = name, name = null), 
                "string" === type(category) && "string" !== type(name) && (name = category, category = null), 
                /* eslint-enable no-unused-expressions, no-sequences */
                properties = clone(properties) || {}, name && (properties.name = name), category && (properties.category = category);
                // Ensure properties has baseline spec properties.
                // TODO: Eventually move these entirely to `options.context.page`
                var defs = pageDefaults();
                defaults(properties, defs);
                // Mirror user overrides to `options.context.page` (but exclude custom properties)
                // (Any page defaults get applied in `this.normalize` for consistency.)
                // Weird, yeah--moving special props to `context.page` will fix this in the long term.
                var overrides = pick(keys(defs), properties);
                is.empty(overrides) || (options = options || {}, options.context = options.context || {}, 
                options.context.page = overrides);
                var msg = this.normalize({
                    properties: properties,
                    category: category,
                    options: options,
                    name: name
                });
                // Add the initialize integrations so the server-side ones can be disabled too
                return this.options.integrations && defaults(msg.integrations, this.options.integrations), 
                this._invoke("page", new Page(msg)), this.emit("page", category, name, properties, options), 
                this._callback(fn), this;
            }, /**
 * FIXME: BACKWARDS COMPATIBILITY: convert an old `pageview` to a `page` call.
 *
 * @param {string} [url]
 * @return {Analytics}
 * @api private
 */
            Analytics.prototype.pageview = function(url) {
                var properties = {};
                return url && (properties.path = url), this.page(properties), this;
            }, /**
 * Merge two previously unassociated user identities.
 *
 * @param {string} to
 * @param {string} from (optional)
 * @param {Object} options (optional)
 * @param {Function} fn (optional)
 * @return {Analytics}
 */
            Analytics.prototype.alias = function(to, from, options, fn) {
                // Argument reshuffling.
                /* eslint-disable no-unused-expressions, no-sequences */
                is.fn(options) && (fn = options, options = null), is.fn(from) && (fn = from, options = null, 
                from = null), is.object(from) && (options = from, from = null);
                /* eslint-enable no-unused-expressions, no-sequences */
                var msg = this.normalize({
                    options: options,
                    previousId: from,
                    userId: to
                });
                // Add the initialize integrations so the server-side ones can be disabled too
                return this.options.integrations && defaults(msg.integrations, this.options.integrations), 
                this._invoke("alias", new Alias(msg)), this.emit("alias", to, from, options), this._callback(fn), 
                this;
            }, /**
 * Register a `fn` to be fired when all the analytics services are ready.
 *
 * @param {Function} fn
 * @return {Analytics}
 */
            Analytics.prototype.ready = function(fn) {
                return is.fn(fn) && (this._readied ? nextTick(fn) : this.once("ready", fn)), this;
            }, /**
 * Set the `timeout` (in milliseconds) used for callbacks.
 *
 * @param {Number} timeout
 */
            Analytics.prototype.timeout = function(timeout) {
                this._timeout = timeout;
            }, /**
 * Enable or disable debug.
 *
 * @param {string|boolean} str
 */
            Analytics.prototype.debug = function(str) {
                !arguments.length || str ? debug.enable("analytics:" + (str || "*")) : debug.disable();
            }, /**
 * Apply options.
 *
 * @param {Object} options
 * @return {Analytics}
 * @api private
 */
            Analytics.prototype._options = function(options) {
                return options = options || {}, this.options = options, cookie.options(options.cookie), 
                metrics.options(options.metrics), store.options(options.localStorage), user.options(options.user), 
                group.options(options.group), this;
            }, /**
 * Callback a `fn` after our defined timeout period.
 *
 * @param {Function} fn
 * @return {Analytics}
 * @api private
 */
            Analytics.prototype._callback = function(fn) {
                return is.fn(fn) && (this._timeout ? setTimeout(fn, this._timeout) : nextTick(fn)), 
                this;
            }, /**
 * Call `method` with `facade` on all enabled integrations.
 *
 * @param {string} method
 * @param {Facade} facade
 * @return {Analytics}
 * @api private
 */
            Analytics.prototype._invoke = function(method, facade) {
                function applyIntegrationMiddlewares(facade) {
                    var failedInitializations = self.failedInitializations || [];
                    each(function(integration, name) {
                        var facadeCopy = extend(!0, new Facade({}), facade);
                        if (facadeCopy.enabled(name)) // Check if an integration failed to initialize.
                        // If so, do not process the message as the integration is in an unstable state.
                        if (failedInitializations.indexOf(name) >= 0) self.log("Skipping invocation of .%s method of %s integration. Integration failed to initialize properly.", method, name); else try {
                            // Apply any integration middlewares that exist, then invoke the integration with the result.
                            self._integrationMiddlewares.applyMiddlewares(facadeCopy, integration.name, function(result) {
                                // A nullified payload should not be sent to an integration.
                                if (null === result) return void self.log('Payload to integration "%s" was null and dropped by a middleware.', name);
                                // Check if the payload is still a Facade. If not, convert it to one.
                                result instanceof Facade || (result = new Facade(result)), metrics.increment("analytics_js.integration.invoke", {
                                    method: method,
                                    integration_name: integration.name
                                }), integration.invoke.call(integration, method, result);
                            });
                        } catch (e) {
                            metrics.increment("analytics_js.integration.invoke.error", {
                                method: method,
                                integration_name: integration.name
                            }), self.log("Error invoking .%s method of %s integration: %o", method, name, e);
                        }
                    }, self._integrations);
                }
                var self = this;
                try {
                    this._sourceMiddlewares.applyMiddlewares(extend(!0, new Facade({}), facade), this._integrations, function(result) {
                        // A nullified payload should not be sent.
                        if (null === result) return void self.log('Payload with method "%s" was null and dropped by source a middleware.', method);
                        // Check if the payload is still a Facade. If not, convert it to one.
                        result instanceof Facade || (result = new Facade(result)), self.emit("invoke", result), 
                        metrics.increment("analytics_js.invoke", {
                            method: method
                        }), applyIntegrationMiddlewares(result);
                    });
                } catch (e) {
                    metrics.increment("analytics_js.invoke.error", {
                        method: method
                    }), self.log("Error invoking .%s method of %s integration: %o", method, name, e);
                }
                return this;
            }, /**
 * Push `args`.
 *
 * @param {Array} args
 * @api private
 */
            Analytics.prototype.push = function(args) {
                var method = args.shift();
                this[method] && this[method].apply(this, args);
            }, /**
 * Reset group and user traits and id's.
 *
 * @api public
 */
            Analytics.prototype.reset = function() {
                this.user().logout(), this.group().logout();
            }, /**
 * Parse the query string for callable methods.
 *
 * @param {String} query
 * @return {Analytics}
 * @api private
 */
            Analytics.prototype._parseQuery = function(query) {
                /**
   * Create a shallow copy of an input object containing only the properties
   * whose keys are specified by a prefix, stripped of that prefix
   *
   * @param {String} prefix
   * @param {Object} object
   * @return {Object}
   * @api private
   */
                function pickPrefix(prefix, object) {
                    var sub, length = prefix.length;
                    return foldl(function(acc, val, key) {
                        return key.substr(0, length) === prefix && (sub = key.substr(length), acc[sub] = val), 
                        acc;
                    }, {}, object);
                }
                // Parse querystring to an object
                var q = querystring.parse(query), traits = pickPrefix("ajs_trait_", q), props = pickPrefix("ajs_prop_", q);
                // Trigger based on callable parameters in the URL
                return q.ajs_uid && this.identify(q.ajs_uid, traits), q.ajs_event && this.track(q.ajs_event, props), 
                q.ajs_aid && user.anonymousId(q.ajs_aid), this;
            }, /**
 * Normalize the given `msg`.
 *
 * @param {Object} msg
 * @return {Object}
 */
            Analytics.prototype.normalize = function(msg) {
                // Ensure all outgoing requests include page data in their contexts.
                return msg = normalize(msg, keys(this._integrations)), msg.anonymousId && user.anonymousId(msg.anonymousId), 
                msg.anonymousId = user.anonymousId(), msg.context.page = defaults(msg.context.page || {}, pageDefaults()), 
                msg;
            }, /**
 * Merges the tracking plan and initialization integration options.
 *
 * @param  {Object} planIntegrations Tracking plan integrations.
 * @return {Object}                  The merged integrations.
 */
            Analytics.prototype._mergeInitializeAndPlanIntegrations = function(planIntegrations) {
                // Do nothing if there are no initialization integrations
                if (!this.options.integrations) return planIntegrations;
                // Clone the initialization integrations
                var integrationName, integrations = extend({}, this.options.integrations);
                // Allow the tracking plan to disable integrations that were explicitly
                // enabled on initialization
                !1 === planIntegrations.All && (integrations = {
                    All: !1
                });
                for (integrationName in planIntegrations) planIntegrations.hasOwnProperty(integrationName) && !1 !== this.options.integrations[integrationName] && (integrations[integrationName] = planIntegrations[integrationName]);
                return integrations;
            }, /**
 * No conflict support.
 */
            Analytics.prototype.noConflict = function() {
                return window.analytics = _analytics, this;
            }, /*
 * Exports.
 */
            module.exports = Analytics, module.exports.cookie = cookie, module.exports.memory = memory, 
            module.exports.store = store, module.exports.metrics = metrics;
        }).call(exports, __webpack_require__(17));
    }, /* 161 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Module dependencies.
 */
        var get = __webpack_require__(44);
        /**
 * Add address getters to `proto`.
 *
 * @param {Function} proto
 */
        module.exports = function(proto) {
            function trait(a, b) {
                return function() {
                    var traits = this.traits(), props = this.properties ? this.properties() : {};
                    return get(traits, "address." + a) || get(traits, a) || (b ? get(traits, "address." + b) : null) || (b ? get(traits, b) : null) || get(props, "address." + a) || get(props, a) || (b ? get(props, "address." + b) : null) || (b ? get(props, b) : null);
                };
            }
            proto.zip = trait("postalCode", "zip"), proto.country = trait("country"), proto.street = trait("street"), 
            proto.state = trait("state"), proto.city = trait("city"), proto.region = trait("region");
        };
    }, /* 162 */
    /***/
    function(module, exports) {
        /**
 * toString ref.
 */
        var toString = Object.prototype.toString;
        /**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */
        module.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Function]":
                return "function";

              case "[object Date]":
                return "date";

              case "[object RegExp]":
                return "regexp";

              case "[object Arguments]":
                return "arguments";

              case "[object Array]":
                return "array";
            }
            return null === val ? "null" : void 0 === val ? "undefined" : val === Object(val) ? "object" : typeof val;
        };
    }, /* 163 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * A few integrations are disabled by default. They must be explicitly
 * enabled by setting options[Provider] = true.
 */
        var disabled = {
            Salesforce: !0
        };
        /**
 * Check whether an integration should be enabled by default.
 *
 * @param {string} integration
 * @return {boolean}
 */
        module.exports = function(integration) {
            return !disabled[integration];
        };
    }, /* 164 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Matcher.
 */
        var matcher = /\d{13}/;
        /**
 * Check whether a string is a millisecond date string.
 *
 * @param {string} string
 * @return {boolean}
 */
        exports.is = function(string) {
            return matcher.test(string);
        }, /**
 * Convert a millisecond string to a date.
 *
 * @param {string} millis
 * @return {Date}
 */
        exports.parse = function(millis) {
            return millis = parseInt(millis, 10), new Date(millis);
        };
    }, /* 165 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Matcher.
 */
        var matcher = /\d{10}/;
        /**
 * Check whether a string is a second date string.
 *
 * @param {string} string
 * @return {Boolean}
 */
        exports.is = function(string) {
            return matcher.test(string);
        }, /**
 * Convert a second string to a date.
 *
 * @param {string} seconds
 * @return {Date}
 */
        exports.parse = function(seconds) {
            var millis = 1e3 * parseInt(seconds, 10);
            return new Date(millis);
        };
    }, /* 166 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Convert `obj` to a `Function`.
 *
 * @param {Mixed} obj
 * @return {Function}
 * @api private
 */
        function toFunction(obj) {
            switch ({}.toString.call(obj)) {
              case "[object Object]":
                return objectToFunction(obj);

              case "[object Function]":
                return obj;

              case "[object String]":
                return stringToFunction(obj);

              case "[object RegExp]":
                return regexpToFunction(obj);

              default:
                return defaultToFunction(obj);
            }
        }
        /**
 * Default to strict equality.
 *
 * @param {Mixed} val
 * @return {Function}
 * @api private
 */
        function defaultToFunction(val) {
            return function(obj) {
                return val === obj;
            };
        }
        /**
 * Convert `re` to a function.
 *
 * @param {RegExp} re
 * @return {Function}
 * @api private
 */
        function regexpToFunction(re) {
            return function(obj) {
                return re.test(obj);
            };
        }
        /**
 * Convert property `str` to a function.
 *
 * @param {String} str
 * @return {Function}
 * @api private
 */
        function stringToFunction(str) {
            // immediate such as "> 20"
            // immediate such as "> 20"
            return /^ *\W+/.test(str) ? new Function("_", "return _ " + str) : new Function("_", "return " + get(str));
        }
        /**
 * Convert `object` to a function.
 *
 * @param {Object} object
 * @return {Function}
 * @api private
 */
        function objectToFunction(obj) {
            var match = {};
            for (var key in obj) match[key] = "string" == typeof obj[key] ? defaultToFunction(obj[key]) : toFunction(obj[key]);
            return function(val) {
                if ("object" != typeof val) return !1;
                for (var key in match) {
                    if (!(key in val)) return !1;
                    if (!match[key](val[key])) return !1;
                }
                return !0;
            };
        }
        /**
 * Built the getter function. Supports getter style functions
 *
 * @param {String} str
 * @return {String}
 * @api private
 */
        function get(str) {
            var props = expr(str);
            if (!props.length) return "_." + str;
            var val, i, prop;
            for (i = 0; i < props.length; i++) prop = props[i], val = "_." + prop, val = "('function' == typeof " + val + " ? " + val + "() : " + val + ")", 
            // mimic negative lookbehind to avoid problems with nested properties
            str = stripNested(prop, str, val);
            return str;
        }
        /**
 * Mimic negative lookbehind to avoid problems with nested properties.
 *
 * See: http://blog.stevenlevithan.com/archives/mimic-lookbehind-javascript
 *
 * @param {String} prop
 * @param {String} str
 * @param {String} val
 * @return {String}
 * @api private
 */
        function stripNested(prop, str, val) {
            return str.replace(new RegExp("(\\.)?" + prop, "g"), function($0, $1) {
                return $1 ? $0 : val;
            });
        }
        /**
 * Module Dependencies
 */
        var expr;
        try {
            expr = __webpack_require__(97);
        } catch (e) {
            expr = __webpack_require__(97);
        }
        /**
 * Expose `toFunction()`.
 */
        module.exports = toFunction;
    }, /* 167 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Alias` facade with a `dictionary` of arguments.
 *
 * @param {Object} dictionary
 *   @property {string} from
 *   @property {string} to
 *   @property {Object} options
 * @param {Object} opts
 *   @property {boolean|undefined} clone
 */
        function Alias(dictionary, opts) {
            Facade.call(this, dictionary, opts);
        }
        /**
 * Module dependencies.
 */
        var inherit = __webpack_require__(9).inherit, Facade = __webpack_require__(25);
        /**
 * Inherit from `Facade`.
 */
        inherit(Alias, Facade), /**
 * Return type of facade.
 *
 * @return {string}
 */
        Alias.prototype.action = function() {
            return "alias";
        }, Alias.prototype.type = Alias.prototype.action, /**
 * Get `previousId`.
 *
 * @api public
 * @return {*}
 */
        Alias.prototype.previousId = function() {
            return this.field("previousId") || this.field("from");
        }, Alias.prototype.from = Alias.prototype.previousId, /**
 * Get `userId`.
 *
 * @api public
 * @return {string}
 */
        Alias.prototype.userId = function() {
            return this.field("userId") || this.field("to");
        }, Alias.prototype.to = Alias.prototype.userId, /**
 * Exports.
 */
        module.exports = Alias;
    }, /* 168 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Group` facade with a `dictionary` of arguments.
 *
 * @param {Object} dictionary
 *   @param {string} userId
 *   @param {string} groupId
 *   @param {Object} properties
 *   @param {Object} options
 * @param {Object} opts
 *   @property {boolean|undefined} clone
 */
        function Group(dictionary, opts) {
            Facade.call(this, dictionary, opts);
        }
        /**
 * Module dependencies.
 */
        var inherit = __webpack_require__(9).inherit, isEmail = __webpack_require__(46), newDate = __webpack_require__(67), Facade = __webpack_require__(25);
        /**
 * Inherit from `Facade`
 */
        inherit(Group, Facade), /**
 * Get the facade's action.
 */
        Group.prototype.action = function() {
            return "group";
        }, Group.prototype.type = Group.prototype.action, /**
 * Setup some basic proxies.
 */
        Group.prototype.groupId = Facade.field("groupId"), /**
 * Get created or createdAt.
 *
 * @return {Date}
 */
        Group.prototype.created = function() {
            var created = this.proxy("traits.createdAt") || this.proxy("traits.created") || this.proxy("properties.createdAt") || this.proxy("properties.created");
            if (created) return newDate(created);
        }, /**
 * Get the group's email, falling back to the group ID if it's a valid email.
 *
 * @return {string}
 */
        Group.prototype.email = function() {
            var email = this.proxy("traits.email");
            if (email) return email;
            var groupId = this.groupId();
            return isEmail(groupId) ? groupId : void 0;
        }, /**
 * Get the group's traits.
 *
 * @param {Object} aliases
 * @return {Object}
 */
        Group.prototype.traits = function(aliases) {
            var ret = this.properties(), id = this.groupId();
            aliases = aliases || {}, id && (ret.id = id);
            for (var alias in aliases) {
                var value = null == this[alias] ? this.proxy("traits." + alias) : this[alias]();
                null != value && (ret[aliases[alias]] = value, delete ret[alias]);
            }
            return ret;
        }, /**
 * Special traits.
 */
        Group.prototype.name = Facade.proxy("traits.name"), Group.prototype.industry = Facade.proxy("traits.industry"), 
        Group.prototype.employees = Facade.proxy("traits.employees"), /**
 * Get traits or properties.
 *
 * TODO: remove me
 *
 * @return {Object}
 */
        Group.prototype.properties = function() {
            return this.field("traits") || this.field("properties") || {};
        }, /**
 * Exports.
 */
        module.exports = Group;
    }, /* 169 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize new `Screen` facade with `dictionary`.
 *
 * @param {Object} dictionary
 *   @param {string} category
 *   @param {string} name
 *   @param {Object} traits
 *   @param {Object} options
 * @param {Object} opts
 *   @property {boolean|undefined} clone
 */
        function Screen(dictionary, opts) {
            Page.call(this, dictionary, opts);
        }
        var inherit = __webpack_require__(9).inherit, Page = __webpack_require__(100), Track = __webpack_require__(68);
        /**
 * Inherit from `Page`
 */
        inherit(Screen, Page), /**
 * Get the facade's action.
 *
 * @api public
 * @return {string}
 */
        Screen.prototype.action = function() {
            return "screen";
        }, Screen.prototype.type = Screen.prototype.action, /**
 * Get event with `name`.
 *
 * @api public
 * @param {string} name
 * @return {string}
 */
        Screen.prototype.event = function(name) {
            return name ? "Viewed " + name + " Screen" : "Loaded a Screen";
        }, /**
 * Convert this Screen.
 *
 * @api public
 * @param {string} name
 * @return {Track}
 */
        Screen.prototype.track = function(name) {
            var json = this.json();
            return json.event = this.event(name), json.timestamp = this.timestamp(), json.properties = this.properties(), 
            new Track(json, this.opts);
        }, /**
 * Exports.
 */
        module.exports = Screen;
    }, /* 170 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var hasOwn = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray = function(arr) {
            return "function" == typeof Array.isArray ? Array.isArray(arr) : "[object Array]" === toStr.call(arr);
        }, isPlainObject = function(obj) {
            if (!obj || "[object Object]" !== toStr.call(obj)) return !1;
            var hasOwnConstructor = hasOwn.call(obj, "constructor"), hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
            // Not own constructor property must be Object
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return !1;
            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
            var key;
            for (key in obj) ;
            return void 0 === key || hasOwn.call(obj, key);
        }, setProperty = function(target, options) {
            defineProperty && "__proto__" === options.name ? defineProperty(target, options.name, {
                enumerable: !0,
                configurable: !0,
                value: options.newValue,
                writable: !0
            }) : target[options.name] = options.newValue;
        }, getProperty = function(obj, name) {
            if ("__proto__" === name) {
                if (!hasOwn.call(obj, name)) return;
                if (gOPD) // In early versions of node, obj['__proto__'] is buggy when obj has
                // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
                return gOPD(obj, name).value;
            }
            return obj[name];
        };
        module.exports = function extend() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0], i = 1, length = arguments.length, deep = !1;
            for (// Handle a deep copy situation
            "boolean" == typeof target && (deep = target, target = arguments[1] || {}, // skip the boolean and the target
            i = 2), (null == target || "object" != typeof target && "function" != typeof target) && (target = {}); i < length; ++i) // Only deal with non-null/undefined values
            if (null != (options = arguments[i])) // Extend the base object
            for (name in options) src = getProperty(target, name), copy = getProperty(options, name), 
            // Prevent never-ending loop
            target !== copy && (// Recurse if we're merging plain objects or arrays
            deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
            clone = src && isArray(src) ? src : []) : clone = src && isPlainObject(src) ? src : {}, 
            // Never move original objects, clone them
            setProperty(target, {
                name: name,
                newValue: extend(deep, clone, copy)
            })) : void 0 !== copy && setProperty(target, {
                name: name,
                newValue: copy
            }));
            // Return the modified object
            return target;
        };
    }, /* 171 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */
        function selectColor(namespace) {
            var i, hash = 0;
            for (i in namespace) hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
            return exports.colors[Math.abs(hash) % exports.colors.length];
        }
        /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */
        function createDebug(namespace) {
            function debug() {
                // disabled?
                if (debug.enabled) {
                    var self = debug, curr = +new Date(), ms = curr - (prevTime || curr);
                    self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr;
                    for (var args = new Array(arguments.length), i = 0; i < args.length; i++) args[i] = arguments[i];
                    args[0] = exports.coerce(args[0]), "string" != typeof args[0] && // anything else let's inspect with %O
                    args.unshift("%O");
                    // apply any `formatters` transformations
                    var index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                        // if we encounter an escaped % then don't increase the array index
                        if ("%%" === match) return match;
                        index++;
                        var formatter = exports.formatters[format];
                        if ("function" == typeof formatter) {
                            var val = args[index];
                            match = formatter.call(self, val), // now we need to remove `args[index]` since it's inlined in the `format`
                            args.splice(index, 1), index--;
                        }
                        return match;
                    }), // apply env-specific formatting (colors, etc.)
                    exports.formatArgs.call(self, args);
                    (debug.log || exports.log || console.log.bind(console)).apply(self, args);
                }
            }
            // env-specific initialization logic for debug instances
            return debug.namespace = namespace, debug.enabled = exports.enabled(namespace), 
            debug.useColors = exports.useColors(), debug.color = selectColor(namespace), "function" == typeof exports.init && exports.init(debug), 
            debug;
        }
        /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */
        function enable(namespaces) {
            exports.save(namespaces), exports.names = [], exports.skips = [];
            for (var split = ("string" == typeof namespaces ? namespaces : "").split(/[\s,]+/), len = split.length, i = 0; i < len; i++) split[i] && (// ignore empty strings
            namespaces = split[i].replace(/\*/g, ".*?"), "-" === namespaces[0] ? exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : exports.names.push(new RegExp("^" + namespaces + "$")));
        }
        /**
 * Disable debug output.
 *
 * @api public
 */
        function disable() {
            exports.enable("");
        }
        /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */
        function enabled(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return !1;
            for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return !0;
            return !1;
        }
        /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */
        function coerce(val) {
            return val instanceof Error ? val.stack || val.message : val;
        }
        /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = createDebug.debug = createDebug.default = createDebug, 
        exports.coerce = coerce, exports.disable = disable, exports.enable = enable, exports.enabled = enabled, 
        exports.humanize = __webpack_require__(172), /**
 * The currently active debug mode names, and names to skip.
 */
        exports.names = [], exports.skips = [], /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */
        exports.formatters = {};
        /**
 * Previous log timestamp.
 */
        var prevTime;
    }, /* 172 */
    /***/
    function(module, exports) {
        /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */
        function parse(str) {
            if (str = String(str), !(str.length > 100)) {
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                if (match) {
                    var n = parseFloat(match[1]);
                    switch ((match[2] || "ms").toLowerCase()) {
                      case "years":
                      case "year":
                      case "yrs":
                      case "yr":
                      case "y":
                        return n * y;

                      case "days":
                      case "day":
                      case "d":
                        return n * d;

                      case "hours":
                      case "hour":
                      case "hrs":
                      case "hr":
                      case "h":
                        return n * h;

                      case "minutes":
                      case "minute":
                      case "mins":
                      case "min":
                      case "m":
                        return n * m;

                      case "seconds":
                      case "second":
                      case "secs":
                      case "sec":
                      case "s":
                        return n * s;

                      case "milliseconds":
                      case "millisecond":
                      case "msecs":
                      case "msec":
                      case "ms":
                        return n;

                      default:
                        return;
                    }
                }
            }
        }
        /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function fmtShort(ms) {
            return ms >= d ? Math.round(ms / d) + "d" : ms >= h ? Math.round(ms / h) + "h" : ms >= m ? Math.round(ms / m) + "m" : ms >= s ? Math.round(ms / s) + "s" : ms + "ms";
        }
        /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function fmtLong(ms) {
            return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
        }
        /**
 * Pluralization helper.
 */
        function plural(ms, n, name) {
            if (!(ms < n)) return ms < 1.5 * n ? Math.floor(ms / n) + " " + name : Math.ceil(ms / n) + " " + name + "s";
        }
        /**
 * Helpers.
 */
        var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, y = 365.25 * d;
        /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ("string" === type && val.length > 0) return parse(val);
            if ("number" === type && !1 === isNaN(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
    }, /* 173 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var max = Math.max, drop = function(count, collection) {
            var length = collection ? collection.length : 0;
            if (!length) return [];
            for (var toDrop = max(Number(count) || 0, 0), resultsLength = max(length - toDrop, 0), results = new Array(resultsLength), i = 0; i < resultsLength; i += 1) results[i] = collection[i + toDrop];
            return results;
        };
        /*
 * Exports.
 */
        module.exports = drop;
    }, /* 174 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var max = Math.max, rest = function(collection) {
            if (null == collection || !collection.length) return [];
            for (var results = new Array(max(collection.length - 2, 0)), i = 1; i < collection.length; i += 1) results[i - 1] = collection[i];
            return results;
        };
        /*
 * Exports.
 */
        module.exports = rest;
    }, /* 175 */
    /***/
    function(module, exports) {
        module.exports = function(module) {
            // module.parent = undefined by default
            return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], 
            module.children || (module.children = []), Object.defineProperty(module, "loaded", {
                enumerable: !0,
                get: function() {
                    return module.l;
                }
            }), Object.defineProperty(module, "id", {
                enumerable: !0,
                get: function() {
                    return module.i;
                }
            }), module.webpackPolyfill = 1), module;
        };
    }, /* 176 */
    /***/
    function(module, exports) {
        /* WEBPACK VAR INJECTION */
        (function(__webpack_amd_options__) {
            /* globals __webpack_amd_options__ */
            module.exports = __webpack_amd_options__;
        }).call(exports, {});
    }, /* 177 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function Metrics(options) {
            this.options(options);
        }
        var bindAll = __webpack_require__(23), send = __webpack_require__(105), debug = __webpack_require__(4)("analytics.js:metrics");
        /**
 * Set the metrics options.
 *
 * @param {Object} options
 *   @field {String} host
 *   @field {Number} sampleRate
 *   @field {Number} flushTimer
 */
        Metrics.prototype.options = function(options) {
            if (options = options || {}, this.host = options.host || "api.segment.io/v1", this.sampleRate = options.sampleRate || 0, 
            // disable metrics by default.
            this.flushTimer = options.flushTimer || 3e4, this.maxQueueSize = options.maxQueueSize || 20, 
            this.queue = [], this.sampleRate > 0) {
                var self = this;
                setInterval(function() {
                    self._flush();
                }, this.flushTimer);
            }
        }, /**
 * Increments the counter identified by name and tags by one.
 *
 * @param {String} metric Name of the metric to increment.
 * @param {Object} tags Dimensions associated with the metric.
 */
        Metrics.prototype.increment = function(metric, tags) {
            Math.random() > this.sampleRate || this.queue.length >= this.maxQueueSize || (this.queue.push({
                type: "Counter",
                metric: metric,
                value: 1,
                tags: tags
            }), // Trigger a flush if this is an error metric.
            metric.indexOf("error") > 0 && this._flush());
        }, /**
 * Flush all queued metrics.
 */
        Metrics.prototype._flush = function() {
            var self = this;
            if (!(self.queue.length <= 0)) {
                var payload = {
                    series: this.queue
                }, headers = {
                    "Content-Type": "text/plain"
                };
                self.queue = [], // This endpoint does not support jsonp, so only proceed if the browser
                // supports xhr.
                "xhr" === send.type && send("https://" + this.host + "/m", payload, headers, function(err, res) {
                    debug("sent %O, received %O", payload, [ err, res ]);
                });
            }
        }, /**
 * Expose the metrics singleton.
 */
        module.exports = bindAll(new Metrics()), /**
 * Expose the `Metrics` constructor.
 */
        module.exports.Metrics = Metrics;
    }, /* 178 */
    /***/
    function(module, exports, __webpack_require__) {
        function encode(input) {
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4, output = "", i = 0;
            for (input = utf8Encode(input); i < input.length; ) chr1 = input.charCodeAt(i++), 
            chr2 = input.charCodeAt(i++), chr3 = input.charCodeAt(i++), enc1 = chr1 >> 2, enc2 = (3 & chr1) << 4 | chr2 >> 4, 
            enc3 = (15 & chr2) << 2 | chr3 >> 6, enc4 = 63 & chr3, isNaN(chr2) ? enc3 = enc4 = 64 : isNaN(chr3) && (enc4 = 64), 
            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
            return output;
        }
        var utf8Encode = __webpack_require__(179), keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        module.exports = encode;
    }, /* 179 */
    /***/
    function(module, exports) {
        function encode(string) {
            string = string.replace(/\r\n/g, "\n");
            for (var utftext = "", n = 0; n < string.length; n++) {
                var c = string.charCodeAt(n);
                c < 128 ? utftext += String.fromCharCode(c) : c > 127 && c < 2048 ? (utftext += String.fromCharCode(c >> 6 | 192), 
                utftext += String.fromCharCode(63 & c | 128)) : (utftext += String.fromCharCode(c >> 12 | 224), 
                utftext += String.fromCharCode(c >> 6 & 63 | 128), utftext += String.fromCharCode(63 & c | 128));
            }
            return utftext;
        }
        module.exports = encode;
    }, /* 180 */
    /***/
    function(module, exports) {
        /**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */
        try {
            module.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
        } catch (err) {
            // if XMLHttp support is disabled in IE then it will throw
            // when trying to create
            module.exports = !1;
        }
    }, /* 181 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Noop function.
 */
        function noop() {}
        /**
 * JSONP handler
 *
 * Options:
 *  - param {String} qs parameter (`callback`)
 *  - prefix {String} qs parameter (`__jp`)
 *  - name {String} qs parameter (`prefix` + incr)
 *  - timeout {Number} how long after a timeout error is emitted (`60000`)
 *
 * @param {String} url
 * @param {Object|Function} optional options / callback
 * @param {Function} optional callback
 */
        function jsonp(url, opts, fn) {
            function cleanup() {
                script.parentNode && script.parentNode.removeChild(script), window[id] = noop, timer && clearTimeout(timer);
            }
            function cancel() {
                window[id] && cleanup();
            }
            "function" == typeof opts && (fn = opts, opts = {}), opts || (opts = {});
            var script, timer, prefix = opts.prefix || "__jp", id = opts.name || prefix + count++, param = opts.param || "callback", timeout = null != opts.timeout ? opts.timeout : 6e4, enc = encodeURIComponent, target = document.getElementsByTagName("script")[0] || document.head;
            // add qs component
            // create script
            return timeout && (timer = setTimeout(function() {
                cleanup(), fn && fn(new Error("Timeout"));
            }, timeout)), window[id] = function(data) {
                debug("jsonp got", data), cleanup(), fn && fn(null, data);
            }, url += (~url.indexOf("?") ? "&" : "?") + param + "=" + enc(id), url = url.replace("?&", "?"), 
            debug('jsonp req "%s"', url), script = document.createElement("script"), script.src = url, 
            target.parentNode.insertBefore(script, target), cancel;
        }
        /**
 * Module dependencies
 */
        var debug = __webpack_require__(4)("jsonp");
        /**
 * Module exports.
 */
        module.exports = jsonp;
        /**
 * Callback index.
 */
        var count = 0;
    }, /* 182 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `Group` with `options`.
 *
 * @param {Object} options
 */
        function Group(options) {
            this.defaults = Group.defaults, this.debug = debug, Entity.call(this, options);
        }
        /*
 * Module dependencies.
 */
        var Entity = __webpack_require__(106), bindAll = __webpack_require__(23), debug = __webpack_require__(4)("analytics:group"), inherit = __webpack_require__(66);
        /**
 * Group defaults
 */
        Group.defaults = {
            persist: !0,
            cookie: {
                key: "ajs_group_id"
            },
            localStorage: {
                key: "ajs_group_properties"
            }
        }, /**
 * Inherit `Entity`
 */
        inherit(Group, Entity), /**
 * Expose the group singleton.
 */
        module.exports = bindAll(new Group()), /**
 * Expose the `Group` constructor.
 */
        module.exports.Group = Group;
    }, /* 183 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */
        (function(global) {
            var JSON = __webpack_require__(28);
            module.exports = function() {
                // Store.js
                var storage, store = {}, win = "undefined" != typeof window ? window : global, doc = win.document, localStorageName = "localStorage";
                if (store.disabled = !1, store.version = "1.3.20", store.set = function(key, value) {}, 
                store.get = function(key, defaultVal) {}, store.has = function(key) {
                    return void 0 !== store.get(key);
                }, store.remove = function(key) {}, store.clear = function() {}, store.transact = function(key, defaultVal, transactionFn) {
                    null == transactionFn && (transactionFn = defaultVal, defaultVal = null), null == defaultVal && (defaultVal = {});
                    var val = store.get(key, defaultVal);
                    transactionFn(val), store.set(key, val);
                }, store.getAll = function() {
                    var ret = {};
                    return store.forEach(function(key, val) {
                        ret[key] = val;
                    }), ret;
                }, store.forEach = function() {}, store.serialize = function(value) {
                    return JSON.stringify(value);
                }, store.deserialize = function(value) {
                    if ("string" == typeof value) try {
                        return JSON.parse(value);
                    } catch (e) {
                        return value || void 0;
                    }
                }, // Functions to encapsulate questionable FireFox 3.6.13 behavior
                // when about.config::dom.storage.enabled === false
                // See https://github.com/marcuswestin/store.js/issues#issue/13
                function() {
                    try {
                        return localStorageName in win && win[localStorageName];
                    } catch (err) {
                        return !1;
                    }
                }()) storage = win[localStorageName], store.set = function(key, val) {
                    return void 0 === val ? store.remove(key) : (storage.setItem(key, store.serialize(val)), 
                    val);
                }, store.get = function(key, defaultVal) {
                    var val = store.deserialize(storage.getItem(key));
                    return void 0 === val ? defaultVal : val;
                }, store.remove = function(key) {
                    storage.removeItem(key);
                }, store.clear = function() {
                    storage.clear();
                }, store.forEach = function(callback) {
                    for (var i = 0; i < storage.length; i++) {
                        var key = storage.key(i);
                        callback(key, store.get(key));
                    }
                }; else if (doc && doc.documentElement.addBehavior) {
                    var storageOwner, storageContainer;
                    // Since #userData storage applies only to specific paths, we need to
                    // somehow link our data to a specific path.  We choose /favicon.ico
                    // as a pretty safe option, since all browsers already make a request to
                    // this URL anyway and being a 404 will not hurt us here.  We wrap an
                    // iframe pointing to the favicon in an ActiveXObject(htmlfile) object
                    // (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
                    // since the iframe access rules appear to allow direct access and
                    // manipulation of the document element, even for a 404 page.  This
                    // document can be used instead of the current document (which would
                    // have been limited to the current path) to perform #userData storage.
                    try {
                        storageContainer = new ActiveXObject("htmlfile"), storageContainer.open(), storageContainer.write('<script>document.w=window<\/script><iframe src="/favicon.ico"></iframe>'), 
                        storageContainer.close(), storageOwner = storageContainer.w.frames[0].document, 
                        storage = storageOwner.createElement("div");
                    } catch (e) {
                        // somehow ActiveXObject instantiation failed (perhaps some special
                        // security settings or otherwse), fall back to per-path storage
                        storage = doc.createElement("div"), storageOwner = doc.body;
                    }
                    var withIEStorage = function(storeFunction) {
                        return function() {
                            var args = Array.prototype.slice.call(arguments, 0);
                            args.unshift(storage), // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
                            // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
                            storageOwner.appendChild(storage), storage.addBehavior("#default#userData"), storage.load(localStorageName);
                            var result = storeFunction.apply(store, args);
                            return storageOwner.removeChild(storage), result;
                        };
                    }, forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g"), ieKeyFix = function(key) {
                        return key.replace(/^d/, "___$&").replace(forbiddenCharsRegex, "___");
                    };
                    store.set = withIEStorage(function(storage, key, val) {
                        return key = ieKeyFix(key), void 0 === val ? store.remove(key) : (storage.setAttribute(key, store.serialize(val)), 
                        storage.save(localStorageName), val);
                    }), store.get = withIEStorage(function(storage, key, defaultVal) {
                        key = ieKeyFix(key);
                        var val = store.deserialize(storage.getAttribute(key));
                        return void 0 === val ? defaultVal : val;
                    }), store.remove = withIEStorage(function(storage, key) {
                        key = ieKeyFix(key), storage.removeAttribute(key), storage.save(localStorageName);
                    }), store.clear = withIEStorage(function(storage) {
                        var attributes = storage.XMLDocument.documentElement.attributes;
                        storage.load(localStorageName);
                        for (var i = attributes.length - 1; i >= 0; i--) storage.removeAttribute(attributes[i].name);
                        storage.save(localStorageName);
                    }), store.forEach = withIEStorage(function(storage, callback) {
                        for (var attr, attributes = storage.XMLDocument.documentElement.attributes, i = 0; attr = attributes[i]; ++i) callback(attr.name, store.deserialize(storage.getAttribute(attr.name)));
                    });
                }
                try {
                    var testKey = "__storejs__";
                    store.set(testKey, testKey), store.get(testKey) != testKey && (store.disabled = !0), 
                    store.remove(testKey);
                } catch (e) {
                    store.disabled = !0;
                }
                return store.enabled = !store.disabled, store;
            }();
        }).call(exports, __webpack_require__(17));
    }, /* 184 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function isMeta(e) {
            if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return !0;
            // Logic that handles checks for the middle mouse button, based
            // on [jQuery](https://github.com/jquery/jquery/blob/master/src/event.js#L466).
            var which = e.which, button = e.button;
            return which || void 0 === button ? 2 === which : 1 & !button && 2 & !button && 4 & button;
        }
        /*
 * Exports.
 */
        module.exports = isMeta;
    }, /* 185 */
    /***/
    function(module, exports, __webpack_require__) {
        function Timeout(id, clearFn) {
            this._id = id, this._clearFn = clearFn;
        }
        var apply = Function.prototype.apply;
        // DOM APIs, for completeness
        exports.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
        }, exports.setInterval = function() {
            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
        }, exports.clearTimeout = exports.clearInterval = function(timeout) {
            timeout && timeout.close();
        }, Timeout.prototype.unref = Timeout.prototype.ref = function() {}, Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id);
        }, // Does not start the time, just sets up the members needed.
        exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs;
        }, exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId), item._idleTimeout = -1;
        }, exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            msecs >= 0 && (item._idleTimeoutId = setTimeout(function() {
                item._onTimeout && item._onTimeout();
            }, msecs));
        }, // setimmediate attaches itself to the global object
        __webpack_require__(186);
        var global = __webpack_require__(187);
        exports.setImmediate = global.setImmediate, exports.clearImmediate = global.clearImmediate;
    }, /* 186 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(global, process) {
            !function(global, undefined) {
                "use strict";
                function setImmediate(callback) {
                    // Callback can either be a function or a string
                    "function" != typeof callback && (callback = new Function("" + callback));
                    for (var args = new Array(arguments.length - 1), i = 0; i < args.length; i++) args[i] = arguments[i + 1];
                    // Store and register the task
                    var task = {
                        callback: callback,
                        args: args
                    };
                    return tasksByHandle[nextHandle] = task, registerImmediate(nextHandle), nextHandle++;
                }
                function clearImmediate(handle) {
                    delete tasksByHandle[handle];
                }
                function run(task) {
                    var callback = task.callback, args = task.args;
                    switch (args.length) {
                      case 0:
                        callback();
                        break;

                      case 1:
                        callback(args[0]);
                        break;

                      case 2:
                        callback(args[0], args[1]);
                        break;

                      case 3:
                        callback(args[0], args[1], args[2]);
                        break;

                      default:
                        callback.apply(undefined, args);
                    }
                }
                function runIfPresent(handle) {
                    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                    // So if we're currently running a task, we'll need to delay this invocation.
                    if (currentlyRunningATask) // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                    // "too much recursion" error.
                    setTimeout(runIfPresent, 0, handle); else {
                        var task = tasksByHandle[handle];
                        if (task) {
                            currentlyRunningATask = !0;
                            try {
                                run(task);
                            } finally {
                                clearImmediate(handle), currentlyRunningATask = !1;
                            }
                        }
                    }
                }
                if (!global.setImmediate) {
                    var registerImmediate, nextHandle = 1, tasksByHandle = {}, currentlyRunningATask = !1, doc = global.document, attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
                    attachTo = attachTo && attachTo.setTimeout ? attachTo : global, // Don't get fooled by e.g. browserify environments.
                    "[object process]" === {}.toString.call(global.process) ? // For Node.js before 0.9
                    function() {
                        registerImmediate = function(handle) {
                            process.nextTick(function() {
                                runIfPresent(handle);
                            });
                        };
                    }() : function() {
                        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
                        // where `global.postMessage` means something completely different and can't be used for this purpose.
                        if (global.postMessage && !global.importScripts) {
                            var postMessageIsAsynchronous = !0, oldOnMessage = global.onmessage;
                            return global.onmessage = function() {
                                postMessageIsAsynchronous = !1;
                            }, global.postMessage("", "*"), global.onmessage = oldOnMessage, postMessageIsAsynchronous;
                        }
                    }() ? // For non-IE10 modern browsers
                    function() {
                        // Installs an event handler on `global` for the `message` event: see
                        // * https://developer.mozilla.org/en/DOM/window.postMessage
                        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
                        var messagePrefix = "setImmediate$" + Math.random() + "$", onGlobalMessage = function(event) {
                            event.source === global && "string" == typeof event.data && 0 === event.data.indexOf(messagePrefix) && runIfPresent(+event.data.slice(messagePrefix.length));
                        };
                        global.addEventListener ? global.addEventListener("message", onGlobalMessage, !1) : global.attachEvent("onmessage", onGlobalMessage), 
                        registerImmediate = function(handle) {
                            global.postMessage(messagePrefix + handle, "*");
                        };
                    }() : global.MessageChannel ? // For web workers, where supported
                    function() {
                        var channel = new MessageChannel();
                        channel.port1.onmessage = function(event) {
                            runIfPresent(event.data);
                        }, registerImmediate = function(handle) {
                            channel.port2.postMessage(handle);
                        };
                    }() : doc && "onreadystatechange" in doc.createElement("script") ? // For IE 68
                    function() {
                        var html = doc.documentElement;
                        registerImmediate = function(handle) {
                            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                            var script = doc.createElement("script");
                            script.onreadystatechange = function() {
                                runIfPresent(handle), script.onreadystatechange = null, html.removeChild(script), 
                                script = null;
                            }, html.appendChild(script);
                        };
                    }() : // For older browsers
                    function() {
                        registerImmediate = function(handle) {
                            setTimeout(runIfPresent, 0, handle);
                        };
                    }(), attachTo.setImmediate = setImmediate, attachTo.clearImmediate = clearImmediate;
                }
            }("undefined" == typeof self ? void 0 === global ? this : global : self);
        }).call(exports, __webpack_require__(17), __webpack_require__(69));
    }, /* 187 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(global) {
            var win;
            win = "undefined" != typeof window ? window : void 0 !== global ? global : "undefined" != typeof self ? self : {}, 
            module.exports = win;
        }).call(exports, __webpack_require__(17));
    }, /* 188 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Normalize `msg` based on integrations `list`.
 *
 * @param {Object} msg
 * @param {Array} list
 * @return {Function}
 */
        function normalize(msg, list) {
            function integration(name) {
                return !(!includes(name, list) && "all" !== name.toLowerCase() && !includes(name.toLowerCase(), lower));
            }
            var lower = map(function(s) {
                return s.toLowerCase();
            }, list), opts = msg.options || {}, integrations = opts.integrations || {}, providers = opts.providers || {}, context = opts.context || {}, ret = {};
            // integrations.
            // providers.
            // move all toplevel options to msg
            // and the rest to context.
            // generate and attach a messageId to msg
            // cleanup
            return debug("<-", msg), each(function(value, key) {
                integration(key) && (has.call(integrations, key) || (integrations[key] = value), 
                delete opts[key]);
            }, opts), delete opts.providers, each(function(value, key) {
                integration(key) && "object" !== type(integrations[key]) && (has.call(integrations, key) && "boolean" == typeof providers[key] || (integrations[key] = value));
            }, providers), each(function(value, key) {
                includes(key, toplevel) ? ret[key] = opts[key] : context[key] = opts[key];
            }, opts), msg.messageId = "ajs-" + md5(json.stringify(msg) + uuid()), delete msg.options, 
            ret.integrations = integrations, ret.context = context, ret = defaults(ret, msg), 
            debug("->", ret), ret;
        }
        /**
 * Module Dependencies.
 */
        var debug = __webpack_require__(4)("analytics.js:normalize"), defaults = __webpack_require__(27), each = __webpack_require__(5), includes = __webpack_require__(73), map = __webpack_require__(189), type = __webpack_require__(22), uuid = __webpack_require__(74).v4, json = __webpack_require__(28), md5 = __webpack_require__(108).hash, has = Object.prototype.hasOwnProperty;
        /**
 * Expose `normalize`
 */
        module.exports = normalize;
        /**
 * Toplevel properties.
 */
        var toplevel = [ "integrations", "anonymousId", "timestamp", "context" ];
    }, /* 189 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var each = __webpack_require__(5), map = function(iterator, collection) {
            if ("function" != typeof iterator) throw new TypeError("Expected a function but received a " + typeof iterator);
            var result = [];
            return each(function(val, i, collection) {
                result.push(iterator(val, i, collection));
            }, collection), result;
        };
        /*
 * Exports.
 */
        module.exports = map;
    }, /* 190 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(global) {
            var rng, crypto = global.crypto || global.msCrypto;
            // for IE 11
            if (crypto && crypto.getRandomValues) {
                // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
                // Moderately fast, high quality
                var _rnds8 = new Uint8Array(16);
                rng = function() {
                    return crypto.getRandomValues(_rnds8), _rnds8;
                };
            }
            if (!rng) {
                // Math.random()-based (RNG)
                //
                // If all else fails, use Math.random().  It's fast, but is of unspecified
                // quality.
                var _rnds = new Array(16);
                rng = function() {
                    for (var r, i = 0; i < 16; i++) 0 == (3 & i) && (r = 4294967296 * Math.random()), 
                    _rnds[i] = r >>> ((3 & i) << 3) & 255;
                    return _rnds;
                };
            }
            module.exports = rng;
        }).call(exports, __webpack_require__(17));
    }, /* 191 */
    /***/
    function(module, exports) {
        var bind = window.addEventListener ? "addEventListener" : "attachEvent", unbind = window.removeEventListener ? "removeEventListener" : "detachEvent", prefix = "addEventListener" !== bind ? "on" : "";
        /**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */
        exports.bind = function(el, type, fn, capture) {
            return el[bind](prefix + type, fn, capture || !1), fn;
        }, /**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */
        exports.unbind = function(el, type, fn, capture) {
            return el[unbind](prefix + type, fn, capture || !1), fn;
        };
    }, /* 192 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Return a default `options.context.page` object.
 *
 * https://segment.com/docs/spec/page/#properties
 *
 * @return {Object}
 */
        function pageDefaults() {
            return {
                path: canonicalPath(),
                referrer: document.referrer,
                search: location.search,
                title: document.title,
                url: canonicalUrl(location.search)
            };
        }
        /**
 * Return the canonical path for the page.
 *
 * @return {string}
 */
        function canonicalPath() {
            var canon = canonical();
            return canon ? url.parse(canon).pathname : window.location.pathname;
        }
        /**
 * Return the canonical URL for the page concat the given `search`
 * and strip the hash.
 *
 * @param {string} search
 * @return {string}
 */
        function canonicalUrl(search) {
            var canon = canonical();
            if (canon) return includes("?", canon) ? canon : canon + search;
            var url = window.location.href, i = url.indexOf("#");
            return -1 === i ? url : url.slice(0, i);
        }
        /*
 * Module dependencies.
 */
        var canonical = __webpack_require__(193), includes = __webpack_require__(73), url = __webpack_require__(104);
        /*
 * Exports.
 */
        module.exports = pageDefaults;
    }, /* 193 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Get the current page's canonical URL.
 *
 * @return {string|undefined}
 */
        function canonical() {
            // eslint-disable-next-line no-cond-assign
            for (var tag, tags = document.getElementsByTagName("link"), i = 0; tag = tags[i]; i++) if ("canonical" === tag.getAttribute("rel")) return tag.getAttribute("href");
        }
        /*
 * Exports.
 */
        module.exports = canonical;
    }, /* 194 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var objToString = Object.prototype.toString, existy = function(val) {
            return null != val;
        }, isArray = function(val) {
            return "[object Array]" === objToString.call(val);
        }, isString = function(val) {
            return "string" == typeof val || "[object String]" === objToString.call(val);
        }, isObject = function(val) {
            return null != val && "object" == typeof val;
        }, pick = function(props, object) {
            if (!existy(object) || !isObject(object)) return {};
            isString(props) && (props = [ props ]), isArray(props) || (props = []);
            for (var result = {}, i = 0; i < props.length; i += 1) isString(props[i]) && props[i] in object && (result[props[i]] = object[props[i]]);
            return result;
        };
        /*
 * Exports.
 */
        module.exports = pick;
    }, /* 195 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Prevent default on a given event.
 *
 * @param {Event} e
 * @example
 * anchor.onclick = prevent;
 * anchor.onclick = function(e){
 *   if (something) return prevent(e);
 * };
 */
        function preventDefault(e) {
            return e = e || window.event, e.preventDefault ? e.preventDefault() : e.returnValue = !1;
        }
        /*
 * Exports.
 */
        module.exports = preventDefault;
    }, /* 196 */
    /***/
    function(module, exports) {
        /**
 * toString ref.
 */
        var toString = Object.prototype.toString;
        /**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */
        module.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Date]":
                return "date";

              case "[object RegExp]":
                return "regexp";

              case "[object Arguments]":
                return "arguments";

              case "[object Array]":
                return "array";

              case "[object Error]":
                return "error";
            }
            return null === val ? "null" : void 0 === val ? "undefined" : val !== val ? "nan" : val && 1 === val.nodeType ? "element" : typeof (val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val));
        };
    }, /* 197 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Initialize a new `User` with `options`.
 *
 * @param {Object} options
 */
        function User(options) {
            this.defaults = User.defaults, this.debug = debug, Entity.call(this, options);
        }
        /*
 * Module dependencies.
 */
        var Entity = __webpack_require__(106), bindAll = __webpack_require__(23), cookie = __webpack_require__(48), debug = __webpack_require__(4)("analytics:user"), inherit = __webpack_require__(66), rawCookie = __webpack_require__(49), uuid = __webpack_require__(74), localStorage = __webpack_require__(72);
        /**
 * User defaults
 */
        User.defaults = {
            persist: !0,
            cookie: {
                key: "ajs_user_id",
                oldKey: "ajs_user"
            },
            localStorage: {
                key: "ajs_user_traits"
            }
        }, /**
 * Inherit `Entity`
 */
        inherit(User, Entity), /**
 * Set/get the user id.
 *
 * When the user id changes, the method will reset his anonymousId to a new one.
 *
 * // FIXME: What are the mixed types?
 * @param {string} id
 * @return {Mixed}
 * @example
 * // didn't change because the user didn't have previous id.
 * anonymousId = user.anonymousId();
 * user.id('foo');
 * assert.equal(anonymousId, user.anonymousId());
 *
 * // didn't change because the user id changed to null.
 * anonymousId = user.anonymousId();
 * user.id('foo');
 * user.id(null);
 * assert.equal(anonymousId, user.anonymousId());
 *
 * // change because the user had previous id.
 * anonymousId = user.anonymousId();
 * user.id('foo');
 * user.id('baz'); // triggers change
 * user.id('baz'); // no change
 * assert.notEqual(anonymousId, user.anonymousId());
 */
        User.prototype.id = function(id) {
            var prev = this._getId(), ret = Entity.prototype.id.apply(this, arguments);
            // FIXME: We're relying on coercion here (1 == "1"), but our API treats these
            // two values differently. Figure out what will break if we remove this and
            // change to strict equality
            /* eslint-disable eqeqeq */
            return null == prev ? ret : (prev != id && id && this.anonymousId(null), ret);
        }, /**
 * Set / get / remove anonymousId.
 *
 * @param {String} anonymousId
 * @return {String|User}
 */
        User.prototype.anonymousId = function(anonymousId) {
            var store = this.storage();
            // set / remove
            // set / remove
            // new
            // value exists in cookie, copy it to localStorage
            // refresh cookie to extend expiry
            // if anonymousId doesn't exist in cookies, check localStorage
            // Write to cookies if available in localStorage but not cookies
            // old - it is not stringified so we use the raw cookie.
            // empty
            return arguments.length ? (store.set("ajs_anonymous_id", anonymousId), this._setAnonymousIdInLocalStorage(anonymousId), 
            this) : (anonymousId = store.get("ajs_anonymous_id")) ? (this._setAnonymousIdInLocalStorage(anonymousId), 
            store.set("ajs_anonymous_id", anonymousId), anonymousId) : !this._options.localStorageFallbackDisabled && (anonymousId = localStorage.get("ajs_anonymous_id")) ? (store.set("ajs_anonymous_id", anonymousId), 
            anonymousId) : (anonymousId = rawCookie("_sio")) ? (anonymousId = anonymousId.split("----")[0], 
            store.set("ajs_anonymous_id", anonymousId), this._setAnonymousIdInLocalStorage(anonymousId), 
            store.remove("_sio"), anonymousId) : (anonymousId = uuid.v4(), store.set("ajs_anonymous_id", anonymousId), 
            this._setAnonymousIdInLocalStorage(anonymousId), store.get("ajs_anonymous_id"));
        }, /**
 * Set the user's `anonymousid` in local storage.
 *
 * @param {String} id
 */
        User.prototype._setAnonymousIdInLocalStorage = function(id) {
            this._options.localStorageFallbackDisabled || localStorage.set("ajs_anonymous_id", id);
        }, /**
 * Remove anonymous id on logout too.
 */
        User.prototype.logout = function() {
            Entity.prototype.logout.call(this), this.anonymousId(null);
        }, /**
 * Load saved user `id` or `traits` from storage.
 */
        User.prototype.load = function() {
            this._loadOldCookie() || Entity.prototype.load.call(this);
        }, /**
 * BACKWARDS COMPATIBILITY: Load the old user from the cookie.
 *
 * @api private
 * @return {boolean}
 */
        User.prototype._loadOldCookie = function() {
            var user = cookie.get(this._options.cookie.oldKey);
            return !!user && (this.id(user.id), this.traits(user.traits), cookie.remove(this._options.cookie.oldKey), 
            !0);
        }, /**
 * Expose the user singleton.
 */
        module.exports = bindAll(new User()), /**
 * Expose the `User` constructor.
 */
        module.exports.User = User;
    }, /* 198 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        /**
 * getTld
 * Get domain.com from subdomain.domain.com, etc.
 * @param {string} domain
 * @return {string} tld
 */
        function getTld(domain) {
            return domain.split(".").splice(-2).join(".");
        }
        /**
 * getJson
 * @param {string} url
 * @param {function} callback => err, json
 */
        function getJson(url, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, !0), xhr.withCredentials = !0, xhr.onreadystatechange = function() {
                xhr.readyState === XMLHttpRequest.DONE && (xhr.status >= 200 && xhr.status < 300 ? callback(null, xhr.responseText ? json.parse(xhr.responseText) : null) : callback(xhr.statusText || "Unknown Error", null));
            }, xhr.send();
        }
        /**
 * getCrossDomainId
 * @param {Array} domain
 * @param {string} writeKey
 * @param {function} callback => err, {domain, id}
 */
        function getCrossDomainIdFromSingleServer(domain, writeKey, callback) {
            getJson("https://" + domain + "/v1/id/" + writeKey, function(err, res) {
                err ? callback(err, null) : callback(null, {
                    domain: domain,
                    id: res && res.id || null
                });
            });
        }
        /**
 * getCrossDomainIdFromServers
 * @param {Array} domains
 * @param {string} writeKey
 * @param {function} callback => err, {domain, id}
 */
        function getCrossDomainIdFromServerList(domains, writeKey, callback) {
            // Should not happen but special case
            0 === domains.length && callback(null, null);
            var crossDomainIdFound = !1, finishedRequests = 0, error = null;
            domains.forEach(function(domain) {
                getCrossDomainIdFromSingleServer(domain, writeKey, function(err, res) {
                    finishedRequests++, err ? // if request against a particular domain fails, we won't early exit
                    // but rather wait and see if requests to other domains succeed
                    error = err : res && res.id && !crossDomainIdFound && (// If we found an xid from any of the servers, we'll just early exit and callback
                    crossDomainIdFound = !0, callback(null, res)), finishedRequests !== domains.length || crossDomainIdFound || // Error is non-null if we encountered an issue, otherwise error will be null
                    // meaning that no domains in the list has an xid for current user
                    callback(error, null);
                });
            });
        }
        var _slicedToArray2 = __webpack_require__(199), _slicedToArray3 = _interopRequireDefault(_slicedToArray2), _entries = __webpack_require__(206), _entries2 = _interopRequireDefault(_entries), ads = __webpack_require__(209), clone = __webpack_require__(210), cookie = __webpack_require__(49), extend = __webpack_require__(71), integration = __webpack_require__(111), json = __webpack_require__(28), keys = __webpack_require__(33), localstorage = __webpack_require__(223), md5 = __webpack_require__(108).hash, protocol = __webpack_require__(225), send = __webpack_require__(105), topDomain = __webpack_require__(103), utm = __webpack_require__(226), uuid = __webpack_require__(74).v4, Queue = __webpack_require__(113), BatchableQueue = __webpack_require__(231).default, cookieOptions = {
            // 1 year
            maxage: 31536e6,
            secure: !1,
            path: "/"
        }, defaultQueueOptions = {
            maxRetryDelay: 36e4,
            // max interval of 1hr. Added as a guard.
            minRetryDelay: 1e3,
            // first attempt (1s)
            backoffFactor: 2,
            maxAttempts: 10,
            maxItems: 100
        }, Segment = integration("Segment.io").option("apiKey", "").option("apiScheme", "https").option("apiHost", "api.segment.io/v1").option("crossDomainIdServers", []).option("retryQueue", !0).option("retryQueuePrefix", "awc").option("addBundledMetadata", !1).option("unbundledIntegrations", []).option("retryQueueOptions", defaultQueueOptions).option("useBatchQueue", !1).option("requestTimeout", 1e4);
        exports = Segment, module.exports = Segment, /**
 * Get the store.
 *
 * @return {Function}
 */
        exports.storage = function() {
            return "file:" === protocol() || "chrome-extension:" === protocol() ? localstorage : cookie;
        }, /**
 * Expose global for testing.
 */
        exports.global = window, /**
 * Send the given `obj` and `headers` to `url` with the specified `timeout` and
 * `fn(err, req)`. Exported for testing.
 *
 * @param {String} url
 * @param {Object} obj
 * @param {Object} headers
 * @param {long} timeout
 * @param {Function} fn
 * @api private
 */
        exports.sendJsonWithTimeout = function(url, obj, headers, timeout, fn) {
            function done() {
                4 === req.readyState && (// Fail on 429 and 5xx HTTP errors
                429 === req.status || req.status >= 500 && req.status < 600 ? fn(new Error("HTTP Error " + req.status + " (" + req.statusText + ")")) : fn(null, req));
            }
            // only proceed with our new code path when cors is supported. this is
            // unlikely to happen in production, but we're being safe to preserve backward
            // compatibility.
            if ("xhr" !== send.type) return void send(url, obj, headers, fn);
            var req = new XMLHttpRequest();
            req.onerror = fn, req.onreadystatechange = done, req.withCredentials = !0, req.open("POST", url, !0), 
            req.timeout = timeout, req.ontimeout = fn, // TODO: Remove this eslint disable
            // eslint-disable-next-line guard-for-in
            (0, _entries2.default)(headers).forEach(function(_ref) {
                var _ref2 = (0, _slicedToArray3.default)(_ref, 2), key = _ref2[0], value = _ref2[1];
                req.setRequestHeader(key, value);
            }), req.send(json.stringify(obj));
        }, Segment.prototype.proccessSingleItem = function(item, done) {
            var self = this;
            item.msg.sentAt = new Date(), // send with 10s timeout
            Segment.sendJsonWithTimeout(item.url, item.msg, item.headers, this.options.requestTimeout, function(err, res) {
                return self.debug("sent %O, received %O", item.msg, [ err, res ]), err ? done(err) : done(null, res);
            });
        }, Segment.prototype.proccessBatchItems = function(items, done) {
            var self = this;
            if (1 === items.length) return this.proccessSingleItem(items[0], done);
            var sentAt = new Date().toISOString(), batchItems = items.map(function(item) {
                return item.msg.sentAt = sentAt, item.msg;
            }), batchObj = {
                batch: batchItems,
                sentAt: sentAt
            }, url = this.options.apiScheme + "://" + this.options.apiHost + "/batch", headers = {
                "Content-Type": "text/plain"
            };
            // send with 10s timeout
            return Segment.sendJsonWithTimeout(url, batchObj, headers, this.options.requestTimeout, function(err, res) {
                return self.debug("sent %O, received %O", batchObj, [ err, res ]), err ? done(err) : done(null, res);
            });
        }, /**
 * Initialize.
 *
 * https://github.com/segmentio/segmentio/blob/master/modules/segmentjs/segment.js/v1/segment.js
 *
 * @api public
 */
        Segment.prototype.initialize = function() {
            var self = this;
            this.options.retryQueue && (this.options.useBatchQueue ? this._lsqueue = new BatchableQueue(this.options.retryQueuePrefix, this.options.retryQueueOptions, this.proccessBatchItems.bind(this)) : this._lsqueue = new Queue(this.options.retryQueuePrefix, this.options.retryQueueOptions, this.proccessSingleItem.bind(this)), 
            this._lsqueue.start()), this.ready(), this.analytics.on("invoke", function(msg) {
                var action = msg.action(), listener = "on" + msg.action();
                self.debug("%s %o", action, msg), self[listener] && self[listener](msg), self.ready();
            }), // Migrate from old cross domain id cookie names
            this.cookie("segment_cross_domain_id") && (this.cookie("seg_xid", this.cookie("segment_cross_domain_id")), 
            this.cookie("seg_xid_fd", this.cookie("segment_cross_domain_id_from_domain")), this.cookie("seg_xid_ts", this.cookie("segment_cross_domain_id_timestamp")), 
            this.cookie("segment_cross_domain_id", null), this.cookie("segment_cross_domain_id_from_domain", null), 
            this.cookie("segment_cross_domain_id_timestamp", null)), // At this moment we intentionally do not want events to be queued while we retrieve the `crossDomainId`
            // so `.ready` will get called right away and we'll try to figure out `crossDomainId`
            // separately
            this.options.crossDomainIdServers && this.options.crossDomainIdServers.length > 0 && this.retrieveCrossDomainId();
        }, /**
 * Loaded.
 *
 * @api private
 * @return {boolean}
 */
        Segment.prototype.loaded = function() {
            return !0;
        }, /**
 * Page.
 *
 * @api public
 * @param {Page} page
 */
        Segment.prototype.onpage = function(page) {
            this.enqueue("/p", page.json());
        }, /**
 * Identify.
 *
 * @api public
 * @param {Identify} identify
 */
        Segment.prototype.onidentify = function(identify) {
            this.enqueue("/i", identify.json());
        }, /**
 * Group.
 *
 * @api public
 * @param {Group} group
 */
        Segment.prototype.ongroup = function(group) {
            this.enqueue("/g", group.json());
        }, /**
 * ontrack.
 *
 * TODO: Document this.
 *
 * @api private
 * @param {Track} track
 */
        Segment.prototype.ontrack = function(track) {
            var trackJSON = track.json();
            // TODO: figure out why we need traits.
            delete trackJSON.traits, this.enqueue("/t", trackJSON);
        }, /**
 * Alias.
 *
 * @api public
 * @param {Alias} alias
 */
        Segment.prototype.onalias = function(alias) {
            var aliasJSON = alias.json(), user = this.analytics.user();
            aliasJSON.previousId = aliasJSON.previousId || aliasJSON.from || user.id() || user.anonymousId(), 
            aliasJSON.userId = aliasJSON.userId || aliasJSON.to, delete aliasJSON.from, delete aliasJSON.to, 
            this.enqueue("/a", aliasJSON);
        }, /**
 * Normalize the given `msg`.
 *
 * @api private
 * @param {Object} msg
 */
        Segment.prototype.normalize = function(msg) {
            this.debug("normalize %o", msg);
            var user = this.analytics.user(), global = exports.global, query = global.location.search;
            msg.context = msg.context || msg.options || {};
            var ctx = msg.context;
            delete msg.options, msg.writeKey = this.options.apiKey, ctx.userAgent = navigator.userAgent, 
            ctx.library || (ctx.library = {
                name: "analytics.js",
                version: this.analytics.VERSION
            });
            var crossDomainId = this.cookie("seg_xid");
            crossDomainId && (ctx.traits ? ctx.traits.crossDomainId || (ctx.traits.crossDomainId = crossDomainId) : ctx.traits = {
                crossDomainId: crossDomainId
            }), // if user provides campaign via context, do not overwrite with UTM qs param
            query && !ctx.campaign && (ctx.campaign = utm(query)), this.referrerId(query, ctx), 
            msg.userId = msg.userId || user.id(), msg.anonymousId = user.anonymousId(), msg.sentAt = new Date();
            // Add _metadata.
            var failedInitializations = this.analytics.failedInitializations || [];
            if (/* eslint-disable no-underscore-dangle */
            failedInitializations.length > 0 && (msg._metadata = {
                failedInitializations: failedInitializations
            }), this.options.addBundledMetadata) {
                var bundled = keys(this.analytics.Integrations);
                msg._metadata = msg._metadata || {}, msg._metadata.bundled = bundled, msg._metadata.unbundled = this.options.unbundledIntegrations;
            }
            /* eslint-enable no-underscore-dangle */
            // add some randomness to the messageId checksum
            return msg.messageId = "ajs-" + md5(json.stringify(msg) + uuid()), this.debug("normalized %o", msg), 
            this.ampId(ctx), msg;
        }, /**
 * Add amp id if it exists.
 *
 * @param {Object} ctx
 */
        Segment.prototype.ampId = function(ctx) {
            var ampId = this.cookie("segment_amp_id");
            ampId && (ctx.amp = {
                id: ampId
            });
        }, /**
 * Send `obj` to `path`.
 *
 * @api private
 * @param {string} path
 * @param {Object} obj
 * @param {Function} fn
 */
        Segment.prototype.enqueue = function(path, message, fn) {
            var url = this.options.apiScheme + "://" + this.options.apiHost + path, headers = {
                "Content-Type": "text/plain"
            }, msg = this.normalize(message);
            // Print a log statement when messages exceed the maximum size. In the future,
            // we may consider dropping this event on the client entirely.
            json.stringify(msg).length > 32e3 && this.debug("message must be less than 32kb %O", msg), 
            this.debug("enqueueing %O", msg);
            var self = this;
            this.options.retryQueue ? this._lsqueue.addItem({
                url: url,
                headers: headers,
                msg: msg
            }) : // eslint-disable-next-line consistent-return
            send(url, msg, headers, function(err, res) {
                if (self.debug("sent %O, received %O", msg, [ err, res ]), fn) {
                    if (err) return fn(err);
                    fn(null, res);
                }
            });
        }, /**
 * Gets/sets cookies on the appropriate domain.
 *
 * @api private
 * @param {string} name
 * @param {*} val
 */
        // eslint-disable-next-line consistent-return
        Segment.prototype.cookie = function(name, val) {
            var store = Segment.storage();
            if (1 === arguments.length) return store(name);
            var global = exports.global, href = global.location.href, domain = "." + topDomain(href);
            "." === domain && (domain = ""), this.debug("store domain %s -> %s", href, domain);
            var opts = clone(cookieOptions);
            opts.domain = domain, this.debug("store %s, %s, %o", name, val, opts), store(name, val, opts), 
            // eslint-disable-next-line consistent-return
            store(name) || (delete opts.domain, this.debug("fallback store %s, %s, %o", name, val, opts), 
            store(name, val, opts));
        }, /**
 * Add referrerId to context.
 *
 * TODO: remove.
 *
 * @api private
 * @param {Object} query
 * @param {Object} ctx
 */
        Segment.prototype.referrerId = function(query, ctx) {
            var stored = this.cookie("s:context.referrer"), ad = void 0;
            stored && (stored = json.parse(stored)), query && (ad = ads(query)), (ad = ad || stored) && (ctx.referrer = extend(ctx.referrer || {}, ad), 
            this.cookie("s:context.referrer", json.stringify(ad)));
        }, /**
 * retrieveCrossDomainId.
 *
 * @api private
 * @param {function) callback => err, {crossDomainId, fromServer, timestamp}
 */
        Segment.prototype.retrieveCrossDomainId = function(callback) {
            if (!this.options.crossDomainIdServers) return void (callback && callback("crossDomainId not enabled", null));
            if (!this.cookie("seg_xid")) {
                var self = this, writeKey = this.options.apiKey, currentTld = getTld(window.location.hostname), domains = [];
                this.options.crossDomainIdServers.forEach(function(domain) {
                    getTld(domain) !== currentTld && domains.push(domain);
                }), getCrossDomainIdFromServerList(domains, writeKey, function(err, res) {
                    if (err) // We optimize for no conflicting xid as much as possible. So bail out if there is an
                    // error and we cannot be sure that xid does not exist on any other domains
                    return void (callback && callback(err, null));
                    var crossDomainId = null, fromDomain = null;
                    res ? (crossDomainId = res.id, fromDomain = res.domain) : (crossDomainId = uuid(), 
                    fromDomain = window.location.hostname);
                    var currentTimeMillis = new Date().getTime();
                    self.cookie("seg_xid", crossDomainId), // Not actively used. Saving for future conflict resolution purposes
                    self.cookie("seg_xid_fd", fromDomain), self.cookie("seg_xid_ts", currentTimeMillis), 
                    self.analytics.identify({
                        crossDomainId: crossDomainId
                    }), callback && callback(null, {
                        crossDomainId: crossDomainId,
                        fromDomain: fromDomain,
                        timestamp: currentTimeMillis
                    });
                });
            }
        };
    }, /* 199 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _isIterable2 = __webpack_require__(200), _isIterable3 = _interopRequireDefault(_isIterable2), _getIterator2 = __webpack_require__(203), _getIterator3 = _interopRequireDefault(_getIterator2);
        exports.default = function() {
            function sliceIterator(arr, i) {
                var _arr = [], _n = !0, _d = !1, _e = void 0;
                try {
                    for (var _s, _i = (0, _getIterator3.default)(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                    !i || _arr.length !== i); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        !_n && _i.return && _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) return arr;
                if ((0, _isIterable3.default)(Object(arr))) return sliceIterator(arr, i);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
        }();
    }, /* 200 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(201),
            __esModule: !0
        };
    }, /* 201 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(41), __webpack_require__(35), module.exports = __webpack_require__(202);
    }, /* 202 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(76), ITERATOR = __webpack_require__(2)("iterator"), Iterators = __webpack_require__(24);
        module.exports = __webpack_require__(0).isIterable = function(it) {
            var O = Object(it);
            return void 0 !== O[ITERATOR] || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
        };
    }, /* 203 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(204),
            __esModule: !0
        };
    }, /* 204 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(41), __webpack_require__(35), module.exports = __webpack_require__(205);
    }, /* 205 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), get = __webpack_require__(109);
        module.exports = __webpack_require__(0).getIterator = function(it) {
            var iterFn = get(it);
            if ("function" != typeof iterFn) throw TypeError(it + " is not iterable!");
            return anObject(iterFn.call(it));
        };
    }, /* 206 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(207),
            __esModule: !0
        };
    }, /* 207 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(208), module.exports = __webpack_require__(0).Object.entries;
    }, /* 208 */
    /***/
    function(module, exports, __webpack_require__) {
        // https://github.com/tc39/proposal-object-values-entries
        var $export = __webpack_require__(3), $entries = __webpack_require__(110)(!0);
        $export($export.S, "Object", {
            entries: function(it) {
                return $entries(it);
            }
        });
    }, /* 209 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Get all ads info from the given `querystring`
 *
 * @param {string} query
 * @return {Object}
 */
        function ads(query) {
            var params = parse(query);
            for (var key in params) if (params.hasOwnProperty(key)) for (var id in QUERYIDS) if (QUERYIDS.hasOwnProperty(id) && key === id) return {
                id: params[key],
                type: QUERYIDS[id]
            };
        }
        /*
 * Module dependencies.
 */
        var parse = __webpack_require__(75).parse, QUERYIDS = {
            btid: "dataxu",
            urid: "millennial-media"
        };
        /*
 * Exports.
 */
        module.exports = ads;
    }, /* 210 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Clones objects.
 *
 * @param {Mixed} any object
 * @api public
 */
        function clone(obj) {
            switch (type(obj)) {
              case "object":
                var copy = {};
                for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (copy[key] = clone(obj[key]));
                return copy;

              case "array":
                for (var copy = new Array(obj.length), i = 0, l = obj.length; i < l; i++) copy[i] = clone(obj[i]);
                return copy;

              case "regexp":
                // from millermedeiros/amd-utils - MIT
                var flags = "";
                return flags += obj.multiline ? "m" : "", flags += obj.global ? "g" : "", flags += obj.ignoreCase ? "i" : "", 
                new RegExp(obj.source, flags);

              case "date":
                return new Date(obj.getTime());

              default:
                // string, number, boolean, 
                return obj;
            }
        }
        /**
 * Module dependencies.
 */
        var type;
        try {
            type = __webpack_require__(22);
        } catch (_) {
            type = __webpack_require__(22);
        }
        /**
 * Module exports.
 */
        module.exports = clone;
    }, /* 211 */
    /***/
    function(module, exports) {
        /**
 * Generate a slug from the given `str`.
 *
 * example:
 *
 *        generate('foo bar');
 *        // > foo-bar
 *
 * @param {String} str
 * @param {Object} options
 * @config {String|RegExp} [replace] characters to replace, defaulted to `/[^a-z0-9]/g`
 * @config {String} [separator] separator to insert, defaulted to `-`
 * @return {String}
 */
        module.exports = function(str, options) {
            return options || (options = {}), str.toLowerCase().replace(options.replace || /[^a-z0-9]/g, " ").replace(/^ +| +$/g, "").replace(/ +/g, options.separator || "-");
        };
    }, /* 212 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Determine the type of the option passed to `#map`
 *
 * @api private
 * @param {Object|Object[]} mapping
 * @return {String} mappingType
 */
        function getMappingType(mapping) {
            return is.array(mapping) ? every(isMixed, mapping) ? "mixed" : "array" : is.object(mapping) ? "map" : "unknown";
        }
        /**
 * Determine if item in mapping array is a valid "mixed" type value
 *
 * Must be an object with properties "key" (of type string)
 * and "value" (of any type)
 *
 * @api private
 * @param {*} item
 * @return {Boolean}
 */
        function isMixed(item) {
            return !!is.object(item) && (!!is.string(item.key) && !!has.call(item, "value"));
        }
        /**
 * TODO: Document me
 *
 * @api private
 * @param {Object} attrs
 * @param {Function} fn
 * @return {Image}
 */
        function loadImage(attrs, fn) {
            fn = fn || function() {};
            var img = new Image();
            return img.onerror = error(fn, "failed to load pixel", img), img.onload = function() {
                fn();
            }, img.src = attrs.src, img.width = 1, img.height = 1, img;
        }
        /**
 * TODO: Document me
 *
 * @api private
 * @param {Function} fn
 * @param {string} message
 * @param {Element} img
 * @return {Function}
 */
        function error(fn, message, img) {
            return function(e) {
                e = e || window.event;
                var err = new Error(message);
                err.event = e, err.source = img, fn(err);
            };
        }
        /**
 * Render template + locals into an `attrs` object.
 *
 * @api private
 * @param {Object} template
 * @param {Object} locals
 * @return {Object}
 */
        function render(template, locals) {
            return foldl(function(attrs, val, key) {
                return attrs[key] = val.replace(/\{\{\ *(\w+)\ *\}\}/g, function(_, $1) {
                    return locals[$1];
                }), attrs;
            }, {}, template.attrs);
        }
        /**
 * Module dependencies.
 */
        var Emitter = __webpack_require__(47), after = __webpack_require__(213), each = __webpack_require__(5), events = __webpack_require__(215), every = __webpack_require__(216), fmt = __webpack_require__(217), foldl = __webpack_require__(70), is = __webpack_require__(45), loadIframe = __webpack_require__(218), loadScript = __webpack_require__(219), nextTick = __webpack_require__(50), normalize = __webpack_require__(220), has = Object.prototype.hasOwnProperty, noop = function() {}, onerror = window.onerror;
        /**
 * Mixin emitter.
 */
        /* eslint-disable new-cap */
        Emitter(exports), /* eslint-enable new-cap */
        /**
 * Initialize.
 */
        exports.initialize = function() {
            var ready = this.ready;
            nextTick(ready);
        }, /**
 * Loaded?
 *
 * @api private
 * @return {boolean}
 */
        exports.loaded = function() {
            return !1;
        }, /**
 * Page.
 *
 * @api public
 * @param {Page} page
 */
        /* eslint-disable no-unused-vars */
        exports.page = function(page) {}, /* eslint-enable no-unused-vars */
        /**
 * Track.
 *
 * @api public
 * @param {Track} track
 */
        /* eslint-disable no-unused-vars */
        exports.track = function(track) {}, /* eslint-enable no-unused-vars */
        /**
 * Get values from items in `options` that are mapped to `key`.
 * `options` is an integration setting which is a collection
 * of type 'map', 'array', or 'mixed'
 *
 * Use cases include mapping events to pixelIds (map), sending generic
 * conversion pixels only for specific events (array), or configuring dynamic
 * mappings of event properties to query string parameters based on event (mixed)
 *
 * @api public
 * @param {Object|Object[]|String[]} options An object, array of objects, or
 * array of strings pulled from settings.mapping.
 * @param {string} key The name of the item in options whose metadata
 * we're looking for.
 * @return {Array} An array of settings that match the input `key` name.
 * @example
 *
 * // 'Map'
 * var events = { my_event: 'a4991b88' };
 * .map(events, 'My Event');
 * // => ["a4991b88"]
 * .map(events, 'whatever');
 * // => []
 *
 * // 'Array'
 * * var events = ['Completed Order', 'My Event'];
 * .map(events, 'My Event');
 * // => ["My Event"]
 * .map(events, 'whatever');
 * // => []
 *
 * // 'Mixed'
 * var events = [{ key: 'my event', value: '9b5eb1fa' }];
 * .map(events, 'my_event');
 * // => ["9b5eb1fa"]
 * .map(events, 'whatever');
 * // => []
 */
        exports.map = function(options, key) {
            var normalizedComparator = normalize(key), mappingType = getMappingType(options);
            return "unknown" === mappingType ? [] : foldl(function(matchingValues, val, key) {
                var compare, result;
                return "map" === mappingType && (compare = key, result = val), "array" === mappingType && (compare = val, 
                result = val), "mixed" === mappingType && (compare = val.key, result = val.value), 
                normalize(compare) === normalizedComparator && matchingValues.push(result), matchingValues;
            }, [], options);
        }, /**
 * Invoke a `method` that may or may not exist on the prototype with `args`,
 * queueing or not depending on whether the integration is "ready". Don't
 * trust the method call, since it contains integration party code.
 *
 * @api private
 * @param {string} method
 * @param {...*} args
 */
        exports.invoke = function(method) {
            if (this[method]) {
                var args = Array.prototype.slice.call(arguments, 1);
                return this._ready ? (this.debug("%s with %o", method, args), this[method].apply(this, args)) : this.queue(method, args);
            }
        }, /**
 * Queue a `method` with `args`. If the integration assumes an initial
 * pageview, then let the first call to `page` pass through.
 *
 * @api private
 * @param {string} method
 * @param {Array} args
 */
        exports.queue = function(method, args) {
            if ("page" === method && this._assumesPageview && !this._initialized) return this.page.apply(this, args);
            this._queue.push({
                method: method,
                args: args
            });
        }, /**
 * Flush the internal queue.
 *
 * @api private
 */
        exports.flush = function() {
            this._ready = !0;
            var self = this;
            each(function(call) {
                self[call.method].apply(self, call.args);
            }, this._queue), // Empty the queue.
            this._queue.length = 0;
        }, /**
 * Reset the integration, removing its global variables.
 *
 * @api private
 */
        exports.reset = function() {
            for (var i = 0; i < this.globals.length; i++) window[this.globals[i]] = void 0;
            window.onerror = onerror, window.onload = null;
        }, /**
 * Load a tag by `name`.
 *
 * @param {string} name The name of the tag.
 * @param {Object} locals Locals used to populate the tag's template variables
 * (e.g. `userId` in '<img src="https://whatever.com/{{ userId }}">').
 * @param {Function} [callback=noop] A callback, invoked when the tag finishes
 * loading.
 */
        exports.load = function(name, locals, callback) {
            // Argument shuffling
            "function" == typeof name && (callback = name, locals = null, name = null), name && "object" == typeof name && (callback = locals, 
            locals = name, name = null), "function" == typeof locals && (callback = locals, 
            locals = null), // Default arguments
            name = name || "library", locals = locals || {}, locals = this.locals(locals);
            var template = this.templates[name];
            if (!template) throw new Error(fmt('template "%s" not defined.', name));
            var attrs = render(template, locals);
            callback = callback || noop;
            var el, self = this;
            switch (template.type) {
              case "img":
                attrs.width = 1, attrs.height = 1, el = loadImage(attrs, callback);
                break;

              case "script":
                el = loadScript(attrs, function(err) {
                    if (!err) return callback();
                    self.debug('error loading "%s" error="%s"', self.name, err);
                }), // TODO: hack until refactoring load-script
                delete attrs.src, each(function(val, key) {
                    el.setAttribute(key, val);
                }, attrs);
                break;

              case "iframe":
                el = loadIframe(attrs, callback);
            }
            return el;
        }, /**
 * Locals for tag templates.
 *
 * By default it includes a cache buster and all of the options.
 *
 * @param {Object} [locals]
 * @return {Object}
 */
        exports.locals = function(locals) {
            locals = locals || {};
            var cache = Math.floor(new Date().getTime() / 36e5);
            return locals.hasOwnProperty("cache") || (locals.cache = cache), each(function(val, key) {
                locals.hasOwnProperty(key) || (locals[key] = val);
            }, this.options), locals;
        }, /**
 * Simple way to emit ready.
 *
 * @api public
 */
        exports.ready = function() {
            this.emit("ready");
        }, /**
 * Wrap the initialize method in an exists check, so we don't have to do it for
 * every single integration.
 *
 * @api private
 */
        exports._wrapInitialize = function() {
            var initialize = this.initialize;
            this.initialize = function() {
                this.debug("initialize"), this._initialized = !0;
                var ret = initialize.apply(this, arguments);
                return this.emit("initialize"), ret;
            }, this._assumesPageview && (this.initialize = after(2, this.initialize));
        }, /**
 * Wrap the page method to call `initialize` instead if the integration assumes
 * a pageview.
 *
 * @api private
 */
        exports._wrapPage = function() {
            var page = this.page;
            this.page = function() {
                return this._assumesPageview && !this._initialized ? this.initialize.apply(this, arguments) : page.apply(this, arguments);
            };
        }, /**
 * Wrap the track method to call other ecommerce methods if available depending
 * on the `track.event()`.
 *
 * @api private
 */
        exports._wrapTrack = function() {
            var t = this.track;
            this.track = function(track) {
                var called, ret, event = track.event();
                for (var method in events) if (has.call(events, method)) {
                    var regexp = events[method];
                    if (!this[method]) continue;
                    if (!regexp.test(event)) continue;
                    ret = this[method].apply(this, arguments), called = !0;
                    break;
                }
                return called || (ret = t.apply(this, arguments)), ret;
            };
        };
    }, /* 213 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var arity = __webpack_require__(214), objToString = Object.prototype.toString, isFunction = function(val) {
            return "function" == typeof val;
        }, isNumber = function(val) {
            var type = typeof val;
            return "number" === type || "object" === type && "[object Number]" === objToString.call(val);
        }, after = function(n, fn) {
            if (!isNumber(n)) throw new TypeError("Expected a number but received " + typeof n);
            if (!isFunction(fn)) throw new TypeError("Expected a function but received " + typeof fn);
            var callCount = 0;
            return arity(fn.length, function() {
                if (!((callCount += 1) < n)) return fn.apply(this, arguments);
            });
        };
        /*
 * Exports.
 */
        module.exports = after;
    }, /* 214 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var objToString = Object.prototype.toString, isFunction = function(val) {
            return "function" == typeof val;
        }, isNumber = function(val) {
            var type = typeof val;
            return "number" === type || "object" === type && "[object Number]" === objToString.call(val);
        }, createParams = function(n) {
            for (var args = [], i = 1; i <= n; i += 1) args.push("arg" + i);
            return args;
        }, createArityWrapper = function(n) {
            var paramNames = createParams(n).join(", "), wrapperBody = "".concat("  return function(", paramNames, ") {\n", "    return func.apply(this, arguments);\n", "  };");
            /* eslint-disable no-new-func */
            return new Function("func", wrapperBody);
        }, arityWrapperCache = [ /* eslint-disable no-unused-vars */
        function(fn) {
            return function() {
                return fn.apply(this, arguments);
            };
        }, function(fn) {
            return function(arg1) {
                return fn.apply(this, arguments);
            };
        }, function(fn) {
            return function(arg1, arg2) {
                return fn.apply(this, arguments);
            };
        }, function(fn) {
            return function(arg1, arg2, arg3) {
                return fn.apply(this, arguments);
            };
        }, function(fn) {
            return function(arg1, arg2, arg3, arg4) {
                return fn.apply(this, arguments);
            };
        }, function(fn) {
            return function(arg1, arg2, arg3, arg4, arg5) {
                return fn.apply(this, arguments);
            };
        } ], arity = function(n, func) {
            if (!isFunction(func)) throw new TypeError("Expected a function but got " + typeof func);
            return n = Math.max(isNumber(n) ? n : 0, 0), arityWrapperCache[n] || (arityWrapperCache[n] = createArityWrapper(n)), 
            arityWrapperCache[n](func);
        };
        /*
 * Exports.
 */
        module.exports = arity;
    }, /* 215 */
    /***/
    function(module, exports) {
        module.exports = {
            // Promotions
            promotionViewed: /^[ _]?promotion[ _]?viewed?[ _]?$/i,
            viewedPromotion: /^[ _]?viewed[ _]?promotion?[ _]?$/i,
            promotionClicked: /^[ _]?promotion[ _]?clicked?[ _]?$/i,
            clickedPromotion: /^[ _]?clicked[ _]?promotion?[ _]?$/i,
            // Browsing
            productsSearched: /^[ _]?products[ _]?searched[ _]?$/i,
            productListViewed: /^[ _]?product[ _]?list[ _]?viewed[ _]?$/i,
            productListFiltered: /^[ _]?product[ _]?list[ _]?filtered[ _]?$/i,
            viewedProductCategory: /^[ _]?viewed[ _]?product[ _]?category[ _]?$/i,
            viewedProductDetails: /^[ _]?viewed[ _]?product[ _]?details?[ _]?$/i,
            // Core Ordering
            productClicked: /^[ _]?product[ _]?clicked[ _]?$/i,
            clickedProduct: /^[ _]?clicked[ _]?product[ _]?$/i,
            productViewed: /^[ _]?product[ _]?viewed[ _]?$/i,
            viewedProduct: /^[ _]?viewed[ _]?product[ _]?$/i,
            productAdded: /^[ _]?product[ _]?added[ _]?$/i,
            addedProduct: /^[ _]?added[ _]?product[ _]?$/i,
            productRemoved: /^[ _]?product[ _]?removed[ _]?$/i,
            removedProduct: /^[ _]?removed[ _]?product[ _]?$/i,
            cartViewed: /^[ _]?cart[ _]?viewed[ _]?$/i,
            orderStarted: /^[ _]?order[ _]?started[ _]?$/i,
            startedOrder: /^[ _]?started[ _]?order[ _]?$/i,
            orderUpdated: /^[ _]?order[ _]?updated[ _]?$/i,
            updatedOrder: /^[ _]?updated[ _]?order[ _]?$/i,
            orderCompleted: /^[ _]?order[ _]?completed[ _]?$/i,
            completedOrder: /^[ _]?completed[ _]?order[ _]?$/i,
            orderRefunded: /^[ _]?order[ _]?refunded[ _]?$/i,
            refundedOrder: /^[ _]?refunded[ _]?order[ _]?$/i,
            orderCancelled: /^[ _]?order[ _]?cancelled[ _]?$/i,
            paymentInfoAdded: /^[ _]?payment[ _]?info[ _]?added[ _]?$/i,
            checkoutStarted: /^[ _]?checkout[ _]?started[ _]?$/i,
            checkoutStepViewed: /^[ _]?checkout[ _]?step[ _]?viewed[ _]?$/i,
            viewedCheckoutStep: /^[ _]?viewed[ _]?checkout[ _]?step[ _]?$/i,
            checkoutStepCompleted: /^[ _]?checkout[ _]?step[ _]?completed[ _]?$/i,
            completedCheckoutStep: /^[ _]?completed[ _]?checkout[ _]?step[ _]?$/i,
            // Coupons
            couponEntered: /^[ _]?coupon[ _]?entered[ _]?$/i,
            couponApplied: /^[ _]?coupon[ _]?applied[ _]?$/i,
            couponDenied: /^[ _]?coupon[ _]?denied[ _]?$/i,
            couponRemoved: /^[ _]?coupon[ _]?removed[ _]?$/i,
            // Wishlisting
            productAddedToWishlist: /^[ _]?product[ _]?added[ _]?to[ _]?wishlist[ _]?$/i,
            wishlistProductRemoved: /^[ _]?wishlist[ _]?product[ _]?removed[ _]?$/i,
            wishlistProductAddedToCart: /^[ _]?wishlist[ _]?product[ _]?added[ _]?to[ _]?cart[ _]?$/i,
            // Sharing
            productShared: /^[ _]?product[ _]?shared[ _]?$/i,
            cartShared: /^[ _]?cart[ _]?shared[ _]?$/i,
            // Reviewing
            productRemoved: /^[ _]?product[ _]?removed[ _]?$/i,
            // App Lifecycle
            applicationInstalled: /^[ _]?application[ _]?installed[ _]?$/i,
            applicationUpdated: /^[ _]?application[ _]?updated[ _]?$/i,
            applicationOpened: /^[ _]?application[ _]?opened[ _]?$/i,
            applicationBackgrounded: /^[ _]?application[ _]?backgrounded[ _]?$/i,
            applicationUninstalled: /^[ _]?application[ _]?uninstalled[ _]?$/i,
            // App Campaign and Referral Events
            installAttributed: /^[ _]?install[ _]?attributed[ _]?$/i,
            deepLinkOpened: /^[ _]?deep[ _]?link[ _]?opened[ _]?$/i,
            pushNotificationReceived: /^[ _]?push[ _]?notification[ _]?received[ _]?$/i,
            pushNotificationTapped: /^[ _]?push[ _]?notification[ _]?received[ _]?$/i,
            pushNotificationBounced: /^[ _]?push[ _]?notification[ _]?bounced[ _]?$/i
        };
    }, /* 216 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*
 * Module dependencies.
 */
        var each = __webpack_require__(5), every = function(predicate, collection) {
            if ("function" != typeof predicate) throw new TypeError("`predicate` must be a function but was a " + typeof predicate);
            var result = !0;
            return each(function(val, key, collection) {
                // Exit early
                if (!(result = !!predicate(val, key, collection))) return !1;
            }, collection), result;
        };
        /*
 * Exports.
 */
        module.exports = every;
    }, /* 217 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */
        (function(global) {
            /**
 * Format the given `str`.
 *
 * @param {string} str
 * @param {...*} [args]
 * @return {string}
 */
            function fmt(str) {
                var args = Array.prototype.slice.call(arguments, 1), j = 0;
                return str.replace(/%([a-z])/gi, function(match, f) {
                    return fmt[f] ? fmt[f](args[j++]) : match + f;
                });
            }
            // Stringifier
            var toString = global.JSON && "function" == typeof JSON.stringify ? JSON.stringify : String;
            // Formatters
            fmt.o = toString, fmt.s = String, fmt.d = parseInt, /*
 * Exports.
 */
            module.exports = fmt;
        }).call(exports, __webpack_require__(17));
    }, /* 218 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Module dependencies.
 */
        var is = __webpack_require__(45), onload = __webpack_require__(112), tick = __webpack_require__(50);
        /**
 * Expose `loadScript`.
 *
 * @param {Object} options
 * @param {Function} fn
 * @api public
 */
        module.exports = function(options, fn) {
            if (!options) throw new Error("Cant load nothing...");
            // Allow for the simplest case, just passing a `src` string.
            is.string(options) && (options = {
                src: options
            });
            var https = "https:" === document.location.protocol || "chrome-extension:" === document.location.protocol;
            // If you use protocol relative URLs, third-party scripts like Google
            // Analytics break when testing with `file:` so this fixes that.
            options.src && 0 === options.src.indexOf("//") && (options.src = https ? "https:" + options.src : "http:" + options.src), 
            // Allow them to pass in different URLs depending on the protocol.
            https && options.https ? options.src = options.https : !https && options.http && (options.src = options.http);
            // Make the `<iframe>` element and insert it before the first iframe on the
            // page, which is guaranteed to exist since this Javaiframe is running.
            var iframe = document.createElement("iframe");
            // Return the iframe element in case they want to do anything special, like
            // give it an ID or attributes.
            // If we have a fn, attach event handlers, even in IE. Based off of
            // the Third-Party Javascript script loading example:
            // https://github.com/thirdpartyjs/thirdpartyjs-code/blob/master/examples/templates/02/loading-files/index.html
            return iframe.src = options.src, iframe.width = options.width || 1, iframe.height = options.height || 1, 
            iframe.style.display = "none", is.fn(fn) && onload(iframe, fn), tick(function() {
                // Append after event listeners are attached for IE.
                var firstScript = document.getElementsByTagName("script")[0];
                firstScript.parentNode.insertBefore(iframe, firstScript);
            }), iframe;
        };
    }, /* 219 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Loads a script asynchronously.
 *
 * @param {Object} options
 * @param {Function} cb
 */
        function loadScript(options, cb) {
            if (!options) throw new Error("Can't load nothing...");
            // Allow for the simplest case, just passing a `src` string.
            "string" === type(options) && (options = {
                src: options
            });
            var https = "https:" === document.location.protocol || "chrome-extension:" === document.location.protocol;
            // If you use protocol relative URLs, third-party scripts like Google
            // Analytics break when testing with `file:` so this fixes that.
            options.src && 0 === options.src.indexOf("//") && (options.src = (https ? "https:" : "http:") + options.src), 
            // Allow them to pass in different URLs depending on the protocol.
            https && options.https ? options.src = options.https : !https && options.http && (options.src = options.http);
            // Make the `<script>` element and insert it before the first script on the
            // page, which is guaranteed to exist since this Javascript is running.
            var script = document.createElement("script");
            // Return the script element in case they want to do anything special, like
            // give it an ID or attributes.
            // If we have a cb, attach event handlers. Does not work on < IE9 because
            // older browser versions don't register element.onerror
            return script.type = "text/javascript", script.async = !0, script.src = options.src, 
            "function" === type(cb) && onload(script, cb), tick(function() {
                // Append after event listeners are attached for IE.
                var firstScript = document.getElementsByTagName("script")[0];
                firstScript.parentNode.insertBefore(script, firstScript);
            }), script;
        }
        /*
 * Module dependencies.
 */
        var onload = __webpack_require__(112), tick = __webpack_require__(50), type = __webpack_require__(22);
        /*
 * Exports.
 */
        module.exports = loadScript;
    }, /* 220 */
    /***/
    function(module, exports) {
        /**
 * Remove any starting case from a `string`, like camel or snake, but keep
 * spaces and punctuation that may be important otherwise.
 *
 * @param {String} string
 * @return {String}
 */
        function toNoCase(string) {
            return hasSpace.test(string) ? string.toLowerCase() : hasSeparator.test(string) ? (unseparate(string) || string).toLowerCase() : uncamelize(string).toLowerCase();
        }
        /**
 * Un-separate a `string`.
 *
 * @param {String} string
 * @return {String}
 */
        function unseparate(string) {
            return string.replace(separatorSplitter, function(m, next) {
                return next ? " " + next : "";
            });
        }
        /**
 * Un-camelcase a `string`.
 *
 * @param {String} string
 * @return {String}
 */
        function uncamelize(string) {
            return string.replace(camelSplitter, function(m, previous, uppers) {
                return previous + " " + uppers.toLowerCase().split("").join(" ");
            });
        }
        /**
 * Expose `toNoCase`.
 */
        module.exports = toNoCase;
        /**
 * Test whether a string is camel-case.
 */
        var hasSpace = /\s/, hasSeparator = /[\W_]/, separatorSplitter = /[\W_]+(.|$)/g, camelSplitter = /(.)([A-Z]+)/g;
    }, /* 221 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Given a string, give back DOM attributes.
 *
 * Do it in a way where the browser doesn't load images or iframes. It turns
 * out domify will load images/iframes because whenever you construct those
 * DOM elements, the browser immediately loads them.
 *
 * @api private
 * @param {string} str
 * @return {Object}
 */
        function objectify(str) {
            // replace `src` with `data-src` to prevent image loading
            str = str.replace(' src="', ' data-src="');
            var el = domify(str), attrs = {};
            return each(function(attr) {
                // then replace it back
                var name = "data-src" === attr.name ? "src" : attr.name;
                includes(attr.name + "=", str) && (attrs[name] = attr.value);
            }, el.attributes), {
                type: el.tagName.toLowerCase(),
                attrs: attrs
            };
        }
        /**
 * Module dependencies.
 */
        var Emitter = __webpack_require__(47), domify = __webpack_require__(222), each = __webpack_require__(5), includes = __webpack_require__(73);
        /**
 * Mix in emitter.
 */
        /* eslint-disable new-cap */
        Emitter(exports), /* eslint-enable new-cap */
        /**
 * Add a new option to the integration by `key` with default `value`.
 *
 * @api public
 * @param {string} key
 * @param {*} value
 * @return {Integration}
 */
        exports.option = function(key, value) {
            return this.prototype.defaults[key] = value, this;
        }, /**
 * Add a new mapping option.
 *
 * This will create a method `name` that will return a mapping for you to use.
 *
 * @api public
 * @param {string} name
 * @return {Integration}
 * @example
 * Integration('My Integration')
 *   .mapping('events');
 *
 * new MyIntegration().track('My Event');
 *
 * .track = function(track){
 *   var events = this.events(track.event());
 *   each(send, events);
 *  };
 */
        exports.mapping = function(name) {
            return this.option(name, []), this.prototype[name] = function(key) {
                return this.map(this.options[name], key);
            }, this;
        }, /**
 * Register a new global variable `key` owned by the integration, which will be
 * used to test whether the integration is already on the page.
 *
 * @api public
 * @param {string} key
 * @return {Integration}
 */
        exports.global = function(key) {
            return this.prototype.globals.push(key), this;
        }, /**
 * Mark the integration as assuming an initial pageview, so to defer loading
 * the script until the first `page` call, noop the first `initialize`.
 *
 * @api public
 * @return {Integration}
 */
        exports.assumesPageview = function() {
            return this.prototype._assumesPageview = !0, this;
        }, /**
 * Mark the integration as being "ready" once `load` is called.
 *
 * @api public
 * @return {Integration}
 */
        exports.readyOnLoad = function() {
            return this.prototype._readyOnLoad = !0, this;
        }, /**
 * Mark the integration as being "ready" once `initialize` is called.
 *
 * @api public
 * @return {Integration}
 */
        exports.readyOnInitialize = function() {
            return this.prototype._readyOnInitialize = !0, this;
        }, /**
 * Define a tag to be loaded.
 *
 * @api public
 * @param {string} [name='library'] A nicename for the tag, commonly used in
 * #load. Helpful when the integration has multiple tags and you need a way to
 * specify which of the tags you want to load at a given time.
 * @param {String} str DOM tag as string or URL.
 * @return {Integration}
 */
        exports.tag = function(name, tag) {
            return null == tag && (tag = name, name = "library"), this.prototype.templates[name] = objectify(tag), 
            this;
        };
    }, /* 222 */
    /***/
    function(module, exports) {
        /**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */
        function parse(html, doc) {
            if ("string" != typeof html) throw new TypeError("String expected");
            // default to the global `document` object
            doc || (doc = document);
            // tag name
            var m = /<([\w:]+)/.exec(html);
            if (!m) return doc.createTextNode(html);
            html = html.replace(/^\s+|\s+$/g, "");
            // Remove leading/trailing whitespace
            var tag = m[1];
            // body support
            if ("body" == tag) {
                var el = doc.createElement("html");
                return el.innerHTML = html, el.removeChild(el.lastChild);
            }
            // wrap map
            var wrap = map[tag] || map._default, depth = wrap[0], prefix = wrap[1], suffix = wrap[2], el = doc.createElement("div");
            for (el.innerHTML = prefix + html + suffix; depth--; ) el = el.lastChild;
            // one element
            if (el.firstChild == el.lastChild) return el.removeChild(el.firstChild);
            for (// several elements
            var fragment = doc.createDocumentFragment(); el.firstChild; ) fragment.appendChild(el.removeChild(el.firstChild));
            return fragment;
        }
        /**
 * Expose `parse`.
 */
        module.exports = parse;
        /**
 * Tests for browser support.
 */
        var bugTestDiv, innerHTMLBug = !1;
        "undefined" != typeof document && (bugTestDiv = document.createElement("div"), // Setup
        bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>', 
        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length, bugTestDiv = void 0);
        /**
 * Wrap map from jquery.
 */
        var map = {
            legend: [ 1, "<fieldset>", "</fieldset>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
            // for script/link/style tags to work in IE6-8, you have to wrap
            // in a div with a non-whitespace character in front, ha!
            _default: innerHTMLBug ? [ 1, "X<div>", "</div>" ] : [ 0, "", "" ]
        };
        map.td = map.th = [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ], map.option = map.optgroup = [ 1, '<select multiple="multiple">', "</select>" ], 
        map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [ 1, "<table>", "</table>" ], 
        map.polyline = map.ellipse = map.polygon = map.circle = map.text = map.line = map.path = map.rect = map.g = [ 1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>" ];
    }, /* 223 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
 * Store the given `key`, `val`.
 *
 * @param {String|Object} key
 * @param {Mixed} value
 * @return {Mixed}
 * @api public
 */
        function store(key, value) {
            var length = arguments.length;
            if (0 == length) return all();
            if (2 <= length) return set(key, value);
            if (1 == length) return null == key ? storage.clear() : "string" == typeof key ? get(key) : "object" == typeof key ? each(key, set) : void 0;
        }
        /**
 * Set `key` to `val`.
 *
 * @param {String} key
 * @param {Mixed} val
 */
        function set(key, val) {
            return null == val ? storage.removeItem(key) : storage.setItem(key, JSON.stringify(val));
        }
        /**
 * Get `key`.
 *
 * @param {String} key
 * @return {Mixed}
 */
        function get(key) {
            return unserialize(storage.getItem(key));
        }
        /**
 * Get all.
 *
 * @return {Object}
 */
        function all() {
            for (var key, len = storage.length, ret = {}; 0 <= --len; ) key = storage.key(len), 
            ret[key] = get(key);
            return ret;
        }
        /**
 * dependencies.
 */
        var storage, unserialize = __webpack_require__(224), each = __webpack_require__(95);
        /**
 * Safari throws when a user
 * blocks access to cookies / localstorage.
 */
        try {
            storage = window.localStorage;
        } catch (e) {
            storage = null;
        }
        /**
 * Expose `store`
 */
        module.exports = store, /**
 * supported flag.
 */
        store.supported = !!storage;
    }, /* 224 */
    /***/
    function(module, exports) {
        /**
 * Unserialize the given "stringified" javascript.
 * 
 * @param {String} val
 * @return {Mixed}
 */
        module.exports = function(val) {
            try {
                return JSON.parse(val);
            } catch (e) {
                return val || void 0;
            }
        };
    }, /* 225 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Gets the current protocol, using the fallback and then the native protocol.
 *
 * @return {String} protocol
 */
        function get() {
            return mockedProtocol || window.location.protocol;
        }
        /**
 * Sets the protocol
 *
 * @param {String} protocol
 */
        function set(protocol) {
            try {
                define(window.location, "protocol", {
                    get: function() {
                        return protocol;
                    }
                });
            } catch (err) {
                mockedProtocol = protocol;
            }
        }
        /**
 * Convenience alias
 */
        var mockedProtocol, define = Object.defineProperty, initialProtocol = window.location.protocol;
        module.exports = function(protocol) {
            return 0 === arguments.length ? get() : set(protocol);
        }, /**
 * Sets the protocol to be http:
 */
        module.exports.http = function() {
            set("http:");
        }, /**
 * Sets the protocol to be https:
 */
        module.exports.https = function() {
            set("https:");
        }, /**
 * Reset to the initial protocol.
 */
        module.exports.reset = function() {
            set(initialProtocol);
        };
    }, /* 226 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Get all utm params from the given `querystring`
 *
 * @param {String} query
 * @return {Object}
 * @api private
 */
        function utm(query) {
            // Remove leading ? if present
            "?" === query.charAt(0) && (query = query.substring(1)), query = query.replace(/\?/g, "&");
            var param, params = parse(query), results = {};
            for (var key in params) has.call(params, key) && "utm_" === key.substr(0, 4) && (param = key.substr(4), 
            "campaign" === param && (param = "name"), results[param] = params[key]);
            return results;
        }
        /**
 * Get strict utm params - from the given `querystring`
 *
 * @param {String} query
 * @return {Object}
 * @api private
 */
        function strict(query) {
            return foldl(function(acc, val, key) {
                return has.call(allowedKeys, key) && (acc[key] = val), acc;
            }, {}, utm(query));
        }
        /**
 * Module dependencies.
 */
        var foldl = __webpack_require__(70), parse = __webpack_require__(75).parse, has = Object.prototype.hasOwnProperty, allowedKeys = {
            name: !0,
            term: !0,
            source: !0,
            medium: !0,
            content: !0
        };
        /*
 * Exports.
 */
        module.exports = utm, module.exports.strict = strict;
    }, /* 227 */
    /***/
    function(module, exports, __webpack_require__) {
        // See https://github.com/broofa/node-uuid for API details
        function v1(options, buf, offset) {
            var i = buf && offset || 0, b = buf || [];
            options = options || {};
            var node = options.node || _nodeId, clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq;
            // node and clockseq need to be initialized to random values if they're not
            // specified.  We do this lazily to minimize issues related to insufficient
            // system entropy.  See #189
            if (null == node || null == clockseq) {
                var seedBytes = rng();
                null == node && (// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
                node = _nodeId = [ 1 | seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ]), 
                null == clockseq && (// Per 4.2.2, randomize (14 bit) clockseq
                clockseq = _clockseq = 16383 & (seedBytes[6] << 8 | seedBytes[7]));
            }
            // UUID timestamps are 100 nano-second units since the Gregorian epoch,
            // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
            // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
            // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
            var msecs = void 0 !== options.msecs ? options.msecs : new Date().getTime(), nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1, dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
            // Per 4.2.1.2 Throw error if too many uuids are requested
            if (// Per 4.2.1.2, Bump clockseq on clock regression
            dt < 0 && void 0 === options.clockseq && (clockseq = clockseq + 1 & 16383), // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
            // time interval
            (dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
            _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq, // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
            msecs += 122192928e5;
            // `time_low`
            var tl = (1e4 * (268435455 & msecs) + nsecs) % 4294967296;
            b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = 255 & tl;
            // `time_mid`
            var tmh = msecs / 4294967296 * 1e4 & 268435455;
            b[i++] = tmh >>> 8 & 255, b[i++] = 255 & tmh, // `time_high_and_version`
            b[i++] = tmh >>> 24 & 15 | 16, // include version
            b[i++] = tmh >>> 16 & 255, // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
            b[i++] = clockseq >>> 8 | 128, // `clock_seq_low`
            b[i++] = 255 & clockseq;
            // `node`
            for (var n = 0; n < 6; ++n) b[i + n] = node[n];
            return buf || bytesToUuid(b);
        }
        var _nodeId, _clockseq, rng = __webpack_require__(115), bytesToUuid = __webpack_require__(116), _lastMSecs = 0, _lastNSecs = 0;
        module.exports = v1;
    }, /* 228 */
    /***/
    function(module, exports, __webpack_require__) {
        function v4(options, buf, offset) {
            var i = buf && offset || 0;
            "string" == typeof options && (buf = "binary" === options ? new Array(16) : null, 
            options = null), options = options || {};
            var rnds = options.random || (options.rng || rng)();
            // Copy bytes to buffer, if provided
            if (// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
            rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) for (var ii = 0; ii < 16; ++ii) buf[i + ii] = rnds[ii];
            return buf || bytesToUuid(rnds);
        }
        var rng = __webpack_require__(115), bytesToUuid = __webpack_require__(116);
        module.exports = v4;
    }, /* 229 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
* Store Implementation with dedicated
*/
        function Store(name, id, keys, optionalEngine) {
            this.id = id, this.name = name, this.keys = keys || {}, this.engine = optionalEngine || defaultEngine;
        }
        function isQuotaExceeded(e) {
            var quotaExceeded = !1;
            if (e.code) switch (e.code) {
              case 22:
                quotaExceeded = !0;
                break;

              case 1014:
                // Firefox
                "NS_ERROR_DOM_QUOTA_REACHED" === e.name && (quotaExceeded = !0);
            } else -2147024882 === e.number && (// Internet Explorer 8
            quotaExceeded = !0);
            return quotaExceeded;
        }
        var defaultEngine = __webpack_require__(117).defaultEngine, inMemoryEngine = __webpack_require__(117).inMemoryEngine, each = __webpack_require__(5), keys = __webpack_require__(33), json = __webpack_require__(28);
        /**
* Set value by key.
*/
        Store.prototype.set = function(key, value) {
            var compoundKey = this._createValidKey(key);
            if (compoundKey) try {
                this.engine.setItem(compoundKey, json.stringify(value));
            } catch (err) {
                isQuotaExceeded(err) && (// switch to inMemory engine
                this._swapEngine(), // and save it there
                this.set(key, value));
            }
        }, /**
* Get by Key.
*/
        Store.prototype.get = function(key) {
            try {
                var str = this.engine.getItem(this._createValidKey(key));
                return null === str ? null : json.parse(str);
            } catch (err) {
                return null;
            }
        }, /**
* Remove by Key.
*/
        Store.prototype.remove = function(key) {
            this.engine.removeItem(this._createValidKey(key));
        }, /**
* Ensure the key is valid
*/
        Store.prototype._createValidKey = function(key) {
            var name = this.name, id = this.id;
            if (!keys(this.keys).length) return [ name, id, key ].join(".");
            // validate and return undefined if invalid key
            var compoundKey;
            return each(function(value) {
                value === key && (compoundKey = [ name, id, key ].join("."));
            }, this.keys), compoundKey;
        }, /**
* Switch to inMemoryEngine, bringing any existing data with.
*/
        Store.prototype._swapEngine = function() {
            var self = this;
            // grab existing data, but only for this page's queue instance, not all
            // better to keep other queues in localstorage to be flushed later
            // than to pull them into memory and remove them from durable storage
            each(function(key) {
                var value = self.get(key);
                inMemoryEngine.setItem([ self.name, self.id, key ].join("."), value), self.remove(key);
            }, this.keys), this.engine = inMemoryEngine;
        }, module.exports = Store;
    }, /* 230 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function Schedule() {
            this.tasks = {}, this.nextId = 1;
        }
        var each = __webpack_require__(5), defaultClock = {
            setTimeout: function(fn, ms) {
                return window.setTimeout(fn, ms);
            },
            clearTimeout: function(id) {
                return window.clearTimeout(id);
            },
            Date: window.Date
        }, clock = defaultClock;
        Schedule.prototype.now = function() {
            return +new clock.Date();
        }, Schedule.prototype.run = function(task, timeout) {
            var id = this.nextId++;
            return this.tasks[id] = clock.setTimeout(this._handle(id, task), timeout), id;
        }, Schedule.prototype.cancel = function(id) {
            this.tasks[id] && (clock.clearTimeout(this.tasks[id]), delete this.tasks[id]);
        }, Schedule.prototype.cancelAll = function() {
            each(clock.clearTimeout, this.tasks), this.tasks = {};
        }, Schedule.prototype._handle = function(id, callback) {
            var self = this;
            return function() {
                return delete self.tasks[id], callback();
            };
        }, Schedule.setClock = function(newClock) {
            clock = newClock;
        }, Schedule.resetClock = function() {
            clock = defaultClock;
        }, module.exports = Schedule;
    }, /* 231 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _localstorageRetry = __webpack_require__(113), _localstorageRetry2 = _interopRequireDefault(_localstorageRetry), _Scheduler = __webpack_require__(232), _Scheduler2 = _interopRequireDefault(_Scheduler), QUEUE_RETRY_OPTION_OVERRIDES = {
            minRetryDelay: 1,
            maxRetryDelay: 1,
            backoffFactor: 1,
            backoffJitter: 0
        }, BatchableQueue = function BatchableQueue(retryQueuePrefix, retryQueueOptions, batchProcessFunc) {
            var _this = this;
            (0, _classCallCheck3.default)(this, BatchableQueue), this.start = function() {
                _this.queue.start();
            }, this._flush = function(done) {
                if (0 !== _this.currentBatch.length) {
                    var batchedQueuedObjects = _this.currentBatch.splice(0, _this.flushBatchSize), batchedItems = batchedQueuedObjects.map(function(queuedItem) {
                        return queuedItem.item;
                    });
                    _this.batchProcessFunc(batchedItems, function(error, response) {
                        batchedQueuedObjects.forEach(function(item) {
                            return item.done(error, response);
                        }), done(error), _this.currentBatch.length > 0 && _this._schedule();
                    });
                } else done();
            }, this._schedule = function() {
                _this.scheduler.schedule({
                    immediate: _this.currentBatch.length >= _this.flushBatchSize
                });
            }, this._processSingleElement = function(item, done) {
                _this.currentBatch.push({
                    item: item,
                    done: done
                }), _this.currentBatch.length > _this.maxQueueSize && _this.currentBatch.splice(0, _this.currentBatch.length - _this.maxQueueSize), 
                _this._schedule();
            }, this.addItem = function(item) {
                return _this.queue.addItem(item);
            }, this.maxQueueSize = retryQueueOptions.maxItems || 500, this.queue = new _localstorageRetry2.default(retryQueuePrefix, (0, 
            _extends3.default)({}, retryQueueOptions, QUEUE_RETRY_OPTION_OVERRIDES), this._processSingleElement), 
            this.flushBatchSize = retryQueueOptions.batchFlushSize || 7, this.batchProcessFunc = batchProcessFunc, 
            this.currentBatch = [], this.scheduler = new _Scheduler2.default((0, _extends3.default)({}, retryQueueOptions, {
                waitInterval: retryQueueOptions.flushWaitMs
            }), this._flush);
        };
        exports.default = BatchableQueue;
    }, /* 232 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_classCallCheck2), SCHEDULER_OPTIONS_DEFAULT = {
            minRetryDelay: 1e3,
            maxRetryDelay: 3e4,
            backoffFactor: 2,
            backoffJitter: 0,
            waitInterval: 500
        }, QUEUED_SCHEDULE_TYPES = {
            NONE: "none",
            IMMEDIATE: "immediate",
            WAIT: "wait"
        }, Scheduler = function Scheduler(retryOptions, callback) {
            var _this = this;
            (0, _classCallCheck3.default)(this, Scheduler), this.schedule = function() {
                var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    immediate: !1
                }, _ref$immediate = _ref.immediate, immediate = void 0 !== _ref$immediate && _ref$immediate;
                _this.operationInFlight ? immediate ? _this.queuedSchedule = QUEUED_SCHEDULE_TYPES.IMMEDIATE : _this.queuedSchedule !== QUEUED_SCHEDULE_TYPES.IMMEDIATE && (_this.queuedSchedule = QUEUED_SCHEDULE_TYPES.WAIT) : immediate && 0 === _this.failureCount ? (_this._clearTimeout(), 
                _this._run()) : _this.failureCount > 0 && null === _this.scheduledTimeout ? _this.scheduledTimeout = window.setTimeout(_this._run, _this._calculateBackoff()) : null === _this.scheduledTimeout && (_this.scheduledTimeout = window.setTimeout(_this._run, _this.options.waitInterval));
            }, this._clearTimeout = function() {
                null !== _this.scheduledTimeout && (window.clearTimeout(_this.scheduledTimeout), 
                _this.scheduledTimeout = null);
            }, this._run = function() {
                _this.operationInFlight = !0, _this._clearTimeout();
                try {
                    _this.callback(_this._done);
                } catch (err) {
                    _this._done(err);
                }
            }, this._done = function(err) {
                _this.operationInFlight = !1, err ? (_this.failureCount++, _this._clearTimeout()) : _this.failureCount = 0, 
                _this._processQueuedSchedule();
            }, this._processQueuedSchedule = function() {
                if (_this.queuedSchedule !== QUEUED_SCHEDULE_TYPES.NONE) {
                    var immediate = _this.queuedSchedule === QUEUED_SCHEDULE_TYPES.IMMEDIATE;
                    _this.queuedSchedule = QUEUED_SCHEDULE_TYPES.NONE, _this.schedule({
                        immediate: immediate
                    });
                }
            }, this._calculateBackoff = function() {
                var _options = _this.options, minRetryDelay = _options.minRetryDelay, maxRetryDelay = _options.maxRetryDelay, backoffFactor = _options.backoffFactor, backoffJitter = _options.backoffJitter, ms = minRetryDelay * Math.pow(backoffFactor, _this.failureCount);
                if (backoffJitter) {
                    var rand = Math.random(), deviation = Math.floor(rand * backoffJitter * ms);
                    Math.floor(10 * rand) < 5 ? ms -= deviation : ms += deviation;
                }
                return Number(Math.min(ms, maxRetryDelay).toPrecision(1));
            }, this.options = {
                minRetryDelay: retryOptions.minRetryDelay || SCHEDULER_OPTIONS_DEFAULT.minRetryDelay,
                maxRetryDelay: retryOptions.maxRetryDelay || SCHEDULER_OPTIONS_DEFAULT.maxRetryDelay,
                backoffFactor: retryOptions.backoffFactor || SCHEDULER_OPTIONS_DEFAULT.backoffFactor,
                backoffJitter: retryOptions.backoffJitter || SCHEDULER_OPTIONS_DEFAULT.backoffJitter,
                waitInterval: retryOptions.waitInterval || SCHEDULER_OPTIONS_DEFAULT.waitInterval
            }, this.scheduledTimeout = null, this.failureCount = 0, this.callback = callback, 
            this.operationInFlight = !1, this.queuedSchedule = QUEUED_SCHEDULE_TYPES.NONE;
        };
        exports.default = Scheduler;
    }, /* 233 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _assign = __webpack_require__(43), _assign2 = _interopRequireDefault(_assign), _analytics = __webpack_require__(111), _analytics2 = _interopRequireDefault(_analytics), BeforeSendIntegration = (0, 
        _analytics2.default)("BeforeSend");
        (0, _assign2.default)(BeforeSendIntegration.prototype, {
            initialize: function() {
                var _this = this;
                this.ready(), this.analytics.on("invoke", function(msg) {
                    msg && msg.obj && msg.obj.context && msg.obj.context.page && (msg.obj.context.page = void 0, 
                    _this.ready());
                });
            },
            loaded: function() {
                return !0;
            }
        }), exports.default = BeforeSendIntegration;
    }, /* 234 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _objectWithoutProperties2 = __webpack_require__(235), _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2), _stringify = __webpack_require__(65), _stringify2 = _interopRequireDefault(_stringify), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _analyticsWebTypes = __webpack_require__(11), _SafeLocalStorage = __webpack_require__(118), _SafeLocalStorage2 = _interopRequireDefault(_SafeLocalStorage), UIViewedEvent = function UIViewedEvent(productInfo, getContext, onEvent) {
            var _this = this, settings = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            if ((0, _classCallCheck3.default)(this, UIViewedEvent), this.start = function() {
                _this._startInterval(), _this._bindEventListeners();
            }, this.stop = function() {
                _this._stopInterval(), _this._unbindEventListeners();
            }, this.resetTimers = function() {
                _this._intervalId && (_this.stop(), _this.start());
            }, this._bindEventListeners = function() {
                window.addEventListener("focus", _this._focusListener), window.addEventListener("blur", _this._blurListener);
            }, this._unbindEventListeners = function() {
                window.removeEventListener("focus", _this._focusListener), window.removeEventListener("blur", _this._blurListener);
            }, this._startInterval = function() {
                clearInterval(_this._intervalId), _this._intervalId = setInterval(_this._handleInterval, _this._delay);
            }, this._stopInterval = function() {
                _this._intervalId && (clearInterval(_this._intervalId), _this._intervalId = null);
            }, this._getProductKey = function(product, subproduct) {
                var productKey = product;
                return subproduct && (productKey += "-" + subproduct), productKey;
            }, this._getLastSentTimestamp = function(productKey, tenantId, userId) {
                return (((_this._parseLocalStorageData() || {})[userId] || {})[tenantId] || {})[productKey] || null;
            }, this._parseLocalStorageData = function() {
                var data = _this._safeLocalStorage.getItem(_this._storageKey);
                try {
                    return JSON.parse(data);
                } catch (error) {
                    return _this._safeLocalStorage.removeItem(_this._storageKey), null;
                }
            }, this._setLastSentTimestamp = function(productKey, tenantId, userId) {
                var json = JSON.parse(_this._safeLocalStorage.getItem(_this._storageKey)) || {}, u = json[userId] || {}, t = u[tenantId] || {};
                t[productKey] = Date.now(), u[tenantId] = t, json[userId] = u, _this._safeLocalStorage.setItem(_this._storageKey, (0, 
                _stringify2.default)(json));
            }, this._shouldSendEvent = function(productKey, tenantIdType, tenantId, userId) {
                return !!document.hasFocus() && (!(tenantIdType !== _analyticsWebTypes.tenantType.NONE && !tenantId || !userId) && Date.now() - _this._getLastSentTimestamp(productKey, tenantId, userId) > _this._throttle);
            }, this._handleInterval = function() {
                var _getContext = _this._getContext(), embeddedProduct = _getContext.embeddedProduct, context = (0, 
                _objectWithoutProperties3.default)(_getContext, [ "embeddedProduct" ]);
                _this._sendEvent(_this._product, context), embeddedProduct && _this._sendEvent(embeddedProduct, context, !0);
            }, this._sendEvent = function(product, context, isEmbeddedProduct) {
                var subproduct = context.subproduct, tenantIdType = context.tenantIdType, tenantId = context.tenantId, userId = context.userId, lastScreenEvent = context.lastScreenEvent, productKey = _this._getProductKey(product, subproduct);
                if (_this._shouldSendEvent(productKey, tenantIdType, tenantId, userId)) {
                    _this._setLastSentTimestamp(productKey, tenantId, userId);
                    var event = _this._createEvent(product, subproduct, isEmbeddedProduct, lastScreenEvent);
                    _this._onEvent(event);
                }
            }, this._createEvent = function(product, subproduct, isEmbeddedProduct, lastScreenEvent) {
                var event = {
                    product: product,
                    source: "ui",
                    action: "viewed",
                    actionSubject: "ui"
                };
                // Clear the subproduct and version as they don't relate to the embedded product
                return isEmbeddedProduct && (event.subproduct = null, event.version = null, event.attributes = {
                    embeddedInEnv: _this._productInfo.env,
                    embeddedInProduct: _this._productInfo.product,
                    embeddedInSubproduct: subproduct,
                    embeddedInVersion: _this._productInfo.version,
                    embeddedInOrigin: _this._productInfo.origin,
                    embeddedInPlatform: _this._productInfo.platform
                }), lastScreenEvent && (event.attributes = (0, _extends3.default)({}, event.attributes, {
                    lastScreenEvent: {
                        name: lastScreenEvent.name,
                        attributes: lastScreenEvent.attributes
                    }
                })), event;
            }, !productInfo) throw new Error("Missing productInfo");
            if (!productInfo.product) throw new Error("Missing productInfo.product");
            if (!getContext) throw new Error("Missing getContext callback");
            if ("function" != typeof getContext) throw new Error("Invalid getContext, must be function");
            if (!onEvent) throw new Error("Missing onEvent callback");
            if ("function" != typeof onEvent) throw new Error("Invalid onEvent, must be function");
            this._productInfo = productInfo, this._product = productInfo.product, this._getContext = getContext, 
            this._onEvent = onEvent, this._delay = settings.delay || 2e3, this._throttle = settings.throttle || 36e5, 
            this._storageKey = settings.storageKey || "ui.viewed.last.sent", this._safeLocalStorage = new _SafeLocalStorage2.default(this._productInfo.env), 
            this._focusListener = function() {
                _this._startInterval();
            }, this._blurListener = function() {
                _this._stopInterval();
            };
        };
        exports.default = UIViewedEvent;
    }, /* 235 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0, exports.default = function(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        };
    }, /* 236 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(237),
            __esModule: !0
        };
    }, /* 237 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(238), module.exports = __webpack_require__(0).Object.freeze;
    }, /* 238 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.5 Object.freeze(O)
        var isObject = __webpack_require__(14), meta = __webpack_require__(42).onFreeze;
        __webpack_require__(64)("freeze", function($freeze) {
            return function(it) {
                return $freeze && isObject(it) ? $freeze(meta(it)) : it;
            };
        });
    }, /* 239 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(240), module.exports = __webpack_require__(0).Object.getPrototypeOf;
    }, /* 240 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 Object.getPrototypeOf(O)
        var toObject = __webpack_require__(31), $getPrototypeOf = __webpack_require__(87);
        __webpack_require__(64)("getPrototypeOf", function() {
            return function(it) {
                return $getPrototypeOf(toObject(it));
            };
        });
    }, /* 241 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(242),
            __esModule: !0
        };
    }, /* 242 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(243), module.exports = __webpack_require__(0).Object.setPrototypeOf;
    }, /* 243 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export = __webpack_require__(3);
        $export($export.S, "Object", {
            setPrototypeOf: __webpack_require__(244).set
        });
    }, /* 244 */
    /***/
    function(module, exports, __webpack_require__) {
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */
        var isObject = __webpack_require__(14), anObject = __webpack_require__(13), check = function(O, proto) {
            if (anObject(O), !isObject(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!");
        };
        module.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? // eslint-disable-line
            function(test, buggy, set) {
                try {
                    set = __webpack_require__(30)(Function.call, __webpack_require__(91).f(Object.prototype, "__proto__").set, 2), 
                    set(test, []), buggy = !(test instanceof Array);
                } catch (e) {
                    buggy = !0;
                }
                return function(O, proto) {
                    return check(O, proto), buggy ? O.__proto__ = proto : set(O, proto), O;
                };
            }({}, !1) : void 0),
            check: check
        };
    }, /* 245 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(246),
            __esModule: !0
        };
    }, /* 246 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(247);
        var $Object = __webpack_require__(0).Object;
        module.exports = function(P, D) {
            return $Object.create(P, D);
        };
    }, /* 247 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(3);
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, "Object", {
            create: __webpack_require__(38)
        });
    }, /* 248 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _map = __webpack_require__(123), _map2 = _interopRequireDefault(_map), _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(29), _createClass3 = _interopRequireDefault(_createClass2), _performance = __webpack_require__(264), _performance2 = _interopRequireDefault(_performance), _pageVisibility = __webpack_require__(127), _pageVisibility2 = _interopRequireDefault(_pageVisibility), _analyticsWebTypes = __webpack_require__(11), ApdexEvent = function() {
            function ApdexEvent(onEvent, pageVisibility) {
                var _this = this;
                if ((0, _classCallCheck3.default)(this, ApdexEvent), this._getEventKey = function(_ref) {
                    var task = _ref.task, taskId = _ref.taskId;
                    return taskId ? task + "." + taskId : task;
                }, this._getEventTimingByName = function(name) {
                    var eventTimings = _this._performance.getEntriesByName(name);
                    return eventTimings[eventTimings.length - 1];
                }, this._getApdexFields = function(event) {
                    var apdexTimings = _this._getApdexTimings(event), apdexScore = _this._calculateApdex({
                        duration: apdexTimings.duration,
                        threshold: event.threshold
                    });
                    return (0, _extends3.default)({}, apdexTimings, {
                        apdex: apdexScore
                    });
                }, this._getApdexTimings = function(event) {
                    var eventKey = _this._getEventKey(event), eventStartName = eventKey + "-start", startTime = event.startTime || _this._getStartTime(event, eventStartName), stopTime = event.stopTime || _this._getStopTime();
                    // We do some clean up of the marks and started events
                    return _this._cleanApdexState(eventKey), {
                        startTime: startTime,
                        stopTime: stopTime,
                        duration: stopTime - startTime
                    };
                }, this._getStartTime = function(event, eventName) {
                    var startTime = void 0, timeOrigin = _this._performance.getTimeOrigin();
                    if (event.type === _analyticsWebTypes.apdexType.INITIAL_LOAD) startTime = timeOrigin; else {
                        startTime = timeOrigin + _this._getEventTimingByName(eventName).startTime;
                    }
                    return startTime;
                }, this._getStopTime = function() {
                    return _this._performance.getTimeOrigin() + _this._performance.now();
                }, this._cleanApdexState = function(eventKey) {
                    _this._performance.clearMarks(eventKey + "-start"), _this._performance.clearMarks(eventKey + "-stop"), 
                    _this._startedEvents.delete(eventKey);
                }, this._getVisibilityFields = function(event) {
                    var isActiveTab = void 0;
                    /**
       * For initialLoad type:
       * 1. if tab was not ever hidden (!_wasPreviouslyHidden)
       *
       * For transition type:
       * 1. active status is tracked in active events map (_isActiveEvents)
       *
       * For any type, if startTime or stopTime is specified:
       * 1. If currently active (!_isHidden)
       */
                    if (event.type === _analyticsWebTypes.apdexType.INITIAL_LOAD) isActiveTab = !_this._wasPreviouslyHidden; else if (event.type === _analyticsWebTypes.apdexType.TRANSITION) {
                        var eventKey = _this._getEventKey(event);
                        isActiveTab = _this._isActiveEvents.get(eventKey);
                    }
                    return (event.startTime || event.stopTime) && (isActiveTab = !_this._pageVisibility.getIsHidden()), 
                    {
                        isActiveTab: isActiveTab
                    };
                }, this._calculateApdex = function(_ref2) {
                    var duration = _ref2.duration, _ref2$threshold = _ref2.threshold, threshold = void 0 === _ref2$threshold ? _this._threshold : _ref2$threshold, satisfiedThreshold = threshold, tolerableThreshold = 4 * threshold;
                    return duration <= satisfiedThreshold ? 1 : duration <= tolerableThreshold ? .5 : 0;
                }, this._validateStartEvent = function(event) {
                    if (!event) throw new Error('Missing "event" in Apdex start event');
                    if (!event.task) throw new Error('Missing "task" in Apdex start event');
                    if ("string" != typeof event.task) throw new Error('Invalid "task" in Apdex start event');
                    if (event.taskId && "string" != typeof event.taskId) throw new Error('Invalid "taskId" in Apdex start event');
                }, this._validateStopEvent = function(event) {
                    if (!event) throw new Error('Missing "event" in Apdex stop event');
                    if (!event.task) throw new Error('Missing "task" in Apdex stop event');
                    if ("string" != typeof event.task) throw new Error('Invalid "task" in Apdex stop event');
                    if (event.taskId && "string" != typeof event.taskId) throw new Error('Invalid "taskId" in Apdex stop event');
                    if (!event.type) throw new Error('Missing "type" in Apdex stop event');
                    if (event.type && !(0, _analyticsWebTypes.isType)(_analyticsWebTypes.apdexType, event.type)) throw new Error('Invalid "type" in Apdex stop event');
                    if (event.threshold && "number" != typeof event.threshold) throw new Error('Invalid "threshold" in Apdex stop event');
                    /*
       * For a transition, if the startTime was not specified,
       * the start event should have been present.
       */
                    if (!event.startTime && event.type === _analyticsWebTypes.apdexType.TRANSITION) {
                        var eventKey = _this._getEventKey(event);
                        if (!_this._startedEvents.has(eventKey)) throw new Error('Apdex event transition "' + eventKey + '" was not started');
                    }
                    if (event.startTime && !("number" == typeof event.startTime && event.startTime >= 0)) throw new Error('Invalid "startTime" in Apdex stop event');
                    if (event.stopTime && "number" != typeof event.stopTime) throw new Error('Invalid "stopTime" in Apdex stop event');
                    if (event.stopTime <= event.startTime) throw new Error('"stopTime" should be greater than "startTime" in Apdex stop event');
                }, this._shouldSendEvent = function(event) {
                    return !!event && "number" == typeof event.apdex;
                }, this._sendEvent = function(event, callback) {
                    _this._shouldSendEvent(event) && _this._onEvent({
                        source: "ui",
                        action: "readyForUser",
                        actionSubject: "ui",
                        attributes: (0, _extends3.default)({}, event.additionalAttributes, {
                            task: event.task,
                            taskId: event.taskId,
                            type: event.type,
                            threshold: event.threshold || _this._threshold,
                            apdex: event.apdex,
                            startTime: event.startTime,
                            stopTime: event.stopTime,
                            duration: event.duration,
                            isActiveTab: event.isActiveTab
                        })
                    }, callback);
                }, !onEvent) throw new Error("Missing onEvent callback");
                if ("function" != typeof onEvent) throw new Error("Invalid onEvent, must be function");
                if (!(pageVisibility instanceof _pageVisibility2.default)) throw new Error("Invalid pageVisibility, must be PageVisibility class");
                this._startedEvents = new _map2.default(), this._performance = new _performance2.default(), 
                this._onEvent = onEvent, this._threshold = 1e3, this._wasPreviouslyHidden = pageVisibility.getIsHidden(), 
                this._isActiveEvents = new _map2.default(), this._pageVisibility = pageVisibility, 
                this._pageVisibility.addCallback("apdexEvent", function(isHidden) {
                    _this.onVisibilityChange(!isHidden);
                });
            }
            return (0, _createClass3.default)(ApdexEvent, [ {
                key: "start",
                value: function(event) {
                    if (this._validateStartEvent(event), this._performance.isAvailable()) {
                        var eventKey = this._getEventKey(event), eventStartName = eventKey + "-start";
                        this._startedEvents.set(eventKey, !0), this._isActiveEvents.set(eventKey, !this._pageVisibility.getIsHidden()), 
                        this._performance.clearMarks(eventStartName), this._performance.mark(eventStartName);
                    }
                }
            }, {
                key: "getStart",
                value: function(event) {
                    if (this._validateStartEvent(event), this._performance.isAvailable()) {
                        var eventKey = this._getEventKey(event), eventStartName = eventKey + "-start";
                        return this._getEventTimingByName(eventStartName);
                    }
                }
            }, {
                key: "stop",
                value: function(event, callback) {
                    if (this._validateStopEvent(event), this._performance.isAvailable()) {
                        var apdexFields = this._getApdexFields(event), visibilityFields = this._getVisibilityFields(event);
                        this._sendEvent((0, _extends3.default)({}, event, apdexFields, visibilityFields), callback);
                    }
                }
            }, {
                key: "onVisibilityChange",
                value: function(isActive) {
                    var _this2 = this;
                    isActive || (this._wasPreviouslyHidden = !0, this._isActiveEvents.forEach(function(value, key) {
                        return _this2._isActiveEvents.set(key, !1);
                    }));
                }
            } ]), ApdexEvent;
        }();
        exports.default = ApdexEvent;
    }, /* 249 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(92), __webpack_require__(35), __webpack_require__(41), __webpack_require__(250), 
        __webpack_require__(259), module.exports = __webpack_require__(0).Map;
    }, /* 250 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var strong = __webpack_require__(251);
        // 23.1 Map Objects
        module.exports = __webpack_require__(255)("Map", function(get) {
            return function() {
                return get(this, arguments.length > 0 ? arguments[0] : void 0);
            };
        }, {
            // 23.1.3.6 Map.prototype.get(key)
            get: function(key) {
                var entry = strong.getEntry(this, key);
                return entry && entry.v;
            },
            // 23.1.3.9 Map.prototype.set(key, value)
            set: function(key, value) {
                return strong.def(this, 0 === key ? 0 : key, value);
            }
        }, strong, !0);
    }, /* 251 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var dP = __webpack_require__(7).f, create = __webpack_require__(38), redefineAll = __webpack_require__(124), ctx = __webpack_require__(30), anInstance = __webpack_require__(125), defined = __webpack_require__(36), forOf = __webpack_require__(78), $iterDefine = __webpack_require__(52), step = __webpack_require__(88), setSpecies = __webpack_require__(254), DESCRIPTORS = __webpack_require__(8), fastKey = __webpack_require__(42).fastKey, SIZE = DESCRIPTORS ? "_s" : "size", getEntry = function(that, key) {
            // fast case
            var entry, index = fastKey(key);
            if ("F" !== index) return that._i[index];
            // frozen object case
            for (entry = that._f; entry; entry = entry.n) if (entry.k == key) return entry;
        };
        module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function(that, iterable) {
                    anInstance(that, C, NAME, "_i"), that._i = create(null), // index
                    that._f = void 0, // first entry
                    that._l = void 0, // last entry
                    that[SIZE] = 0, // size
                    void 0 != iterable && forOf(iterable, IS_MAP, that[ADDER], that);
                });
                return redefineAll(C.prototype, {
                    // 23.1.3.1 Map.prototype.clear()
                    // 23.2.3.2 Set.prototype.clear()
                    clear: function() {
                        for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) entry.r = !0, 
                        entry.p && (entry.p = entry.p.n = void 0), delete data[entry.i];
                        that._f = that._l = void 0, that[SIZE] = 0;
                    },
                    // 23.1.3.3 Map.prototype.delete(key)
                    // 23.2.3.4 Set.prototype.delete(value)
                    delete: function(key) {
                        var that = this, entry = getEntry(that, key);
                        if (entry) {
                            var next = entry.n, prev = entry.p;
                            delete that._i[entry.i], entry.r = !0, prev && (prev.n = next), next && (next.p = prev), 
                            that._f == entry && (that._f = next), that._l == entry && (that._l = prev), that[SIZE]--;
                        }
                        return !!entry;
                    },
                    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                    forEach: function(callbackfn) {
                        anInstance(this, C, "forEach");
                        for (var entry, f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3); entry = entry ? entry.n : this._f; ) // revert to the last existing entry
                        for (f(entry.v, entry.k, this); entry && entry.r; ) entry = entry.p;
                    },
                    // 23.1.3.7 Map.prototype.has(key)
                    // 23.2.3.7 Set.prototype.has(value)
                    has: function(key) {
                        return !!getEntry(this, key);
                    }
                }), DESCRIPTORS && dP(C.prototype, "size", {
                    get: function() {
                        return defined(this[SIZE]);
                    }
                }), C;
            },
            def: function(that, key, value) {
                var prev, index, entry = getEntry(that, key);
                // change existing entry
                // add to index
                return entry ? entry.v = value : (that._l = entry = {
                    i: index = fastKey(key, !0),
                    // <- index
                    k: key,
                    // <- key
                    v: value,
                    // <- value
                    p: prev = that._l,
                    // <- previous entry
                    n: void 0,
                    // <- next entry
                    r: !1
                }, that._f || (that._f = entry), prev && (prev.n = entry), that[SIZE]++, "F" !== index && (that._i[index] = entry)), 
                that;
            },
            getEntry: getEntry,
            setStrong: function(C, NAME, IS_MAP) {
                // add .keys, .values, .entries, [@@iterator]
                // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
                $iterDefine(C, NAME, function(iterated, kind) {
                    this._t = iterated, // target
                    this._k = kind, // kind
                    this._l = void 0;
                }, function() {
                    // revert to the last existing entry
                    for (var that = this, kind = that._k, entry = that._l; entry && entry.r; ) entry = entry.p;
                    // get next entry
                    // get next entry
                    // return step by kind
                    // or finish the iteration
                    return that._t && (that._l = entry = entry ? entry.n : that._t._f) ? "keys" == kind ? step(0, entry.k) : "values" == kind ? step(0, entry.v) : step(0, [ entry.k, entry.v ]) : (that._t = void 0, 
                    step(1));
                }, IS_MAP ? "entries" : "values", !IS_MAP, !0), // add [@@species], 23.1.2.2, 23.2.2.2
                setSpecies(NAME);
            }
        };
    }, /* 252 */
    /***/
    function(module, exports, __webpack_require__) {
        // call something on iterator step with safe closing on error
        var anObject = __webpack_require__(13);
        module.exports = function(iterator, fn, value, entries) {
            try {
                return entries ? fn(anObject(value)[0], value[1]) : fn(value);
            } catch (e) {
                var ret = iterator.return;
                throw void 0 !== ret && anObject(ret.call(iterator)), e;
            }
        };
    }, /* 253 */
    /***/
    function(module, exports, __webpack_require__) {
        // check on default Array iterator
        var Iterators = __webpack_require__(24), ITERATOR = __webpack_require__(2)("iterator"), ArrayProto = Array.prototype;
        module.exports = function(it) {
            return void 0 !== it && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
        };
    }, /* 254 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var global = __webpack_require__(6), core = __webpack_require__(0), dP = __webpack_require__(7), DESCRIPTORS = __webpack_require__(8), SPECIES = __webpack_require__(2)("species");
        module.exports = function(KEY) {
            var C = "function" == typeof core[KEY] ? core[KEY] : global[KEY];
            DESCRIPTORS && C && !C[SPECIES] && dP.f(C, SPECIES, {
                configurable: !0,
                get: function() {
                    return this;
                }
            });
        };
    }, /* 255 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var global = __webpack_require__(6), $export = __webpack_require__(3), meta = __webpack_require__(42), fails = __webpack_require__(18), hide = __webpack_require__(12), redefineAll = __webpack_require__(124), forOf = __webpack_require__(78), anInstance = __webpack_require__(125), isObject = __webpack_require__(14), setToStringTag = __webpack_require__(40), dP = __webpack_require__(7).f, each = __webpack_require__(256)(0), DESCRIPTORS = __webpack_require__(8);
        module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
            var Base = global[NAME], C = Base, ADDER = IS_MAP ? "set" : "add", proto = C && C.prototype, O = {};
            // create collection constructor
            return DESCRIPTORS && "function" == typeof C && (IS_WEAK || proto.forEach && !fails(function() {
                new C().entries().next();
            })) ? (C = wrapper(function(target, iterable) {
                anInstance(target, C, NAME, "_c"), target._c = new Base(), void 0 != iterable && forOf(iterable, IS_MAP, target[ADDER], target);
            }), each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
                var IS_ADDER = "add" == KEY || "set" == KEY;
                KEY in proto && (!IS_WEAK || "clear" != KEY) && hide(C.prototype, KEY, function(a, b) {
                    if (anInstance(this, C, KEY), !IS_ADDER && IS_WEAK && !isObject(a)) return "get" == KEY && void 0;
                    var result = this._c[KEY](0 === a ? 0 : a, b);
                    return IS_ADDER ? this : result;
                });
            }), "size" in proto && dP(C.prototype, "size", {
                get: function() {
                    return this._c.size;
                }
            })) : (C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER), redefineAll(C.prototype, methods), 
            meta.NEED = !0), setToStringTag(C, NAME), O[NAME] = C, $export($export.G + $export.W + $export.F, O), 
            IS_WEAK || common.setStrong(C, NAME, IS_MAP), C;
        };
    }, /* 256 */
    /***/
    function(module, exports, __webpack_require__) {
        // 0 -> Array#forEach
        // 1 -> Array#map
        // 2 -> Array#filter
        // 3 -> Array#some
        // 4 -> Array#every
        // 5 -> Array#find
        // 6 -> Array#findIndex
        var ctx = __webpack_require__(30), IObject = __webpack_require__(55), toObject = __webpack_require__(31), toLength = __webpack_require__(57), asc = __webpack_require__(257);
        module.exports = function(TYPE, $create) {
            var IS_MAP = 1 == TYPE, IS_FILTER = 2 == TYPE, IS_SOME = 3 == TYPE, IS_EVERY = 4 == TYPE, IS_FIND_INDEX = 6 == TYPE, NO_HOLES = 5 == TYPE || IS_FIND_INDEX, create = $create || asc;
            return function($this, callbackfn, that) {
                for (var val, res, O = toObject($this), self = IObject(O), f = ctx(callbackfn, that, 3), length = toLength(self.length), index = 0, result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0; length > index; index++) if ((NO_HOLES || index in self) && (val = self[index], 
                res = f(val, index, O), TYPE)) if (IS_MAP) result[index] = res; else if (res) switch (TYPE) {
                  case 3:
                    return !0;

                  // some
                    case 5:
                    return val;

                  // find
                    case 6:
                    return index;

                  // findIndex
                    case 2:
                    result.push(val);
                } else if (IS_EVERY) return !1;
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
            };
        };
    }, /* 257 */
    /***/
    function(module, exports, __webpack_require__) {
        // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
        var speciesConstructor = __webpack_require__(258);
        module.exports = function(original, length) {
            return new (speciesConstructor(original))(length);
        };
    }, /* 258 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14), isArray = __webpack_require__(89), SPECIES = __webpack_require__(2)("species");
        module.exports = function(original) {
            var C;
            // cross-realm fallback
            return isArray(original) && (C = original.constructor, "function" != typeof C || C !== Array && !isArray(C.prototype) || (C = void 0), 
            isObject(C) && null === (C = C[SPECIES]) && (C = void 0)), void 0 === C ? Array : C;
        };
    }, /* 259 */
    /***/
    function(module, exports, __webpack_require__) {
        // https://github.com/DavidBruant/Map-Set.prototype.toJSON
        var $export = __webpack_require__(3);
        $export($export.P + $export.R, "Map", {
            toJSON: __webpack_require__(260)("Map")
        });
    }, /* 260 */
    /***/
    function(module, exports, __webpack_require__) {
        // https://github.com/DavidBruant/Map-Set.prototype.toJSON
        var classof = __webpack_require__(76), from = __webpack_require__(261);
        module.exports = function(NAME) {
            return function() {
                if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
                return from(this);
            };
        };
    }, /* 261 */
    /***/
    function(module, exports, __webpack_require__) {
        var forOf = __webpack_require__(78);
        module.exports = function(iter, ITERATOR) {
            var result = [];
            return forOf(iter, !1, result.push, result, ITERATOR), result;
        };
    }, /* 262 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(263);
        var $Object = __webpack_require__(0).Object;
        module.exports = function(it, key, desc) {
            return $Object.defineProperty(it, key, desc);
        };
    }, /* 263 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(3);
        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export($export.S + $export.F * !__webpack_require__(8), "Object", {
            defineProperty: __webpack_require__(7).f
        });
    }, /* 264 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(29), _createClass3 = _interopRequireDefault(_createClass2), Performance = function() {
            function Performance() {
                (0, _classCallCheck3.default)(this, Performance), this._performance = window.performance;
            }
            return (0, _createClass3.default)(Performance, [ {
                key: "clearMarks",
                value: function() {
                    var _performance;
                    this._performance && this._performance.clearMarks && (_performance = this._performance).clearMarks.apply(_performance, arguments);
                }
            }, {
                key: "mark",
                value: function() {
                    var _performance2;
                    this._performance && this._performance.mark && (_performance2 = this._performance).mark.apply(_performance2, arguments);
                }
            }, {
                key: "getEntriesByName",
                value: function() {
                    var _performance3;
                    return this._performance && this._performance.getEntriesByName ? (_performance3 = this._performance).getEntriesByName.apply(_performance3, arguments) : [];
                }
            }, {
                key: "getTimeOrigin",
                value: function() {
                    return this._performance && (this._performance.timeOrigin || this._performance.timing) ? this._performance.timeOrigin || this._performance.timing.navigationStart : 0;
                }
            }, {
                key: "now",
                value: function() {
                    return this._performance && this._performance.now ? this._performance.now() : Date.now ? Date.now() : +new Date();
                }
            }, {
                key: "isAvailable",
                value: function() {
                    return !!(this._performance && this._performance.clearMarks && this._performance.mark && this._performance.getEntriesByName && this._performance.timing);
                }
            } ]), Performance;
        }();
        exports.default = Performance;
    }, /* 265 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(29), _createClass3 = _interopRequireDefault(_createClass2), _uuid = __webpack_require__(128), _uuid2 = _interopRequireDefault(_uuid), _SafeSessionStorage = __webpack_require__(79), _SafeSessionStorage2 = _interopRequireDefault(_SafeSessionStorage), STORAGE_KEY = "tab.id", TabTracking = function() {
            function TabTracking() {
                var _this = this;
                (0, _classCallCheck3.default)(this, TabTracking), this._generateNewTabId = function() {
                    var newTabId = (0, _uuid2.default)();
                    return _this._safeSessionStorage.setItem(STORAGE_KEY, newTabId), newTabId;
                }, this._safeSessionStorage = new _SafeSessionStorage2.default();
            }
            return (0, _createClass3.default)(TabTracking, [ {
                key: "getCurrentTabId",
                value: function() {
                    var tabId = this._safeSessionStorage.getItem(STORAGE_KEY);
                    return tabId || (tabId = this._generateNewTabId()), tabId;
                }
            } ]), TabTracking;
        }();
        exports.default = TabTracking;
    }, /* 266 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(29), _createClass3 = _interopRequireDefault(_createClass2), _SafeLocalStorage = __webpack_require__(118), _SafeLocalStorage2 = _interopRequireDefault(_SafeLocalStorage), SESSION_ID_STORAGE_KEY = "session.id", SESSION_EXPIRY_STORAGE_KEY = "session.expiry", ONLY_NUMBERS_REGEX = /^\d+$/, DEFAULT_SESSION_EXPIRY_TIME_MS = 18e5, SessionTracking = function() {
            function SessionTracking(options) {
                var _this = this;
                (0, _classCallCheck3.default)(this, SessionTracking), this._generateNewSessionId = function() {
                    var newSessionId = Date.now().toString();
                    return _this._safeLocalStorage.setItem(SESSION_ID_STORAGE_KEY, newSessionId), newSessionId;
                }, this._updateSessionExpiry = function() {
                    var expiry = Date.now() + _this._sessionExpiryTime;
                    return _this._safeLocalStorage.setItem(SESSION_EXPIRY_STORAGE_KEY, expiry), expiry;
                }, this._sessionExpiryTime = options ? options.sessionExpiryTime || DEFAULT_SESSION_EXPIRY_TIME_MS : DEFAULT_SESSION_EXPIRY_TIME_MS, 
                this._safeLocalStorage = new _SafeLocalStorage2.default();
            }
            return (0, _createClass3.default)(SessionTracking, [ {
                key: "getCurrentSessionId",
                value: function() {
                    var sessionId = this._safeLocalStorage.getItem(SESSION_ID_STORAGE_KEY), sessionExpiry = parseInt(this._safeLocalStorage.getItem(SESSION_EXPIRY_STORAGE_KEY), 10);
                    // Old versions of sessionId were UUIDs which caused issues for Amplitude which only accepts
                    // integers for this field. In these scenarios we want to regenerate the sessionId as an integer
                    return this._updateSessionExpiry(), !sessionId || sessionExpiry <= Date.now() || isNaN(sessionExpiry) ? this._generateNewSessionId() : ONLY_NUMBERS_REGEX.test(sessionId) ? sessionId : this._generateNewSessionId();
                }
            } ]), SessionTracking;
        }();
        exports.default = SessionTracking;
    }, /* 267 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _keys = __webpack_require__(16), _keys2 = _interopRequireDefault(_keys), _values = __webpack_require__(80), _values2 = _interopRequireDefault(_values), _assign = __webpack_require__(43), _assign2 = _interopRequireDefault(_assign), _stringify = __webpack_require__(65), _stringify2 = _interopRequireDefault(_stringify), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _queryString = __webpack_require__(129), _uuid = __webpack_require__(128), _uuid2 = _interopRequireDefault(_uuid), _objectUtils = __webpack_require__(130), _urlUtils = __webpack_require__(81), _urlUtils2 = _interopRequireDefault(_urlUtils), _analyticsWebTypes = __webpack_require__(11), _SafeSessionStorage = __webpack_require__(79), _SafeSessionStorage2 = _interopRequireDefault(_SafeSessionStorage), INIT_KEY = "taskSessionsInit", TaskSessionStore = function TaskSessionStore() {
            (0, _classCallCheck3.default)(this, TaskSessionStore), _initialiseProps.call(this);
            var currentTimestamp = Date.now();
            this._safeSessionStorage = new _SafeSessionStorage2.default();
            // Wrapping all sessionStorage calls in try catch to stop any error propogation, taskSessions should gracefully fail.
            try {
                this._taskSessionsNotRecentlyInitialised(currentTimestamp) && (this._writeToSessionStorage({}), 
                this._safeSessionStorage.setItem(INIT_KEY, currentTimestamp));
            } catch (e) {}
        }, _initialiseProps = function() {
            var _this = this;
            this._taskSessionsNotRecentlyInitialised = function(currentTimestamp) {
                return null === _this._safeSessionStorage.getItem("taskSessions") || null === _this._safeSessionStorage.getItem(INIT_KEY) || _this._safeSessionStorage.getItem(INIT_KEY) < currentTimestamp - 3e3;
            }, this._removeTaskSessionPrefix = function(_, taskSessionName) {
                return taskSessionName.split("awc.")[1];
            }, this._isTaskSessionQueryParam = function(_, taskSessionName) {
                return taskSessionName.startsWith("awc.");
            }, this.getAllTaskSessions = function() {
                try {
                    return JSON.parse(_this._safeSessionStorage.getItem("taskSessions"));
                } catch (e) {
                    return {};
                }
            }, this._writeToSessionStorage = function(taskSessions) {
                try {
                    _this._safeSessionStorage.setItem("taskSessions", (0, _stringify2.default)(taskSessions));
                } catch (e) {}
            }, this._appendTaskSessions = function(newTaskSessions) {
                var currentState = _this.getAllTaskSessions(), newState = null === currentState ? newTaskSessions : (0, 
                _assign2.default)(currentState, newTaskSessions);
                _this._writeToSessionStorage(newState);
            }, this.createTaskSession = function(taskSessionName) {
                var taskSessionId = (0, _uuid2.default)(), newTaskSessions = {};
                return newTaskSessions[taskSessionName] = taskSessionId, _this._appendTaskSessions(newTaskSessions), 
                taskSessionId;
            }, this.createTaskSessionWithProvidedId = function(taskSessionName, taskSessionId) {
                if ("string" != typeof taskSessionId) throw new TypeError("invalid taskSessionId, must be string");
                var newTaskSessions = {};
                newTaskSessions[taskSessionName] = taskSessionId, _this._appendTaskSessions(newTaskSessions);
            }, this.completeTaskSession = function(taskSessionName) {
                var currentState = _this.getAllTaskSessions();
                delete currentState[taskSessionName], _this._writeToSessionStorage(currentState);
            }, this.formatTaskSessionQueryString = function(_ref) {
                var uri = _ref.uri, includedTaskSessions = _ref.includedTaskSessions, _parseUrl = (0, 
                _queryString.parseUrl)(uri), url = _parseUrl.url, query = _parseUrl.query, currentState = _this.getAllTaskSessions(), filteredTaskSessions = includedTaskSessions ? (0, 
                _objectUtils.pick)(currentState, includedTaskSessions) : (0, _objectUtils.omit)(currentState, (0, 
                _values2.default)(_analyticsWebTypes.originTracingType));
                if (0 === (0, _keys2.default)(filteredTaskSessions).length) return uri;
                var queryWithTaskSessions = (0, _extends3.default)({}, (0, _objectUtils.mapKeys)(filteredTaskSessions, function(_, taskSessionName) {
                    return "awc." + taskSessionName;
                }), query);
                return url + "?" + (0, _queryString.stringify)(queryWithTaskSessions);
            }, this.stripQueryParameters = function() {
                var extractedTaskSessions = (0, _objectUtils.mapKeys)((0, _urlUtils2.default)(_this._isTaskSessionQueryParam), _this._removeTaskSessionPrefix);
                _this._appendTaskSessions(extractedTaskSessions);
            };
        };
        exports.default = TaskSessionStore;
    }, /* 268 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(269), module.exports = __webpack_require__(0).Object.values;
    }, /* 269 */
    /***/
    function(module, exports, __webpack_require__) {
        // https://github.com/tc39/proposal-object-values-entries
        var $export = __webpack_require__(3), $values = __webpack_require__(110)(!1);
        $export($export.S, "Object", {
            values: function(it) {
                return $values(it);
            }
        });
    }, /* 270 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(str) {
            return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        };
    }, /* 271 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function toObject(val) {
            if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
        /* eslint-disable no-unused-vars */
        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        module.exports = function() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                var test1 = new String("abc");
                if (// eslint-disable-line no-new-wrappers
                test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                if ("0123456789" !== Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                }).join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, /* 272 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function decodeComponents(components, split) {
            try {
                // Try to decode the entire string first
                return decodeURIComponent(components.join(""));
            } catch (err) {}
            if (1 === components.length) return components;
            split = split || 1;
            // Split the array in 2 parts
            var left = components.slice(0, split), right = components.slice(split);
            return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
        }
        function decode(input) {
            try {
                return decodeURIComponent(input);
            } catch (err) {
                for (var tokens = input.match(singleMatcher), i = 1; i < tokens.length; i++) input = decodeComponents(tokens, i).join(""), 
                tokens = input.match(singleMatcher);
                return input;
            }
        }
        function customDecodeURIComponent(input) {
            for (// Keep track of all the replacements and prefill the map with the `BOM`
            var replaceMap = {
                "%FE%FF": "",
                "%FF%FE": ""
            }, match = multiMatcher.exec(input); match; ) {
                try {
                    // Decode as big chunks as possible
                    replaceMap[match[0]] = decodeURIComponent(match[0]);
                } catch (err) {
                    var result = decode(match[0]);
                    result !== match[0] && (replaceMap[match[0]] = result);
                }
                match = multiMatcher.exec(input);
            }
            // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
            replaceMap["%C2"] = "";
            for (var entries = Object.keys(replaceMap), i = 0; i < entries.length; i++) {
                // Replace all decoded components
                var key = entries[i];
                input = input.replace(new RegExp(key, "g"), replaceMap[key]);
            }
            return input;
        }
        var singleMatcher = new RegExp("%[a-f0-9]{2}", "gi"), multiMatcher = new RegExp("(%[a-f0-9]{2})+", "gi");
        module.exports = function(encodedURI) {
            if ("string" != typeof encodedURI) throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
            try {
                // Try the built in decoder first
                return encodedURI = encodedURI.replace(/\+/g, " "), decodeURIComponent(encodedURI);
            } catch (err) {
                // Fallback to a more advanced decoder
                return customDecodeURIComponent(encodedURI);
            }
        };
    }, /* 273 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _assign = __webpack_require__(43), _assign2 = _interopRequireDefault(_assign), _defineProperty2 = __webpack_require__(131), _defineProperty3 = _interopRequireDefault(_defineProperty2), _values = __webpack_require__(80), _values2 = _interopRequireDefault(_values), _keys = __webpack_require__(16), _keys2 = _interopRequireDefault(_keys), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _urlUtils = __webpack_require__(81), _urlUtils2 = _interopRequireDefault(_urlUtils), _analyticsWebTypes = __webpack_require__(11), OriginTracing = function OriginTracing() {
            (0, _classCallCheck3.default)(this, OriginTracing), this.handleOriginParameters = function(originParamHandlerMapping, historyReplaceFn) {
                // Collect all the parameter labels to be handled
                var originParamLabelList = (0, _keys2.default)(originParamHandlerMapping);
                if (!originParamLabelList.length > 0) throw new Error("Empty parameter mapping provided");
                // Check if the parameter labels are valid. If any invalid labels are found throw an exception.
                var invalidParams = originParamLabelList.filter(function(x) {
                    return (0, _values2.default)(_analyticsWebTypes.originTracingType).indexOf(x) < 0;
                });
                if (invalidParams.length > 0) throw new Error("Invalid Origin Tracing Parameter(s) supplied: " + invalidParams.join() + "!");
                var isCaptureParam = function(_, key) {
                    return originParamLabelList.indexOf(key) >= 0;
                }, capturedURLParams = (0, _urlUtils2.default)(isCaptureParam, historyReplaceFn), applyHandlerFunction = function(key) {
                    var x = originParamHandlerMapping[key](capturedURLParams[key]);
                    return (0, _defineProperty3.default)({}, key, x);
                };
                return (0, _keys2.default)(capturedURLParams).map(applyHandlerFunction).reduce(function(accumulator, currentValue) {
                    return (0, _assign2.default)(accumulator, currentValue);
                }, {});
            }, this._originStore = {};
        };
        exports.default = OriginTracing;
    }, /* 274 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function buildTenantFields(tenantInfo) {
            return {
                tenantIdType: tenantInfo.tenantIdType,
                tenantId: tenantInfo.tenantId
            };
        }
        function buildUserFields(userInfo) {
            return {
                userIdType: userInfo.userIdType
            };
        }
        function buildOrgFields(orgInfo) {
            return {
                orgId: orgInfo.orgId
            };
        }
        function getProductField(field, override) {
            return void 0 === override ? field : override;
        }
        function buildProductFields(productInfo, productOverrides) {
            var overrides = productOverrides || {};
            return {
                env: getProductField(productInfo.env, overrides.env),
                product: getProductField(productInfo.product, overrides.product),
                subproduct: getProductField(productInfo.subproduct(), overrides.subproduct),
                version: getProductField(productInfo.version, overrides.version),
                origin: getProductField(productInfo.origin, overrides.origin),
                platform: getProductField(productInfo.platform, overrides.platform)
            };
        }
        function isNotEmptyObject(obj) {
            return (0, _objectUtils.isPlainObject)(obj) && (0, _keys2.default)(obj).length > 0;
        }
        function buildAttributesWithName(name, attrObject) {
            return isNotEmptyObject(attrObject) ? (0, _defineProperty3.default)({}, name, attrObject) : void 0;
        }
        function buildAttributes(attributes) {
            return buildAttributesWithName("attributes", attributes);
        }
        function filterAndBuildContainers(containers) {
            var validContainers = {};
            return (0, _keys2.default)(containers).forEach(function(key) {
                var value = containers[key];
                validContainers[key] = {
                    id: value.id,
                    type: value.type
                };
            }), validContainers;
        }
        function buildContainersWithName(containers) {
            if (isNotEmptyObject(containers)) {
                return buildAttributesWithName("containers", filterAndBuildContainers(containers));
            }
        }
        function buildNonPrivacySafeAttributes(nonPrivacySafeAttributes) {
            return buildAttributesWithName("nonPrivacySafeAttributes", nonPrivacySafeAttributes);
        }
        function buildScreenEvent(productInfo, tenantInfo, userInfo, attributes, nonPrivacySafeAttributes, tags, tabId, sessionId, taskSessions, orgInfo, containers) {
            var productFields = buildProductFields(productInfo), tenantFields = buildTenantFields(tenantInfo), userFields = buildUserFields(userInfo), orgFields = buildOrgFields(orgInfo), overrides = {
                title: "",
                path: "",
                url: "",
                referrer: "",
                search: "",
                eventType: _analyticsWebTypes.eventType.SCREEN
            };
            return (0, _extends3.default)({}, productFields, tenantFields, userFields, orgFields, overrides, buildAttributes(attributes), buildNonPrivacySafeAttributes(nonPrivacySafeAttributes), buildContainersWithName(containers), {
                tags: tags,
                tabId: tabId,
                sessionId: sessionId,
                taskSessions: taskSessions
            });
        }
        function buildActionName(event) {
            return event.actionSubject + " " + event.action;
        }
        function buildContext(productInfo) {
            var screen = window.screen || {};
            return {
                context: {
                    locale: productInfo.locale,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        density: window.devicePixelRatio
                    },
                    library: {
                        name: "analytics.js",
                        version: _version2.default
                    }
                }
            };
        }
        function extractProductOverrides(event) {
            return {
                env: event.env,
                product: event.product,
                subproduct: event.subproduct,
                version: event.version,
                origin: event.origin,
                platform: event.platform
            };
        }
        function buildActionEvent(productInfo, tenantInfo, userInfo, event, actionEventType, tabId, sessionId, taskSessions, orgInfo) {
            var productFields = buildProductFields(productInfo, extractProductOverrides(event)), tenantFields = buildTenantFields(tenantInfo), orgFields = buildOrgFields(orgInfo), userFields = buildUserFields(userInfo), actionFields = (0, 
            _extends3.default)({
                containerType: event.containerType,
                containerId: event.containerId,
                source: event.source,
                objectType: event.objectType,
                objectId: event.objectId,
                actionSubject: event.actionSubject,
                action: event.action,
                actionSubjectId: event.actionSubjectId,
                attributes: event.attributes,
                nonPrivacySafeAttributes: event.nonPrivacySafeAttributes,
                tags: event.tags,
                eventType: actionEventType
            }, buildContainersWithName(event.containers));
            return (0, _extends3.default)({}, productFields, tenantFields, orgFields, userFields, actionFields, {
                tabId: tabId,
                sessionId: sessionId,
                taskSessions: taskSessions
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _defineProperty2 = __webpack_require__(131), _defineProperty3 = _interopRequireDefault(_defineProperty2), _keys = __webpack_require__(16), _keys2 = _interopRequireDefault(_keys);
        exports.filterAndBuildContainers = filterAndBuildContainers, exports.buildContainersWithName = buildContainersWithName, 
        exports.buildScreenEvent = buildScreenEvent, exports.buildActionName = buildActionName, 
        exports.buildContext = buildContext, exports.extractProductOverrides = extractProductOverrides, 
        exports.buildActionEvent = buildActionEvent;
        var _analyticsWebTypes = __webpack_require__(11), _version = __webpack_require__(275), _version2 = _interopRequireDefault(_version), _objectUtils = __webpack_require__(132);
    }, /* 275 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), // this file is autogenerated do no edit directly
        exports.default = "1.9.5";
    }, /* 276 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function wrapCallback(callback, event) {
            return cache.saveEvent(event), callback && "function" == typeof callback ? function() {
                callback(event);
            } : null;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = wrapCallback;
        var _testingCache = __webpack_require__(277), _testingCache2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(_testingCache), cache = new _testingCache2.default();
    }, /* 277 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _cookie = __webpack_require__(48), _cookie2 = _interopRequireDefault(_cookie), TestingCache = function TestingCache() {
            var _this = this;
            (0, _classCallCheck3.default)(this, TestingCache), this._bind = function() {
                window.testAnalytics || (window.testAnalytics = {
                    eventCache: [],
                    events: function() {
                        return window.testAnalytics.eventCache;
                    },
                    clear: function() {
                        window.testAnalytics.eventCache = [], localStorage.removeItem("awc.ui.viewed.last.sent"), 
                        localStorage.removeItem("awc-staging.ui.viewed.last.sent"), localStorage.removeItem("awc-dev.ui.viewed.last.sent"), 
                        localStorage.removeItem("awc-local.ui.viewed.last.sent");
                    }
                });
            }, this._cache = function(event) {
                window.testAnalytics.eventCache.length >= 100 && (window.testAnalytics.eventCache = window.testAnalytics.eventCache.slice(1, window.testAnalytics.eventCache.length)), 
                window.testAnalytics.eventCache.push(event);
            }, this._shouldCacheEvent = function() {
                return !!_cookie2.default.get("atlassian_analytics_debug");
            }, this.saveEvent = function(event) {
                event && _this._shouldCacheEvent() && (window.testAnalytics || _this._bind(), event.tags instanceof Array ? event.tags.push("synthetic") : event.tags = [ "synthetic" ], 
                _this._cache(event));
            }, this._shouldCacheEvent() && this._bind();
        };
        exports.default = TestingCache;
    }, /* 278 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), /**
 * Wraps {possibleFn} into a error-safe function and handles cases where {possibleFn}
 * is a function or object
 *
 * @param possibleFn - function that returns and object or the object itself
 * @param errorMessage - error message to log if {possibleFn} is a function and
 *                        throws an error when called
 * @returns {Function}
 */
        exports.default = function(possibleFn, errorMessage) {
            var isFunction = "function" == typeof possibleFn;
            return function() {
                if (isFunction) try {
                    return possibleFn();
                } catch (e) {
                    // eslint-disable-next-line no-console
                    return void console.error(errorMessage + " - " + e.message);
                }
                return possibleFn;
            };
        };
    }, /* 279 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        /**
 * TypeAheadHelper is helper file which assists in
 * tracking analytics around typeahead components, such as mentions, in
 * a consistent way. It generates objects that can be passed into
 * an instance of analyticsWebClient to trigger events.
 *
 * Example usage:
 *
 * const typeAheadHelper = new TypeAheadHelper(
 *   webClient.sendTrackEvent,
 *   baseEvent // an object containing the action + additional context attributes
 * );
 *
 * mentionHelper.search('abc');
 * mentionHelper.searched(resultsArray);
 * mentionHelper.selected(selectedIndex);
 */
        function combineWithBaseEvent(action, extraAttributes, baseEvent) {
            var event = (0, _extends3.default)({
                action: action
            }, baseEvent);
            return event.attributes = (0, _extends3.default)({}, extraAttributes, event.attributes), 
            event;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(29), _createClass3 = _interopRequireDefault(_createClass2), _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), TypeAheadHelper = function() {
            /**
   * Constructs a new instance of TypeAheadHelper.
   *
   * @param {Function} onEvent the function to call when an analytics event must be fired.
   *  There will be one argument, the analytics event object.
   * @param {Object} baseEvent base event with action and context to use when triggering events.
   *  More details here: https://product-fabric.atlassian.net/wiki/x/XQCZFg
   */
            function TypeAheadHelper(onEvent, baseEvent) {
                (0, _classCallCheck3.default)(this, TypeAheadHelper), this._onEvent = onEvent, this._baseEvent = baseEvent, 
                this._searchStartedTime = null, this._lastQueryResultsTime = null, this._queryLength = null, 
                this._baseEvent = (0, _extends3.default)({}, baseEvent);
            }
            /**
   * Records the start time of the first web request
   * and a copy of the query length for sending later in an analytics event.
   *
   * It should be called before the web request is initially made.
   *
   * @param {String} query the string entered as the query
   */
            return (0, _createClass3.default)(TypeAheadHelper, [ {
                key: "search",
                value: function(query) {
                    if (!query && "" !== query) throw new Error("Missing query param");
                    this._searchStartedTime = Date.now(), this._queryLength = (query || "").length;
                }
            }, {
                key: "searched",
                value: function(results) {
                    if (!results) throw new Error("Missing results param");
                    if (null === this._queryLength) throw new Error("search() must be called before searched().");
                    var responseTimeMs = Date.now() - this._searchStartedTime;
                    this._lastQueryResultsTime = Date.now(), this._lastResults = results;
                    var extraAttributes = {
                        responseTimeMs: responseTimeMs,
                        queryLength: this._queryLength,
                        results: results
                    }, event = combineWithBaseEvent("searched", extraAttributes, this._baseEvent);
                    this._onEvent(event);
                }
            }, {
                key: "selected",
                value: function(selectionIndex) {
                    if (!selectionIndex && 0 !== selectionIndex) throw new Error("Missing selectionIndex param");
                    if (!this._lastQueryResultsTime) throw new Error("searched() must be called before selected().");
                    var now = Date.now(), selectionTimeMs = now - this._lastQueryResultsTime, searchTimeMs = now - this._searchStartedTime, selectedResultValue = this._lastResults[selectionIndex], extraAttributes = {
                        queryLength: this._queryLength,
                        selectionIndex: selectionIndex,
                        selectionTimeMs: selectionTimeMs,
                        searchTimeMs: searchTimeMs,
                        selectedResultValue: selectedResultValue
                    }, event = combineWithBaseEvent("selected", extraAttributes, this._baseEvent);
                    this._onEvent(event);
                }
            } ]), TypeAheadHelper;
        }();
        exports.default = TypeAheadHelper;
    }, /* 280 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _timeme = __webpack_require__(281), _timeme2 = _interopRequireDefault(_timeme), _eventValidation = __webpack_require__(82), DEFAULT_TIMING = {
            initialPollInterval: 5,
            pollBackoffRate: 2,
            idleTimeout: 30
        }, DwellTimeHelper = /**
 * Callback for sending a 'track' analytics event. This callback should either be the
 * 'sendTrackEvent' method on the AnalyticsWebClient, or a method that eventually delegates to it.
 * The data for the dwell event will be passed to this method for sending.
 *
 * @callback trackCallback
 * @param {Object} eventData - the base event data that will be added to the track event.
 */
        /**
 * Creates and initialises the DwellTimeHelper.
 *
 * @param {trackCallback} trackCallback - the track callback responsible for actually sending
 * the event.
 * @param {Object} eventData - the base data that will be added to the track event.
 * Additional dwell time attributes will be appended to this data. Note that you don't need to
 * include the 'action' property, as this will be added automatically.
 * @param {?string} searchSessionId - a unique identifier for the related search session.
 * @param {?Object} timingOptions - for the purpose of debugging, you can override the default
 * timing used for measuring dwell time. The following values are possible:
 * - initialPollInterval: how long to wait before the first dwell milestone event
 * is fired (in seconds). Default = 5.
 * - pollBackoffRate: how much to multiply the last poll interval by on each dwell milestone.
 * event. Default = 2.
 * - idleTimeout: how long to wait for no user activity before pausing
 * the dwell timer (in seconds). Default = 30s.
 */
        function DwellTimeHelper(trackCallback, eventData, searchSessionId, timingOptions) {
            if ((0, _classCallCheck3.default)(this, DwellTimeHelper), _initialiseProps.call(this), 
            !trackCallback) throw new Error("trackCallback is required for DwellTimeHelper");
            (0, _eventValidation.validateDwellBaseEvent)(eventData), this._trackCallback = trackCallback, 
            this._eventData = eventData, this._searchSessionId = searchSessionId, this._timing = (0, 
            _extends3.default)({}, DEFAULT_TIMING, timingOptions);
        }, _initialiseProps = function() {
            var _this = this;
            this.start = function() {
                if (_timeme2.default.active) throw new Error("DwellTimeHelper should only be initialised once per page load.");
                _this._initDwellTimeCounterAndPolling(), window.addEventListener("beforeunload", function() {
                    _this.stop();
                });
            }, this.stop = function() {
                _timeme2.default.active && _this._sendDwellEvent(_this._eventData, _this._searchSessionId, !0), 
                _timeme2.default.stopAllTimers(), _timeme2.default.resetAllRecordedPageTimes(), 
                _timeme2.default.timeElapsedCallbacks = [];
            }, this.newPage = function(eventData, searchSessionId) {
                (0, _eventValidation.validateDwellBaseEvent)(eventData), _this.stop(), _this._eventData = eventData, 
                _this._searchSessionId = searchSessionId, _this._initDwellTimeCounterAndPolling();
            }, this._initDwellTimeCounterAndPolling = function() {
                _timeme2.default.initialize({
                    idleTimeoutInSeconds: _this._timing.idleTimeout
                }), _this._pollDwellTime(_this._timing.initialPollInterval, _this._searchSessionId, _this._eventData);
            }, this._pollDwellTime = function(pollTime, searchSessionId, eventData) {
                _timeme2.default.callAfterTimeElapsedInSeconds(pollTime, function() {
                    _this._sendDwellEvent(eventData, searchSessionId, !1), _this._pollDwellTime(pollTime * _this._timing.pollBackoffRate, searchSessionId, eventData);
                });
            }, this._sendDwellEvent = function(eventData, searchSessionId, isFinalDwellEvent) {
                var dwellAttributes = {
                    dwellTime: _timeme2.default.getTimeOnCurrentPageInMilliseconds(),
                    searchReferrer: searchSessionId,
                    finalDwellEvent: isFinalDwellEvent
                };
                _this._trackCallback({
                    action: "dwelled",
                    actionSubject: eventData.actionSubject,
                    actionSubjectId: eventData.actionSubjectId,
                    source: eventData.source,
                    containerType: eventData.containerType,
                    containerId: eventData.containerId,
                    containers: eventData.containers,
                    objectType: eventData.objectType,
                    objectId: eventData.objectId,
                    attributes: (0, _extends3.default)({}, dwellAttributes, eventData.attributes),
                    tags: eventData.tags
                });
            };
        };
        exports.default = DwellTimeHelper;
    }, /* 281 */
    /***/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*Copyright (c) 2017 Jason Zissman
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
        (function() {
            !function(root, factory) {
                if (void 0 !== module && module.exports) // CommonJS
                return module.exports = factory();
                __WEBPACK_AMD_DEFINE_ARRAY__ = [], void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return root.TimeMe = factory();
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            }(this, function() {
                var TimeMe = {
                    startStopTimes: {},
                    idleTimeoutMs: 3e4,
                    currentIdleTimeMs: 0,
                    checkStateRateMs: 250,
                    active: !1,
                    idle: !1,
                    currentPageName: "default-page-name",
                    timeElapsedCallbacks: [],
                    userLeftCallbacks: [],
                    userReturnCallbacks: [],
                    trackTimeOnElement: function(elementId) {
                        var element = document.getElementById(elementId);
                        element && (element.addEventListener("mouseover", function() {
                            TimeMe.startTimer(elementId);
                        }), element.addEventListener("mousemove", function() {
                            TimeMe.startTimer(elementId);
                        }), element.addEventListener("mouseleave", function() {
                            TimeMe.stopTimer(elementId);
                        }), element.addEventListener("keypress", function() {
                            TimeMe.startTimer(elementId);
                        }), element.addEventListener("focus", function() {
                            TimeMe.startTimer(elementId);
                        }));
                    },
                    getTimeOnElementInSeconds: function(elementId) {
                        var time = TimeMe.getTimeOnPageInSeconds(elementId);
                        return time || 0;
                    },
                    startTimer: function(pageName) {
                        if (pageName || (pageName = TimeMe.currentPageName), void 0 === TimeMe.startStopTimes[pageName]) TimeMe.startStopTimes[pageName] = []; else {
                            var arrayOfTimes = TimeMe.startStopTimes[pageName], latestStartStopEntry = arrayOfTimes[arrayOfTimes.length - 1];
                            if (void 0 !== latestStartStopEntry && void 0 === latestStartStopEntry.stopTime) // Can't start new timer until previous finishes.
                            return;
                        }
                        TimeMe.startStopTimes[pageName].push({
                            startTime: new Date(),
                            stopTime: void 0
                        }), TimeMe.active = !0;
                    },
                    stopAllTimers: function() {
                        for (var pageNames = Object.keys(TimeMe.startStopTimes), i = 0; i < pageNames.length; i++) TimeMe.stopTimer(pageNames[i]);
                    },
                    stopTimer: function(pageName) {
                        pageName || (pageName = TimeMe.currentPageName);
                        var arrayOfTimes = TimeMe.startStopTimes[pageName];
                        void 0 !== arrayOfTimes && 0 !== arrayOfTimes.length && (void 0 === arrayOfTimes[arrayOfTimes.length - 1].stopTime && (arrayOfTimes[arrayOfTimes.length - 1].stopTime = new Date()), 
                        TimeMe.active = !1);
                    },
                    getTimeOnCurrentPageInSeconds: function() {
                        return TimeMe.getTimeOnPageInSeconds(TimeMe.currentPageName);
                    },
                    getTimeOnPageInSeconds: function(pageName) {
                        return void 0 === TimeMe.getTimeOnPageInMilliseconds(pageName) ? void 0 : TimeMe.getTimeOnPageInMilliseconds(pageName) / 1e3;
                    },
                    getTimeOnCurrentPageInMilliseconds: function() {
                        return TimeMe.getTimeOnPageInMilliseconds(TimeMe.currentPageName);
                    },
                    getTimeOnPageInMilliseconds: function(pageName) {
                        var arrayOfTimes = TimeMe.startStopTimes[pageName];
                        if (void 0 !== arrayOfTimes) {
                            for (var timeSpentOnPageInSeconds = 0, i = 0; i < arrayOfTimes.length; i++) {
                                var startTime = arrayOfTimes[i].startTime, stopTime = arrayOfTimes[i].stopTime;
                                void 0 === stopTime && (stopTime = new Date());
                                timeSpentOnPageInSeconds += stopTime - startTime;
                            }
                            return Number(timeSpentOnPageInSeconds);
                        }
                    },
                    getTimeOnAllPagesInSeconds: function() {
                        for (var allTimes = [], pageNames = Object.keys(TimeMe.startStopTimes), i = 0; i < pageNames.length; i++) {
                            var pageName = pageNames[i], timeOnPage = TimeMe.getTimeOnPageInSeconds(pageName);
                            allTimes.push({
                                pageName: pageName,
                                timeOnPage: timeOnPage
                            });
                        }
                        return allTimes;
                    },
                    setIdleDurationInSeconds: function(duration) {
                        var durationFloat = parseFloat(duration);
                        if (!1 !== isNaN(durationFloat)) throw {
                            name: "InvalidDurationException",
                            message: "An invalid duration time (" + duration + ") was provided."
                        };
                        return TimeMe.idleTimeoutMs = 1e3 * duration, this;
                    },
                    setCurrentPageName: function(pageName) {
                        return TimeMe.currentPageName = pageName, this;
                    },
                    resetRecordedPageTime: function(pageName) {
                        delete TimeMe.startStopTimes[pageName];
                    },
                    resetAllRecordedPageTimes: function() {
                        for (var pageNames = Object.keys(TimeMe.startStopTimes), i = 0; i < pageNames.length; i++) TimeMe.resetRecordedPageTime(pageNames[i]);
                    },
                    resetIdleCountdown: function() {
                        TimeMe.idle && TimeMe.triggerUserHasReturned(), TimeMe.idle = !1, TimeMe.currentIdleTimeMs = 0;
                    },
                    callWhenUserLeaves: function(callback, numberOfTimesToInvoke) {
                        this.userLeftCallbacks.push({
                            callback: callback,
                            numberOfTimesToInvoke: numberOfTimesToInvoke
                        });
                    },
                    callWhenUserReturns: function(callback, numberOfTimesToInvoke) {
                        this.userReturnCallbacks.push({
                            callback: callback,
                            numberOfTimesToInvoke: numberOfTimesToInvoke
                        });
                    },
                    triggerUserHasReturned: function() {
                        if (!TimeMe.active) for (var i = 0; i < this.userReturnCallbacks.length; i++) {
                            var userReturnedCallback = this.userReturnCallbacks[i], numberTimes = userReturnedCallback.numberOfTimesToInvoke;
                            (isNaN(numberTimes) || void 0 === numberTimes || numberTimes > 0) && (userReturnedCallback.numberOfTimesToInvoke -= 1, 
                            userReturnedCallback.callback());
                        }
                        TimeMe.startTimer();
                    },
                    triggerUserHasLeftPage: function() {
                        if (TimeMe.active) for (var i = 0; i < this.userLeftCallbacks.length; i++) {
                            var userHasLeftCallback = this.userLeftCallbacks[i], numberTimes = userHasLeftCallback.numberOfTimesToInvoke;
                            (isNaN(numberTimes) || void 0 === numberTimes || numberTimes > 0) && (userHasLeftCallback.numberOfTimesToInvoke -= 1, 
                            userHasLeftCallback.callback());
                        }
                        TimeMe.stopAllTimers();
                    },
                    callAfterTimeElapsedInSeconds: function(timeInSeconds, callback) {
                        TimeMe.timeElapsedCallbacks.push({
                            timeInSeconds: timeInSeconds,
                            callback: callback,
                            pending: !0
                        });
                    },
                    checkState: function() {
                        for (var i = 0; i < TimeMe.timeElapsedCallbacks.length; i++) TimeMe.timeElapsedCallbacks[i].pending && TimeMe.getTimeOnCurrentPageInSeconds() > TimeMe.timeElapsedCallbacks[i].timeInSeconds && (TimeMe.timeElapsedCallbacks[i].callback(), 
                        TimeMe.timeElapsedCallbacks[i].pending = !1);
                        !1 === TimeMe.idle && TimeMe.currentIdleTimeMs > TimeMe.idleTimeoutMs ? (TimeMe.idle = !0, 
                        TimeMe.triggerUserHasLeftPage()) : TimeMe.currentIdleTimeMs += TimeMe.checkStateRateMs;
                    },
                    visibilityChangeEventName: void 0,
                    hiddenPropName: void 0,
                    listenForVisibilityEvents: function() {
                        void 0 !== document.hidden ? (TimeMe.hiddenPropName = "hidden", TimeMe.visibilityChangeEventName = "visibilitychange") : void 0 !== document.mozHidden ? (TimeMe.hiddenPropName = "mozHidden", 
                        TimeMe.visibilityChangeEventName = "mozvisibilitychange") : void 0 !== document.msHidden ? (TimeMe.hiddenPropName = "msHidden", 
                        TimeMe.visibilityChangeEventName = "msvisibilitychange") : void 0 !== document.webkitHidden && (TimeMe.hiddenPropName = "webkitHidden", 
                        TimeMe.visibilityChangeEventName = "webkitvisibilitychange"), document.addEventListener(TimeMe.visibilityChangeEventName, function() {
                            document[TimeMe.hiddenPropName] ? TimeMe.triggerUserHasLeftPage() : TimeMe.triggerUserHasReturned();
                        }, !1), window.addEventListener("blur", function() {
                            TimeMe.triggerUserHasLeftPage();
                        }), window.addEventListener("focus", function() {
                            TimeMe.triggerUserHasReturned();
                        }), document.addEventListener("mousemove", function() {
                            TimeMe.resetIdleCountdown();
                        }), document.addEventListener("keyup", function() {
                            TimeMe.resetIdleCountdown();
                        }), document.addEventListener("touchstart", function() {
                            TimeMe.resetIdleCountdown();
                        }), window.addEventListener("scroll", function() {
                            TimeMe.resetIdleCountdown();
                        }), setInterval(function() {
                            TimeMe.checkState();
                        }, TimeMe.checkStateRateMs);
                    },
                    websocket: void 0,
                    websocketHost: void 0,
                    setUpWebsocket: function(websocketOptions) {
                        if (window.WebSocket && websocketOptions) {
                            var websocketHost = websocketOptions.websocketHost;
                            // "ws://hostname:port"
                            try {
                                TimeMe.websocket = new WebSocket(websocketHost), window.onbeforeunload = function(event) {
                                    TimeMe.sendCurrentTime(websocketOptions.appId);
                                }, TimeMe.websocket.onopen = function() {
                                    TimeMe.sendInitWsRequest(websocketOptions.appId);
                                }, TimeMe.websocket.onerror = function(error) {
                                    console && console.log("Error occurred in websocket connection: " + error);
                                }, TimeMe.websocket.onmessage = function(event) {
                                    console && console.log(event.data);
                                };
                            } catch (error) {
                                console && console.error("Failed to connect to websocket host.  Error:" + error);
                            }
                        }
                        return this;
                    },
                    websocketSend: function(data) {
                        TimeMe.websocket.send(JSON.stringify(data));
                    },
                    sendCurrentTime: function(appId) {
                        var timeSpentOnPage = TimeMe.getTimeOnCurrentPageInMilliseconds(), data = {
                            type: "INSERT_TIME",
                            appId: appId,
                            timeOnPageMs: timeSpentOnPage,
                            pageName: TimeMe.currentPageName
                        };
                        TimeMe.websocketSend(data);
                    },
                    sendInitWsRequest: function(appId) {
                        var data = {
                            type: "INIT",
                            appId: appId
                        };
                        TimeMe.websocketSend(data);
                    },
                    initialize: function(options) {
                        var idleTimeoutInSeconds = TimeMe.idleTimeoutMs || 30, currentPageName = TimeMe.currentPageName || "default-page-name", websocketOptions = void 0;
                        options && (idleTimeoutInSeconds = options.idleTimeoutInSeconds || idleTimeoutInSeconds, 
                        currentPageName = options.currentPageName || currentPageName, websocketOptions = options.websocketOptions), 
                        TimeMe.setIdleDurationInSeconds(idleTimeoutInSeconds).setCurrentPageName(currentPageName).setUpWebsocket(websocketOptions).listenForVisibilityEvents(), 
                        // TODO - only do this if page currently visible.
                        TimeMe.startTimer();
                    }
                };
                return TimeMe;
            });
        }).call(this);
    }, /* 282 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(10), _extends3 = _interopRequireDefault(_extends2), _classCallCheck2 = __webpack_require__(1), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _browserInteractionTime = __webpack_require__(283), _browserInteractionTime2 = _interopRequireDefault(_browserInteractionTime), _eventValidation = __webpack_require__(82), DEFAULT_TIMING = {
            initialPollInterval: 5e3,
            idleTimeout: 3e4,
            multiplierCallback: function(x) {
                return x + x;
            }
        }, DwellTimeHelper = /**
 * Callback for sending a 'track' analytics event. This callback should either be the
 * 'sendTrackEvent' method on the AnalyticsWebClient, or a method that eventually delegates to it.
 * The data for the dwell event will be passed to this method for sending.
 *
 * @callback trackCallback
 * @param {Object} eventData - the base event data that will be added to the track event.
 */
        /**
 * Creates and initialises the DwellTimeHelper.
 *
 * @param {trackCallback} trackCallback - the track callback responsible for actually sending
 * the event.
 * @param {Object} eventData - the base data that will be added to the track event.
 * Additional dwell time attributes will be appended to this data. Note that you don't need to
 * include the 'action' property, as this will be added automatically.
 * @param {?string} searchSessionId - a unique identifier for the related search session.
 * @param {?Object} timingOptions - for the purpose of debugging, you can override the default
 * timing used for measuring dwell time. The following values are possible:
 * - initialPollInterval: how long to wait before the first dwell milestone event
 * is fired (in seconds). Default = 5.
 * - pollBackoffRate: how much to multiply the last poll interval by on each dwell milestone.
 * event. Default = 2.
 * - idleTimeout: how long to wait for no user activity before pausing
 * the dwell timer (in seconds). Default = 30s.
 */
        function DwellTimeHelper(trackCallback, eventData, searchSessionId, timingOptions) {
            if ((0, _classCallCheck3.default)(this, DwellTimeHelper), _initialiseProps.call(this), 
            !trackCallback) throw new Error("trackCallback is required for DwellTimeHelper");
            (0, _eventValidation.validateDwellBaseEvent)(eventData), this._trackCallback = trackCallback, 
            this._eventData = eventData, this._searchSessionId = searchSessionId, this._timing = (0, 
            _extends3.default)({}, DEFAULT_TIMING, timingOptions), this.browserInteractionTime = new _browserInteractionTime2.default({
                idleTimeoutMs: this._timing.idleTimeout,
                checkCallbacksIntervalMs: 500
            });
        }, _initialiseProps = function() {
            var _this = this;
            this.start = function() {
                _this.browserInteractionTime.startTimer(), _this.browserInteractionTime.addTimeIntervalEllapsedCallback({
                    callback: function(timeInMilliseconds) {
                        return _this._sendDwellEvent(_this._eventData, _this._searchSessionId, timeInMilliseconds, !1);
                    },
                    timeInMilliseconds: _this._timing.initialPollInterval,
                    multiplier: _this._timing.multiplierCallback
                }), window.addEventListener("beforeunload", _this._onBeforeUnload);
            }, this.stop = function() {
                _this.browserInteractionTime.isRunning() && _this._sendDwellEvent(_this._eventData, _this._searchSessionId, _this.browserInteractionTime.getTimeInMilliseconds(), !0), 
                _this.browserInteractionTime.stopTimer();
            }, this.newPage = function(eventData, searchSessionId) {
                (0, _eventValidation.validateDwellBaseEvent)(eventData), _this.stop(), _this.browserInteractionTime.reset(), 
                _this.setEventData(eventData), _this.setSearchSessionId(searchSessionId), _this.start();
            }, this.setEventData = function(eventData) {
                _this._eventData = eventData;
            }, this.getEventData = function() {
                return _this._eventData;
            }, this.setSearchSessionId = function(searchSessionId) {
                _this._searchSessionId = searchSessionId;
            }, this.getSearchSessionId = function() {
                return _this._searchSessionId;
            }, this.destroy = function() {
                _this.browserInteractionTime.destroy(), window.removeEventListener("beforeunload", _this._onBeforeUnload);
            }, this._onBeforeUnload = function() {
                _this.stop(), _this.destroy();
            }, this._sendDwellEvent = function(eventData, searchSessionId, timeInMilliseconds, isFinalDwellEvent) {
                var dwellAttributes = {
                    dwellTime: timeInMilliseconds,
                    searchReferrer: searchSessionId,
                    finalDwellEvent: isFinalDwellEvent
                };
                _this._trackCallback({
                    action: "dwelled",
                    actionSubject: eventData.actionSubject,
                    actionSubjectId: eventData.actionSubjectId,
                    source: eventData.source,
                    containerType: eventData.containerType,
                    containerId: eventData.containerId,
                    objectType: eventData.objectType,
                    objectId: eventData.objectId,
                    attributes: (0, _extends3.default)({}, dwellAttributes, eventData.attributes),
                    tags: eventData.tags
                });
            };
        };
        exports.default = DwellTimeHelper;
    }, /* 283 */
    /***/
    function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        Object.defineProperty(__webpack_exports__, "__esModule", {
            value: !0
        }), /* WEBPACK VAR INJECTION */
        function(global) {
            /**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
            function isObject(value) {
                var type = typeof value;
                return null != value && ("object" == type || "function" == type);
            }
            /**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = void 0;
                    var unmasked = !0;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
                result;
            }
            /**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
            function objectToString(value) {
                return nativeObjectToString$1.call(value);
            }
            /**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
            function baseGetTag(value) {
                return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
            }
            /**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
            function isObjectLike(value) {
                return null != value && "object" == typeof value;
            }
            /**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
            function isSymbol(value) {
                return "symbol" == typeof value || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
            }
            /**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
            function toNumber(value) {
                if ("number" == typeof value) return value;
                if (isSymbol_1(value)) return NAN;
                if (isObject_1(value)) {
                    var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                    value = isObject_1(other) ? other + "" : other;
                }
                if ("string" != typeof value) return 0 === value ? value : +value;
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            /**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
            function debounce(func, wait, options) {
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
                }
                function leadingEdge(time) {
                    // Invoke the leading edge.
                    // Reset any `maxWait` timer.
                    // Start the timer for the trailing edge.
                    return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    // Either this is the first call, activity has stopped and we're at the
                    // trailing edge, the system time has gone backwards and we're treating
                    // it as the trailing edge, or we've hit the `maxWait` limit.
                    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now_1();
                    if (shouldInvoke(time)) return trailingEdge(time);
                    // Restart the timer.
                    timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
                    result);
                }
                function cancel() {
                    void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                    return void 0 === timerId ? result : trailingEdge(now_1());
                }
                function debounced() {
                    var time = now_1(), isInvoking = shouldInvoke(time);
                    if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                        if (void 0 === timerId) return leadingEdge(lastCallTime);
                        if (maxing) // Handle invocations in a tight loop.
                        return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
                    }
                    return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
                }
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                return wait = toNumber_1(wait) || 0, isObject_1(options) && (leading = !!options.leading, 
                maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait, 
                trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
                debounced.flush = flush, debounced;
            }
            /**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
            function throttle(func, wait, options) {
                var leading = !0, trailing = !0;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT$1);
                return isObject_1(options) && (leading = "leading" in options ? !!options.leading : leading, 
                trailing = "trailing" in options ? !!options.trailing : trailing), debounce_1(func, wait, {
                    leading: leading,
                    maxWait: wait,
                    trailing: trailing
                });
            }
            var isObject_1 = isObject, commonjsGlobal = "undefined" != typeof window ? window : void 0 !== global ? global : "undefined" != typeof self ? self : {}, freeGlobal = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = _freeGlobal || freeSelf || Function("return this")(), _root = root, now = function() {
                return _root.Date.now();
            }, now_1 = now, Symbol = _root.Symbol, _Symbol = Symbol, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = _Symbol ? _Symbol.toStringTag : void 0, _getRawTag = getRawTag, objectProto$1 = Object.prototype, nativeObjectToString$1 = objectProto$1.toString, _objectToString = objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag$1 = _Symbol ? _Symbol.toStringTag : void 0, _baseGetTag = baseGetTag, isObjectLike_1 = isObjectLike, symbolTag = "[object Symbol]", isSymbol_1 = isSymbol, NAN = NaN, reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, toNumber_1 = toNumber, FUNC_ERROR_TEXT = "Expected a function", nativeMax = Math.max, nativeMin = Math.min, debounce_1 = debounce, FUNC_ERROR_TEXT$1 = "Expected a function", throttle_1 = throttle, windowIdleEvents = [ "scroll", "resize" ], documentIdleEvents = [ "mousemove", "keyup", "keydown", "touchstart", "click", "contextmenu" ], BrowserInteractionTime = /** @class */ function() {
                function BrowserInteractionTime(_a) {
                    var timeIntervalEllapsedCallbacks = _a.timeIntervalEllapsedCallbacks, absoluteTimeEllapsedCallbacks = _a.absoluteTimeEllapsedCallbacks, checkCallbacksIntervalMs = _a.checkCallbacksIntervalMs, browserTabInactiveCallbacks = _a.browserTabInactiveCallbacks, browserTabActiveCallbacks = _a.browserTabActiveCallbacks, idleTimeoutMs = _a.idleTimeoutMs, _this = this;
                    this.onBrowserTabInactive = function(event) {
                        // if running pause timer
                        _this.isRunning() && _this.stopTimer(), _this.browserTabInactiveCallbacks.forEach(function(fn) {
                            return fn(_this.getTimeInMilliseconds());
                        });
                    }, this.onBrowserTabActive = function(event) {
                        // if not running start timer
                        _this.isRunning() || _this.startTimer(), _this.browserTabActiveCallbacks.forEach(function(fn) {
                            return fn(_this.getTimeInMilliseconds());
                        });
                    }, this.onTimePassed = function() {
                        // check all callbacks time and if passed execute callback
                        _this.absoluteTimeEllapsedCallbacks.forEach(function(_a, index) {
                            var callback = _a.callback, pending = _a.pending, timeInMilliseconds = _a.timeInMilliseconds;
                            pending && timeInMilliseconds <= _this.getTimeInMilliseconds() && (callback(_this.getTimeInMilliseconds()), 
                            _this.absoluteTimeEllapsedCallbacks[index].pending = !1);
                        }), _this.timeIntervalEllapsedCallbacks.forEach(function(_a, index) {
                            var callback = _a.callback, timeInMilliseconds = _a.timeInMilliseconds, multiplier = _a.multiplier;
                            timeInMilliseconds <= _this.getTimeInMilliseconds() && (callback(_this.getTimeInMilliseconds()), 
                            _this.timeIntervalEllapsedCallbacks[index].timeInMilliseconds = multiplier(timeInMilliseconds));
                        }), _this.currentIdleTimeMs >= _this.idleTimeoutMs && _this.isRunning() ? (_this.idle = !0, 
                        _this.stopTimer()) : _this.currentIdleTimeMs += _this.checkCallbacksIntervalMs;
                    }, this.resetIdleTime = function() {
                        _this.idle && _this.startTimer(), _this.idle = !1, _this.currentIdleTimeMs = 0;
                    }, this.registerEventListeners = function() {
                        var eventListenerOptions = {
                            passive: !0
                        };
                        window.addEventListener("blur", _this.onBrowserTabInactive, eventListenerOptions), 
                        window.addEventListener("focus", _this.onBrowserTabActive, eventListenerOptions);
                        var throttleResetIdleTime = throttle_1(_this.resetIdleTime, 2e3, {
                            leading: !0,
                            trailing: !1
                        });
                        windowIdleEvents.forEach(function(event) {
                            window.addEventListener(event, throttleResetIdleTime, eventListenerOptions);
                        }), documentIdleEvents.forEach(function(event) {
                            return document.addEventListener(event, throttleResetIdleTime, eventListenerOptions);
                        });
                    }, this.unregisterEventListeners = function() {
                        window.removeEventListener("blur", _this.onBrowserTabInactive), window.removeEventListener("focus", _this.onBrowserTabActive), 
                        windowIdleEvents.forEach(function(event) {
                            return window.removeEventListener(event, _this.resetIdleTime);
                        }), documentIdleEvents.forEach(function(event) {
                            return document.removeEventListener(event, _this.resetIdleTime);
                        });
                    }, this.checkCallbacksOnInterval = function() {
                        _this.checkCallbackIntervalId = window.setInterval(function() {
                            _this.onTimePassed();
                        }, _this.checkCallbacksIntervalMs);
                    }, this.startTimer = function() {
                        _this.checkCallbackIntervalId || _this.checkCallbacksOnInterval();
                        var last = _this.times[_this.times.length - 1];
                        last && null === last.stop || (_this.times.push({
                            start: performance.now(),
                            stop: null
                        }), _this.running = !0);
                    }, this.stopTimer = function() {
                        _this.times.length && (_this.times[_this.times.length - 1].stop = performance.now(), 
                        _this.running = !1);
                    }, this.addTimeIntervalEllapsedCallback = function(timeIntervalEllapsedCallback) {
                        _this.timeIntervalEllapsedCallbacks.push(timeIntervalEllapsedCallback);
                    }, this.addAbsoluteTimeEllapsedCallback = function(absoluteTimeEllapsedCallback) {
                        _this.absoluteTimeEllapsedCallbacks.push(absoluteTimeEllapsedCallback);
                    }, this.addBrowserTabInactiveCallback = function(browserTabInactiveCallback) {
                        _this.browserTabInactiveCallbacks.push(browserTabInactiveCallback);
                    }, this.addBrowserTabActiveCallback = function(browserTabActiveCallback) {
                        _this.browserTabActiveCallbacks.push(browserTabActiveCallback);
                    }, this.getTimeInMilliseconds = function() {
                        return _this.times.reduce(function(acc, current) {
                            return current.stop ? acc += current.stop - current.start : acc += performance.now() - current.start, 
                            acc;
                        }, 0);
                    }, this.isRunning = function() {
                        return _this.running;
                    }, this.reset = function() {
                        _this.times = [];
                    }, this.destroy = function() {
                        _this.unregisterEventListeners(), _this.checkCallbackIntervalId && window.clearInterval(_this.checkCallbackIntervalId);
                    }, this.running = !1, this.times = [], this.idle = !1, this.currentIdleTimeMs = 0, 
                    this.marks = {}, this.measures = {}, this.browserTabActiveCallbacks = browserTabActiveCallbacks || [], 
                    this.browserTabInactiveCallbacks = browserTabInactiveCallbacks || [], this.checkCallbacksIntervalMs = checkCallbacksIntervalMs || 100, 
                    this.idleTimeoutMs = idleTimeoutMs || 3e3, // 3s
                    this.timeIntervalEllapsedCallbacks = timeIntervalEllapsedCallbacks || [], this.absoluteTimeEllapsedCallbacks = absoluteTimeEllapsedCallbacks || [], 
                    this.registerEventListeners();
                }
                return BrowserInteractionTime.prototype.mark = function(key) {
                    this.marks[key] || (this.marks[key] = []), this.marks[key].push({
                        time: this.getTimeInMilliseconds()
                    });
                }, BrowserInteractionTime.prototype.getMarks = function(name) {
                    if (!(this.marks[name].length < 1)) return this.marks[name];
                }, BrowserInteractionTime.prototype.measure = function(name, startMarkName, endMarkName) {
                    var startMarks = this.marks[startMarkName], startMark = startMarks[startMarks.length - 1], endMarks = this.marks[endMarkName], endMark = endMarks[endMarks.length - 1];
                    this.measures[name] || (this.measures[name] = []), this.measures[name].push({
                        name: name,
                        startTime: startMark.time,
                        duration: endMark.time - startMark.time
                    });
                }, BrowserInteractionTime.prototype.getMeasures = function(name) {
                    if (this.measures[name] || !(this.measures[name].length < 1)) return this.measures[name];
                }, BrowserInteractionTime;
            }();
            /* harmony default export */
            __webpack_exports__.default = BrowserInteractionTime;
        }.call(__webpack_exports__, __webpack_require__(17));
    } ]);
});}(globalRequire.define));